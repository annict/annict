# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `playwright-ruby-client` gem.
# Please instead update this file by running `bin/tapioca gem playwright-ruby-client`.


# namespace declaration
#
# source://playwright-ruby-client//lib/playwright.rb#4
module Playwright
  private

  # Playwright.connect_to_android_server('ws://....') do |browser|
  #   page = browser.new_page
  #   ...
  # end
  #
  # source://playwright-ruby-client//lib/playwright.rb#190
  def connect_to_android_server(ws_endpoint, &block); end

  # Connects to Playwright server, launched by `npx playwright launch-server chromium` or `playwright.chromium.launchServer()`
  #
  # Playwright.connect_to_browser_server('ws://....') do |browser|
  #   page = browser.new_page
  #   ...
  # end
  #
  # source://playwright-ruby-client//lib/playwright.rb#149
  def connect_to_browser_server(ws_endpoint, &block); end

  # Connects to Playwright server, launched by `npx playwright run-server` via WebSocket transport.
  #
  # Playwright.connect_to_playwright_server(...) do |playwright|
  #   browser = playwright.chromium.launch
  #   ...
  # end
  #
  # source://playwright-ruby-client//lib/playwright.rb#113
  def connect_to_playwright_server(ws_endpoint, &block); end

  # Recommended to call this method with block.
  #
  # Playwright.create(...) do |playwright|
  #   browser = playwright.chromium.launch
  #   ...
  # end
  #
  # When we use this method without block, an instance of Playwright::Execution is returned
  # and we *must* call execution.stop on the end.
  # The instance of playwright is available by calling execution.playwright
  #
  # source://playwright-ruby-client//lib/playwright.rb#80
  def create(playwright_cli_executable_path:, &block); end

  class << self
    # Playwright.connect_to_android_server('ws://....') do |browser|
    #   page = browser.new_page
    #   ...
    # end
    #
    # source://playwright-ruby-client//lib/playwright.rb#190
    def connect_to_android_server(ws_endpoint, &block); end

    # Connects to Playwright server, launched by `npx playwright launch-server chromium` or `playwright.chromium.launchServer()`
    #
    # Playwright.connect_to_browser_server('ws://....') do |browser|
    #   page = browser.new_page
    #   ...
    # end
    #
    # source://playwright-ruby-client//lib/playwright.rb#149
    def connect_to_browser_server(ws_endpoint, &block); end

    # Connects to Playwright server, launched by `npx playwright run-server` via WebSocket transport.
    #
    # Playwright.connect_to_playwright_server(...) do |playwright|
    #   browser = playwright.chromium.launch
    #   ...
    # end
    #
    # source://playwright-ruby-client//lib/playwright.rb#113
    def connect_to_playwright_server(ws_endpoint, &block); end

    # Recommended to call this method with block.
    #
    # Playwright.create(...) do |playwright|
    #   browser = playwright.chromium.launch
    #   ...
    # end
    #
    # When we use this method without block, an instance of Playwright::Execution is returned
    # and we *must* call execution.stop on the end.
    # The instance of playwright is available by calling execution.playwright
    #
    # source://playwright-ruby-client//lib/playwright.rb#80
    def create(playwright_cli_executable_path:, &block); end

    # source://playwright-ruby-client//lib/playwright/api_implementation.rb#6
    def define_api_implementation(class_name, &block); end

    # source://playwright-ruby-client//lib/playwright/channel_owner.rb#149
    def define_channel_owner(class_name, &block); end
  end
end

# Exposes API that can be used for the Web API testing. This class is used for creating
# `APIRequestContext` instance which in turn can be used for sending web requests. An instance
# of this class can be obtained via [`property: Playwright.request`]. For more information
# see `APIRequestContext`.
#
# source://playwright-ruby-client//lib/playwright_api/api_request.rb#7
class Playwright::APIRequest < ::Playwright::PlaywrightApi
  # Creates new instances of `APIRequestContext`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request.rb#11
  def new_context(baseURL: T.unsafe(nil), clientCertificates: T.unsafe(nil), extraHTTPHeaders: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), httpCredentials: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), proxy: T.unsafe(nil), storageState: T.unsafe(nil), timeout: T.unsafe(nil), userAgent: T.unsafe(nil)); end
end

# This API is used for the Web API testing. You can use it to trigger API endpoints, configure micro-services, prepare
# environment or the service to your e2e test.
#
# Each Playwright browser context has associated with it `APIRequestContext` instance which shares cookie storage with
# the browser context and can be accessed via [`property: BrowserContext.request`] or [`property: Page.request`].
# It is also possible to create a new APIRequestContext instance manually by calling [`method: APIRequest.newContext`].
#
# **Cookie management**
#
# `APIRequestContext` returned by [`property: BrowserContext.request`] and [`property: Page.request`] shares cookie
# storage with the corresponding `BrowserContext`. Each API request will have `Cookie` header populated with the
# values from the browser context. If the API response contains `Set-Cookie` header it will automatically update
# `BrowserContext` cookies and requests made from the page will pick them up. This means that if you log in using
# this API, your e2e test will be logged in and vice versa.
#
# If you want API requests to not interfere with the browser cookies you should create a new `APIRequestContext` by
# calling [`method: APIRequest.newContext`]. Such `APIRequestContext` object will have its own isolated cookie
# storage.
#
# ```python sync
# import os
# from playwright.sync_api import sync_playwright
#
# REPO = "test-repo-1"
# USER = "github-username"
# API_TOKEN = os.getenv("GITHUB_API_TOKEN")
#
# with sync_playwright() as p:
#     # This will launch a new browser, create a context and page. When making HTTP
#     # requests with the internal APIRequestContext (e.g. `context.request` or `page.request`)
#     # it will automatically set the cookies to the browser page and vice versa.
#     browser = p.chromium.launch()
#     context = browser.new_context(base_url="https://api.github.com")
#     api_request_context = context.request
#     page = context.new_page()
#
#     # Alternatively you can create a APIRequestContext manually without having a browser context attached:
#     # api_request_context = p.request.new_context(base_url="https://api.github.com")
#
#
#     # Create a repository.
#     response = api_request_context.post(
#         "/user/repos",
#         headers={
#             "Accept": "application/vnd.github.v3+json",
#             # Add GitHub personal access token.
#             "Authorization": f"token {API_TOKEN}",
#         },
#         data={"name": REPO},
#     )
#     assert response.ok
#     assert response.json()["name"] == REPO
#
#     # Delete a repository.
#     response = api_request_context.delete(
#         f"/repos/{USER}/{REPO}",
#         headers={
#             "Accept": "application/vnd.github.v3+json",
#             # Add GitHub personal access token.
#             "Authorization": f"token {API_TOKEN}",
#         },
#     )
#     assert response.ok
#     assert await response.body() == '{"status": "ok"}'
# ```
#
# source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#68
class Playwright::APIRequestContext < ::Playwright::PlaywrightApi
  # Sends HTTP(S) [DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE) request and returns its response.
  # The method will populate request cookies from the context and update
  # context cookies from the response. The method will automatically follow redirects.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#74
  def delete(url, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # All responses returned by [`method: APIRequestContext.get`] and similar methods are stored in the memory, so that you can later call [`method: APIResponse.body`].This method discards all its resources, calling any method on disposed `APIRequestContext` will throw an exception.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#91
  def dispose(reason: T.unsafe(nil)); end

  # Sends HTTP(S) request and returns its response. The method will populate request cookies from the context and update
  # context cookies from the response. The method will automatically follow redirects.
  #
  # **Usage**
  #
  # JSON objects can be passed directly to the request:
  #
  # ```python
  # data = {
  #     "title": "Book Title",
  #     "body": "John Doe",
  # }
  # api_request_context.fetch("https://example.com/api/createBook", method="post", data=data)
  # ```
  #
  # The common way to send file(s) in the body of a request is to upload them as form fields with `multipart/form-data` encoding, by specifiying the `multipart` parameter:
  #
  # ```python
  # api_request_context.fetch(
  #   "https://example.com/api/uploadScript",  method="post",
  #   multipart={
  #     "fileField": {
  #       "name": "f.js",
  #       "mimeType": "text/javascript",
  #       "buffer": b"console.log(2022);",
  #     },
  #   })
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#124
  def fetch(urlOrRequest, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), method: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Sends HTTP(S) [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) request and returns its response.
  # The method will populate request cookies from the context and update
  # context cookies from the response. The method will automatically follow redirects.
  #
  # **Usage**
  #
  # Request parameters can be configured with `params` option, they will be serialized into the URL search parameters:
  #
  # ```python
  # query_params = {
  #   "isbn": "1234",
  #   "page": "23"
  # }
  # api_request_context.get("https://example.com/api/getText", params=query_params)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#156
  def get(url, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Sends HTTP(S) [HEAD](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD) request and returns its response.
  # The method will populate request cookies from the context and update
  # context cookies from the response. The method will automatically follow redirects.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#175
  def head(url, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#303
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#297
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#291
  def once(event, callback); end

  # Sends HTTP(S) [PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) request and returns its response.
  # The method will populate request cookies from the context and update
  # context cookies from the response. The method will automatically follow redirects.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#194
  def patch(url, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Sends HTTP(S) [POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) request and returns its response.
  # The method will populate request cookies from the context and update
  # context cookies from the response. The method will automatically follow redirects.
  #
  # **Usage**
  #
  # JSON objects can be passed directly to the request:
  #
  # ```python
  # data = {
  #     "title": "Book Title",
  #     "body": "John Doe",
  # }
  # api_request_context.post("https://example.com/api/createBook", data=data)
  # ```
  #
  # To send form data to the server use `form` option. Its value will be encoded into the request body with `application/x-www-form-urlencoded` encoding (see below how to use `multipart/form-data` form encoding to send files):
  #
  # ```python
  # formData = {
  #     "title": "Book Title",
  #     "body": "John Doe",
  # }
  # api_request_context.post("https://example.com/api/findBook", form=formData)
  # ```
  #
  # The common way to send file(s) in the body of a request is to upload them as form fields with `multipart/form-data` encoding. Use `FormData` to construct request body and pass it to the request as `multipart` parameter:
  #
  # ```python
  # api_request_context.post(
  #   "https://example.com/api/uploadScript'",
  #   multipart={
  #     "fileField": {
  #       "name": "f.js",
  #       "mimeType": "text/javascript",
  #       "buffer": b"console.log(2022);",
  #     },
  #   })
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#249
  def post(url, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Sends HTTP(S) [PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT) request and returns its response.
  # The method will populate request cookies from the context and update
  # context cookies from the response. The method will automatically follow redirects.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#268
  def put(url, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns storage state for this request context, contains current cookies and local storage snapshot if it was passed to the constructor.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#285
  def storage_state(indexedDB: T.unsafe(nil), path: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright_api/api_request_context.rb#307
  def event_emitter_proxy; end
end

# `APIResponse` class represents responses returned by [`method: APIRequestContext.get`] and similar methods.
#
# ```python sync
# from playwright.sync_api import sync_playwright
#
# with sync_playwright() as p:
#     context = playwright.request.new_context()
#     response = context.get("https://example.com/user/repos")
#     assert response.ok
#     assert response.status == 200
#     assert response.headers["content-type"] == "application/json; charset=utf-8"
#     assert response.json()["name"] == "foobar"
#     assert response.body() == '{"status": "ok"}'
# ```
#
# source://playwright-ruby-client//lib/playwright_api/api_response.rb#17
class Playwright::APIResponse < ::Playwright::PlaywrightApi
  # Returns the buffer with response body.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#21
  def body; end

  # Disposes the body of this response. If not called then the body will stay in memory until the context closes.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#27
  def dispose; end

  # An object with all the response HTTP headers associated with this response.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#33
  def headers; end

  # An array with all the response HTTP headers associated with this response. Header names are not lower-cased.
  # Headers with multiple entries, such as `Set-Cookie`, appear in the array multiple times.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#40
  def headers_array; end

  # Returns the JSON representation of response body.
  #
  # This method will throw if the response body is not parsable via `JSON.parse`.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#48
  def json; end

  # Contains a boolean stating whether the response was successful (status in the range 200-299) or not.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#54
  def ok; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#83
  def ok?; end

  # Contains the status code of the response (e.g., 200 for a success).
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#60
  def status; end

  # Contains the status text of the response (e.g. usually an "OK" for a success).
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#66
  def status_text; end

  # Returns the text representation of response body.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#72
  def text; end

  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#88
  def to_s; end

  # Contains the URL of the response.
  #
  # source://playwright-ruby-client//lib/playwright_api/api_response.rb#78
  def url; end
end

# source://playwright-ruby-client//lib/playwright/api_response_impl.rb#0
class Playwright::APIResponseImpl
  include ::Playwright::ApiImplementation
  include ::Playwright::Utils::Errors::TargetClosedErrorMethods

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#7
  def initialize(context, initializer); end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#48
  def body; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#65
  def dispose; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#34
  def headers; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#38
  def headers_array; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#61
  def json; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#21
  def ok; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#21
  def ok?; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#26
  def status; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#30
  def status_text; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#48
  def text; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#13
  def to_s; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#17
  def url; end

  private

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#69
  def _request; end

  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#73
  def fetch_uid; end
end

# The Accessibility class provides methods for inspecting Chromium's accessibility tree. The accessibility tree is used by
# assistive technology such as [screen readers](https://en.wikipedia.org/wiki/Screen_reader) or
# [switches](https://en.wikipedia.org/wiki/Switch_access).
#
# Accessibility is a very platform-specific thing. On different platforms, there are different screen readers that might
# have wildly different output.
#
# Rendering engines of Chromium, Firefox and WebKit have a concept of "accessibility tree", which is then translated into different
# platform-specific APIs. Accessibility namespace gives access to this Accessibility Tree.
#
# Most of the accessibility tree gets filtered out when converting from internal browser AX Tree to Platform-specific AX-Tree or by
# assistive technologies themselves. By default, Playwright tries to approximate this filtering, exposing only the
# "interesting" nodes of the tree.
#
# source://playwright-ruby-client//lib/playwright_api/accessibility.rb#16
class Playwright::Accessibility < ::Playwright::PlaywrightApi
  # Captures the current state of the accessibility tree. The returned object represents the root accessible node of the
  # page.
  #
  # **NOTE**: The Chromium accessibility tree contains nodes that go unused on most platforms and by most screen readers. Playwright
  # will discard them as well for an easier to process tree, unless `interestingOnly` is set to `false`.
  #
  # **Usage**
  #
  # An example of dumping the entire accessibility tree:
  #
  # ```python sync
  # snapshot = page.accessibility.snapshot()
  # print(snapshot)
  # ```
  #
  # An example of logging the focused node's name:
  #
  # ```python sync
  # def find_focused_node(node):
  #     if node.get("focused"):
  #         return node
  #     for child in (node.get("children") or []):
  #         found_node = find_focused_node(child)
  #         if found_node:
  #             return found_node
  #     return None
  #
  # snapshot = page.accessibility.snapshot()
  # node = find_focused_node(snapshot)
  # if node:
  #     print(node["name"])
  # ```
  #
  # @deprecated This method is deprecated. Please use other libraries such as [Axe](https://www.deque.com/axe/) if you need to test page accessibility. See our Node.js [guide](https://playwright.dev/docs/accessibility-testing) for integration with Axe.
  #
  # source://playwright-ruby-client//lib/playwright_api/accessibility.rb#53
  def snapshot(interestingOnly: T.unsafe(nil), root: T.unsafe(nil)); end
end

# source://playwright-ruby-client//lib/playwright/accessibility_impl.rb#0
class Playwright::AccessibilityImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/accessibility_impl.rb#3
  def initialize(channel); end

  # source://playwright-ruby-client//lib/playwright/accessibility_impl.rb#7
  def snapshot(interestingOnly: T.unsafe(nil), root: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/accessibility_impl.rb#19
  def format_ax_node_from_protocol(ax_node); end
end

# source://playwright-ruby-client//lib/playwright/api_response_impl.rb#42
class Playwright::AlreadyDisposedError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/api_response_impl.rb#43
  def initialize; end
end

# Playwright has **experimental** support for Android automation. This includes Chrome for Android and Android WebView.
#
# *Requirements*
# - Android device or AVD Emulator.
# - [ADB daemon](https://developer.android.com/studio/command-line/adb) running and authenticated with your device. Typically running `adb devices` is all you need to do.
# - [`Chrome 87`](https://play.google.com/store/apps/details?id=com.android.chrome) or newer installed on the device
# - "Enable command line on non-rooted devices" enabled in `chrome://flags`.
#
# *Known limitations*
# - Raw USB operation is not yet supported, so you need ADB.
# - Device needs to be awake to produce screenshots. Enabling "Stay awake" developer mode will help.
# - We didn't run all the tests against the device, so not everything works.
#
# *How to run*
#
# An example of the Android automation script would be:
#
# source://playwright-ruby-client//lib/playwright_api/android.rb#19
class Playwright::Android < ::Playwright::PlaywrightApi
  # This methods attaches Playwright to an existing Android device.
  # Use [`method: Android.launchServer`] to launch a new Android server instance.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android.rb#24
  def connect(wsEndpoint, headers: T.unsafe(nil), slowMo: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # source://playwright-ruby-client//lib/playwright_api/android.rb#36
  def default_timeout=(timeout); end

  # Returns the list of detected Android devices.
  #
  # source://playwright-ruby-client//lib/playwright_api/android.rb#30
  def devices(host: T.unsafe(nil), omitDriverInstall: T.unsafe(nil), port: T.unsafe(nil)); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/android.rb#60
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/android.rb#54
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/android.rb#48
  def once(event, callback); end

  # source://playwright-ruby-client//lib/playwright_api/android.rb#42
  def set_default_navigation_timeout(timeout); end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # source://playwright-ruby-client//lib/playwright_api/android.rb#36
  def set_default_timeout(timeout); end

  private

  # source://playwright-ruby-client//lib/playwright_api/android.rb#64
  def event_emitter_proxy; end
end

# `AndroidDevice` represents a connected device, either real hardware or emulated. Devices can be obtained using [`method: Android.devices`].
#
# source://playwright-ruby-client//lib/playwright_api/android_device.rb#4
class Playwright::AndroidDevice < ::Playwright::PlaywrightApi
  # Disconnects from the device.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#12
  def close; end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#150
  def default_timeout=(timeout); end

  # Drags the widget defined by `selector` towards `dest` point.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#18
  def drag(selector, dest, speed: T.unsafe(nil)); end

  # Fills the specific `selector` input box with `text`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#24
  def fill(selector, text); end

  # Flings the widget defined by `selector` in  the specified `direction`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#30
  def fling(selector, direction, speed: T.unsafe(nil)); end

  # Returns information about a widget defined by `selector`.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#36
  def info(selector); end

  # property
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#6
  def input; end

  # Installs an apk on the device.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#42
  def install_apk(file, args: T.unsafe(nil)); end

  # Launches Chrome browser on the device, and returns its persistent context.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#48
  def launch_browser(acceptDownloads: T.unsafe(nil), args: T.unsafe(nil), baseURL: T.unsafe(nil), bypassCSP: T.unsafe(nil), colorScheme: T.unsafe(nil), contrast: T.unsafe(nil), deviceScaleFactor: T.unsafe(nil), extraHTTPHeaders: T.unsafe(nil), forcedColors: T.unsafe(nil), geolocation: T.unsafe(nil), hasTouch: T.unsafe(nil), httpCredentials: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), isMobile: T.unsafe(nil), javaScriptEnabled: T.unsafe(nil), locale: T.unsafe(nil), noViewport: T.unsafe(nil), offline: T.unsafe(nil), permissions: T.unsafe(nil), pkg: T.unsafe(nil), proxy: T.unsafe(nil), record_har_content: T.unsafe(nil), record_har_mode: T.unsafe(nil), record_har_omit_content: T.unsafe(nil), record_har_path: T.unsafe(nil), record_har_url_filter: T.unsafe(nil), record_video_dir: T.unsafe(nil), record_video_size: T.unsafe(nil), reducedMotion: T.unsafe(nil), screen: T.unsafe(nil), serviceWorkers: T.unsafe(nil), strictSelectors: T.unsafe(nil), timezoneId: T.unsafe(nil), userAgent: T.unsafe(nil), viewport: T.unsafe(nil), &block); end

  # Performs a long tap on the widget defined by `selector`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#90
  def long_tap(selector); end

  # Device model.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#96
  def model; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#221
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#215
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#209
  def once(event, callback); end

  # Launches a process in the shell on the device and returns a socket to communicate with the launched process.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#102
  def open(command); end

  # Pinches the widget defined by `selector` in the closing direction.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#108
  def pinch_close(selector, percent, speed: T.unsafe(nil)); end

  # Pinches the widget defined by `selector` in the open direction.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#114
  def pinch_open(selector, percent, speed: T.unsafe(nil)); end

  # Presses the specific `key` in the widget defined by `selector`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#120
  def press(selector, key); end

  # Copies a file to the device.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#126
  def push(file, path, mode: T.unsafe(nil)); end

  # Returns the buffer with the captured screenshot of the device.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#132
  def screenshot(path: T.unsafe(nil)); end

  # Scrolls the widget defined by `selector` in  the specified `direction`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#138
  def scroll(selector, direction, percent, speed: T.unsafe(nil)); end

  # Device serial number.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#144
  def serial; end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#150
  def set_default_timeout(timeout); end

  # Executes a shell command on the device and returns its output.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#157
  def shell(command); end

  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#203
  def should_close_connection_on_close!; end

  # Swipes the widget defined by `selector` in  the specified `direction`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#163
  def swipe(selector, direction, percent, speed: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#198
  def tap_on(selector, duration: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Taps on the widget defined by `selector`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#169
  def tap_point(selector, duration: T.unsafe(nil)); end

  # Waits for the specific `selector` to either appear or disappear, depending on the `state`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#175
  def wait(selector, state: T.unsafe(nil)); end

  # Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy value.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#181
  def wait_for_event(event, optionsOrPredicate: T.unsafe(nil)); end

  # This method waits until `AndroidWebView` matching the `selector` is opened and returns it. If there is already an open `AndroidWebView` matching the `selector`, returns immediately.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#187
  def web_view(selector); end

  # Currently open WebViews.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#193
  def web_views; end

  private

  # source://playwright-ruby-client//lib/playwright_api/android_device.rb#225
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright.rb#54
class Playwright::AndroidExecution
  # @return [AndroidExecution] a new instance of AndroidExecution
  #
  # source://playwright-ruby-client//lib/playwright.rb#55
  def initialize(connection, playwright, device = T.unsafe(nil)); end

  # Returns the value of attribute device.
  #
  # source://playwright-ruby-client//lib/playwright.rb#66
  def device; end

  # Returns the value of attribute playwright.
  #
  # source://playwright-ruby-client//lib/playwright.rb#66
  def playwright; end

  # source://playwright-ruby-client//lib/playwright.rb#61
  def stop; end
end

# source://playwright-ruby-client//lib/playwright_api/android_input.rb#2
class Playwright::AndroidInput < ::Playwright::PlaywrightApi
  # Performs a drag between `from` and `to` points.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_input.rb#6
  def drag(from, to, steps); end

  # Presses the `key`.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_input.rb#12
  def press(key); end

  # Swipes following the path defined by `segments`.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_input.rb#18
  def swipe(from, segments, steps); end

  # Taps at the specified `point`.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_input.rb#24
  def tap_point(point); end

  # Types `text` into currently focused widget.
  #
  # source://playwright-ruby-client//lib/playwright_api/android_input.rb#30
  def type(text); end
end

# source://playwright-ruby-client//lib/playwright/android_input_impl.rb#0
class Playwright::AndroidInputImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/android_input_impl.rb#3
  def initialize(channel); end

  # source://playwright-ruby-client//lib/playwright/android_input_impl.rb#19
  def drag(from, to, steps); end

  # source://playwright-ruby-client//lib/playwright/android_input_impl.rb#11
  def press(key); end

  # source://playwright-ruby-client//lib/playwright/android_input_impl.rb#15
  def tap_point(point); end

  # source://playwright-ruby-client//lib/playwright/android_input_impl.rb#7
  def type(text); end
end

# `AndroidSocket` is a way to communicate with a process launched on the `AndroidDevice`. Use [`method: AndroidDevice.open`] to open a socket.
#
# source://playwright-ruby-client//lib/playwright_api/android_socket.rb#4
class Playwright::AndroidSocket < ::Playwright::PlaywrightApi
  # Closes the socket.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_socket.rb#8
  def close; end

  # Writes some `data` to the socket.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_socket.rb#14
  def write(data); end
end

# `AndroidWebView` represents a WebView open on the `AndroidDevice`. WebView is usually obtained using [`method: AndroidDevice.webView`].
#
# source://playwright-ruby-client//lib/playwright_api/android_web_view.rb#4
class Playwright::AndroidWebView < ::Playwright::PlaywrightApi
  # Connects to the WebView and returns a regular Playwright `Page` to interact with.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_web_view.rb#8
  def page; end

  # WebView process PID.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_web_view.rb#14
  def pid; end

  # WebView package identifier.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/android_web_view.rb#20
  def pkg; end
end

# Each Impl class include this module.
# Used for detecting whether the object is a XXXXImpl or not.
#
# source://playwright-ruby-client//lib/playwright/api_implementation.rb#4
module Playwright::ApiImplementation; end

# source://playwright-ruby-client//lib/playwright/errors.rb#71
class Playwright::AssertionError < ::StandardError; end

# A Browser is created via [`method: BrowserType.launch`]. An example of using a `Browser` to create a `Page`:
#
# ```python sync
# from playwright.sync_api import sync_playwright, Playwright
#
# def run(playwright: Playwright):
#     firefox = playwright.firefox
#     browser = firefox.launch()
#     page = browser.new_page()
#     page.goto("https://example.com")
#     browser.close()
#
# with sync_playwright() as playwright:
#     run(playwright)
# ```
#
# source://playwright-ruby-client//lib/playwright_api/browser.rb#18
class Playwright::Browser < ::Playwright::PlaywrightApi
  # Get the browser type (chromium, firefox or webkit) that the browser belongs to.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#22
  def browser_type; end

  # In case this browser is obtained using [`method: BrowserType.launch`], closes the browser and all of its pages (if any
  # were opened).
  #
  # In case this browser is connected to, clears all created contexts belonging to this browser and disconnects from the
  # browser server.
  #
  # **NOTE**: This is similar to force-quitting the browser. To close pages gracefully and ensure you receive page close events, call [`method: BrowserContext.close`] on any `BrowserContext` instances you explicitly created earlier using [`method: Browser.newContext`] **before** calling [`method: Browser.close`].
  #
  # The `Browser` object itself is considered to be disposed and cannot be used anymore.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#36
  def close(reason: T.unsafe(nil)); end

  # Indicates that the browser is connected.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#57
  def connected?; end

  # Returns an array of all open browser contexts. In a newly created browser, this will return zero browser contexts.
  #
  # **Usage**
  #
  # ```python sync
  # browser = pw.webkit.launch()
  # print(len(browser.contexts)) # prints `0`
  # context = browser.new_context()
  # print(len(browser.contexts)) # prints `1`
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#51
  def contexts; end

  # **NOTE**: CDP Sessions are only supported on Chromium-based browsers.
  #
  # Returns the newly created browser session.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#65
  def new_browser_cdp_session; end

  # Creates a new browser context. It won't share cookies/cache with other browser contexts.
  #
  # **NOTE**: If directly using this method to create `BrowserContext`s, it is best practice to explicitly close the returned context via [`method: BrowserContext.close`] when your code is done with the `BrowserContext`,
  # and before calling [`method: Browser.close`]. This will ensure the `context` is closed gracefully and any artifacts—like HARs and videos—are fully flushed and saved.
  #
  # **Usage**
  #
  # ```python sync
  # browser = playwright.firefox.launch() # or "chromium" or "webkit".
  # # create a new incognito browser context.
  # context = browser.new_context()
  # # create a new page in a pristine context.
  # page = context.new_page()
  # page.goto("https://example.com")
  #
  # # gracefully close up everything
  # context.close()
  # browser.close()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#89
  def new_context(acceptDownloads: T.unsafe(nil), baseURL: T.unsafe(nil), bypassCSP: T.unsafe(nil), clientCertificates: T.unsafe(nil), colorScheme: T.unsafe(nil), contrast: T.unsafe(nil), deviceScaleFactor: T.unsafe(nil), extraHTTPHeaders: T.unsafe(nil), forcedColors: T.unsafe(nil), geolocation: T.unsafe(nil), hasTouch: T.unsafe(nil), httpCredentials: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), isMobile: T.unsafe(nil), javaScriptEnabled: T.unsafe(nil), locale: T.unsafe(nil), noViewport: T.unsafe(nil), offline: T.unsafe(nil), permissions: T.unsafe(nil), proxy: T.unsafe(nil), record_har_content: T.unsafe(nil), record_har_mode: T.unsafe(nil), record_har_omit_content: T.unsafe(nil), record_har_path: T.unsafe(nil), record_har_url_filter: T.unsafe(nil), record_video_dir: T.unsafe(nil), record_video_size: T.unsafe(nil), reducedMotion: T.unsafe(nil), screen: T.unsafe(nil), serviceWorkers: T.unsafe(nil), storageState: T.unsafe(nil), strictSelectors: T.unsafe(nil), timezoneId: T.unsafe(nil), userAgent: T.unsafe(nil), viewport: T.unsafe(nil), &block); end

  # Creates a new page in a new browser context. Closing this page will close the context as well.
  #
  # This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and
  # testing frameworks should explicitly create [`method: Browser.newContext`] followed by the
  # [`method: BrowserContext.newPage`] to control their exact life times.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#135
  def new_page(acceptDownloads: T.unsafe(nil), baseURL: T.unsafe(nil), bypassCSP: T.unsafe(nil), clientCertificates: T.unsafe(nil), colorScheme: T.unsafe(nil), contrast: T.unsafe(nil), deviceScaleFactor: T.unsafe(nil), extraHTTPHeaders: T.unsafe(nil), forcedColors: T.unsafe(nil), geolocation: T.unsafe(nil), hasTouch: T.unsafe(nil), httpCredentials: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), isMobile: T.unsafe(nil), javaScriptEnabled: T.unsafe(nil), locale: T.unsafe(nil), noViewport: T.unsafe(nil), offline: T.unsafe(nil), permissions: T.unsafe(nil), proxy: T.unsafe(nil), record_har_content: T.unsafe(nil), record_har_mode: T.unsafe(nil), record_har_omit_content: T.unsafe(nil), record_har_path: T.unsafe(nil), record_har_url_filter: T.unsafe(nil), record_video_dir: T.unsafe(nil), record_video_size: T.unsafe(nil), reducedMotion: T.unsafe(nil), screen: T.unsafe(nil), serviceWorkers: T.unsafe(nil), storageState: T.unsafe(nil), strictSelectors: T.unsafe(nil), timezoneId: T.unsafe(nil), userAgent: T.unsafe(nil), viewport: T.unsafe(nil), &block); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#220
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#214
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#208
  def once(event, callback); end

  # **NOTE**: This API controls [Chromium Tracing](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool) which is a low-level chromium-specific debugging tool. API to control [Playwright Tracing](../trace-viewer) could be found [here](./class-tracing).
  #
  # You can use [`method: Browser.startTracing`] and [`method: Browser.stopTracing`] to create a trace file that can
  # be opened in Chrome DevTools performance panel.
  #
  # **Usage**
  #
  # ```python sync
  # browser.start_tracing(page, path="trace.json")
  # page.goto("https://www.google.com")
  # browser.stop_tracing()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#188
  def start_tracing(page: T.unsafe(nil), categories: T.unsafe(nil), path: T.unsafe(nil), screenshots: T.unsafe(nil)); end

  # **NOTE**: This API controls [Chromium Tracing](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool) which is a low-level chromium-specific debugging tool. API to control [Playwright Tracing](../trace-viewer) could be found [here](./class-tracing).
  #
  # Returns the buffer with trace data.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#196
  def stop_tracing; end

  # Returns the browser version.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser.rb#202
  def version; end

  private

  # source://playwright-ruby-client//lib/playwright_api/browser.rb#224
  def event_emitter_proxy; end
end

# BrowserContexts provide a way to operate multiple independent browser sessions.
#
# If a page opens another page, e.g. with a `window.open` call, the popup will belong to the parent page's browser
# context.
#
# Playwright allows creating isolated non-persistent browser contexts with [`method: Browser.newContext`] method. Non-persistent browser
# contexts don't write any browsing data to disk.
#
# ```python sync
# # create a new incognito browser context
# context = browser.new_context()
# # create a new page inside context.
# page = context.new_page()
# page.goto("https://example.com")
# # dispose context once it is no longer needed.
# context.close()
# ```
#
# source://playwright-ruby-client//lib/playwright_api/browser_context.rb#20
class Playwright::BrowserContext < ::Playwright::PlaywrightApi
  # Adds cookies into this browser context. All pages within this context will have these cookies installed. Cookies can be
  # obtained via [`method: BrowserContext.cookies`].
  #
  # **Usage**
  #
  # ```python sync
  # browser_context.add_cookies([cookie_object1, cookie_object2])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#47
  def add_cookies(cookies); end

  # Adds a script which would be evaluated in one of the following scenarios:
  # - Whenever a page is created in the browser context or is navigated.
  # - Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.
  #
  # The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
  # the JavaScript environment, e.g. to seed `Math.random`.
  #
  # **Usage**
  #
  # An example of overriding `Math.random` before the page loads:
  #
  # ```python sync
  # # in your playwright script, assuming the preload.js file is in same directory.
  # browser_context.add_init_script(path="preload.js")
  # ```
  #
  # **NOTE**: The order of evaluation of multiple scripts installed via [`method: BrowserContext.addInitScript`] and
  # [`method: Page.addInitScript`] is not defined.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#70
  def add_init_script(path: T.unsafe(nil), script: T.unsafe(nil)); end

  # **NOTE**: Background pages are only supported on Chromium-based browsers.
  #
  # All existing background pages in the context.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#78
  def background_pages; end

  # Gets the browser instance that owns the context. Returns `null` if the context is created outside of normal browser, e.g. Android or Electron.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#84
  def browser; end

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#487
  def browser=(req); end

  # Removes cookies from context. Accepts optional filter.
  #
  # **Usage**
  #
  # ```python sync
  # context.clear_cookies()
  # context.clear_cookies(name="session-id")
  # context.clear_cookies(domain="my-origin.com")
  # context.clear_cookies(path="/api/v1")
  # context.clear_cookies(name="session-id", domain="my-origin.com")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#100
  def clear_cookies(domain: T.unsafe(nil), name: T.unsafe(nil), path: T.unsafe(nil)); end

  # Clears all permission overrides for the browser context.
  #
  # **Usage**
  #
  # ```python sync
  # context = browser.new_context()
  # context.grant_permissions(["clipboard-read"])
  # # do stuff ..
  # context.clear_permissions()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#115
  def clear_permissions; end

  # Playwright has ability to mock clock and passage of time.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#24
  def clock; end

  # Closes the browser context. All the pages that belong to the browser context will be closed.
  #
  # **NOTE**: The default browser context cannot be closed.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#123
  def close(reason: T.unsafe(nil)); end

  # If no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those URLs
  # are returned.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#130
  def cookies(urls: T.unsafe(nil)); end

  # This setting will change the default maximum navigation time for the following methods and related shortcuts:
  # - [`method: Page.goBack`]
  # - [`method: Page.goForward`]
  # - [`method: Page.goto`]
  # - [`method: Page.reload`]
  # - [`method: Page.setContent`]
  # - [`method: Page.waitForNavigation`]
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`] and [`method: Page.setDefaultTimeout`] take priority over
  # [`method: BrowserContext.setDefaultNavigationTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#359
  def default_navigation_timeout=(timeout); end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`], [`method: Page.setDefaultTimeout`] and
  # [`method: BrowserContext.setDefaultNavigationTimeout`] take priority over [`method: BrowserContext.setDefaultTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#369
  def default_timeout=(timeout); end

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#467
  def enable_debug_console!; end

  # Performs action and waits for a `ConsoleMessage` to be logged by in the pages in the context. If predicate is provided, it passes
  # `ConsoleMessage` value into the `predicate` function and waits for `predicate(message)` to return a truthy value.
  # Will throw an error if the page is closed before the [`event: BrowserContext.console`] event is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#429
  def expect_console_message(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
  # value. Will throw an error if the context closes before the event is fired. Returns the event data value.
  #
  # **Usage**
  #
  # ```python sync
  # with context.expect_event("page") as event_info:
  #     page.get_by_role("button").click()
  # page = event_info.value
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#444
  def expect_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Performs action and waits for a new `Page` to be created in the context. If predicate is provided, it passes
  # `Page` value into the `predicate` function and waits for `predicate(event)` to return a truthy value.
  # Will throw an error if the context closes before new `Page` is created.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#452
  def expect_page(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # The method adds a function called `name` on the `window` object of every frame in every page in the context.
  # When called, the function executes `callback` and returns a [Promise] which resolves to the return value of
  # `callback`. If the `callback` returns a [Promise], it will be awaited.
  #
  # The first argument of the `callback` function contains information about the caller: `{ browserContext:
  # BrowserContext, page: Page, frame: Frame }`.
  #
  # See [`method: Page.exposeBinding`] for page-only version.
  #
  # **Usage**
  #
  # An example of exposing page URL to all frames in all pages in the context:
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     webkit = playwright.webkit
  #     browser = webkit.launch(headless=False)
  #     context = browser.new_context()
  #     context.expose_binding("pageURL", lambda source: source["page"].url)
  #     page = context.new_page()
  #     page.set_content("""
  #     <script>
  #       async function onClick() {
  #         document.querySelector('div').textContent = await window.pageURL();
  #       }
  #     </script>
  #     <button onclick="onClick()">Click me</button>
  #     <div></div>
  #     """)
  #     page.get_by_role("button").click()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#171
  def expose_binding(name, callback, handle: T.unsafe(nil)); end

  # The method adds a function called `name` on the `window` object of every frame in every page in the context.
  # When called, the function executes `callback` and returns a [Promise] which resolves to the return value of
  # `callback`.
  #
  # If the `callback` returns a [Promise], it will be awaited.
  #
  # See [`method: Page.exposeFunction`] for page-only version.
  #
  # **Usage**
  #
  # An example of adding a `sha256` function to all pages in the context:
  #
  # ```python sync
  # import hashlib
  # from playwright.sync_api import sync_playwright
  #
  # def sha256(text: str) -> str:
  #     m = hashlib.sha256()
  #     m.update(bytes(text, "utf8"))
  #     return m.hexdigest()
  #
  #
  # def run(playwright: Playwright):
  #     webkit = playwright.webkit
  #     browser = webkit.launch(headless=False)
  #     context = browser.new_context()
  #     context.expose_function("sha256", sha256)
  #     page = context.new_page()
  #     page.set_content("""
  #         <script>
  #           async function onClick() {
  #             document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
  #           }
  #         </script>
  #         <button onclick="onClick()">Click me</button>
  #         <div></div>
  #     """)
  #     page.get_by_role("button").click()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#218
  def expose_function(name, callback); end

  # The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged
  # with page-specific extra HTTP headers set with [`method: Page.setExtraHTTPHeaders`]. If page overrides a particular
  # header, page-specific header value will be used instead of the browser context header value.
  #
  # **NOTE**: [`method: BrowserContext.setExtraHTTPHeaders`] does not guarantee the order of headers in the outgoing requests.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#380
  def extra_http_headers=(headers); end

  # Sets the context's geolocation. Passing `null` or `undefined` emulates position unavailable.
  #
  # **Usage**
  #
  # ```python sync
  # browser_context.set_geolocation({"latitude": 59.95, "longitude": 30.31667})
  # ```
  #
  # **NOTE**: Consider using [`method: BrowserContext.grantPermissions`] to grant permissions for the browser context pages to read
  # its geolocation.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#396
  def geolocation=(geolocation); end

  # Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if
  # specified.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#225
  def grant_permissions(permissions, origin: T.unsafe(nil)); end

  # **NOTE**: CDP sessions are only supported on Chromium-based browsers.
  #
  # Returns the newly created session.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#233
  def new_cdp_session(page); end

  # Creates a new page in the browser context.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#239
  def new_page(&block); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#505
  def off(event, callback); end

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#401
  def offline=(offline); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#499
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#493
  def once(event, callback); end

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#482
  def options=(req); end

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#477
  def owner_page=(req); end

  # Returns all open pages in the context.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#245
  def pages; end

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#472
  def pause; end

  # API testing helper associated with this context. Requests made with this API will use context cookies.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#30
  def request; end

  # Routing provides the capability to modify network requests that are made by any page in the browser context. Once route
  # is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.
  #
  # **NOTE**: [`method: BrowserContext.route`] will not intercept requests intercepted by Service Worker. See [this](https://github.com/microsoft/playwright/issues/1090) issue. We recommend disabling Service Workers when using request interception by setting `serviceWorkers` to `'block'`.
  #
  # **Usage**
  #
  # An example of a naive handler that aborts all image requests:
  #
  # ```python sync
  # context = browser.new_context()
  # page = context.new_page()
  # context.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
  # page.goto("https://example.com")
  # browser.close()
  # ```
  #
  # or the same snippet using a regex pattern instead:
  #
  # ```python sync
  # context = browser.new_context()
  # page = context.new_page()
  # context.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
  # page = await context.new_page()
  # page = context.new_page()
  # page.goto("https://example.com")
  # browser.close()
  # ```
  #
  # It is possible to examine the request to decide the route action. For example, mocking all requests that contain some post data, and leaving all other requests as is:
  #
  # ```python sync
  # def handle_route(route: Route):
  #   if ("my-string" in route.request.post_data):
  #     route.fulfill(body="mocked-data")
  #   else:
  #     route.continue_()
  # context.route("/api/**", handle_route)
  # ```
  #
  # Page routes (set up with [`method: Page.route`]) take precedence over browser context routes when request matches both
  # handlers.
  #
  # To remove a route with its handler you can use [`method: BrowserContext.unroute`].
  #
  # **NOTE**: Enabling routing disables http cache.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#296
  def route(url, handler, times: T.unsafe(nil)); end

  # If specified the network requests that are made in the context will be served from the HAR file. Read more about [Replaying from HAR](../mock.md#replaying-from-har).
  #
  # Playwright will not serve requests intercepted by Service Worker from the HAR file. See [this](https://github.com/microsoft/playwright/issues/1090) issue. We recommend disabling Service Workers when using request interception by setting `serviceWorkers` to `'block'`.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#304
  def route_from_har(har, notFound: T.unsafe(nil), update: T.unsafe(nil), updateContent: T.unsafe(nil), updateMode: T.unsafe(nil), url: T.unsafe(nil)); end

  # This method allows to modify websocket connections that are made by any page in the browser context.
  #
  # Note that only `WebSocket`s created after this method was called will be routed. It is recommended to call this method before creating any pages.
  #
  # **Usage**
  #
  # Below is an example of a simple handler that blocks some websocket messages.
  # See `WebSocketRoute` for more details and examples.
  #
  # ```python sync
  # def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  #   if message == "to-be-blocked":
  #     return
  #   ws.send(message)
  #
  # def handler(ws: WebSocketRoute):
  #   ws.route_send(lambda message: message_handler(ws, message))
  #   ws.connect()
  #
  # context.route_web_socket("/ws", handler)
  # ```
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#336
  def route_web_socket(url, handler); end

  # **NOTE**: Service workers are only supported on Chromium-based browsers.
  #
  # All existing service workers in the context.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#344
  def service_workers; end

  # This setting will change the default maximum navigation time for the following methods and related shortcuts:
  # - [`method: Page.goBack`]
  # - [`method: Page.goForward`]
  # - [`method: Page.goto`]
  # - [`method: Page.reload`]
  # - [`method: Page.setContent`]
  # - [`method: Page.waitForNavigation`]
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`] and [`method: Page.setDefaultTimeout`] take priority over
  # [`method: BrowserContext.setDefaultNavigationTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#359
  def set_default_navigation_timeout(timeout); end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`], [`method: Page.setDefaultTimeout`] and
  # [`method: BrowserContext.setDefaultNavigationTimeout`] take priority over [`method: BrowserContext.setDefaultTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#369
  def set_default_timeout(timeout); end

  # The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged
  # with page-specific extra HTTP headers set with [`method: Page.setExtraHTTPHeaders`]. If page overrides a particular
  # header, page-specific header value will be used instead of the browser context header value.
  #
  # **NOTE**: [`method: BrowserContext.setExtraHTTPHeaders`] does not guarantee the order of headers in the outgoing requests.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#380
  def set_extra_http_headers(headers); end

  # Sets the context's geolocation. Passing `null` or `undefined` emulates position unavailable.
  #
  # **Usage**
  #
  # ```python sync
  # browser_context.set_geolocation({"latitude": 59.95, "longitude": 30.31667})
  # ```
  #
  # **NOTE**: Consider using [`method: BrowserContext.grantPermissions`] to grant permissions for the browser context pages to read
  # its geolocation.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#396
  def set_geolocation(geolocation); end

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#401
  def set_offline(offline); end

  # Returns storage state for this browser context, contains current cookies, local storage snapshot and IndexedDB snapshot.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#408
  def storage_state(indexedDB: T.unsafe(nil), path: T.unsafe(nil)); end

  # property
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#34
  def tracing; end

  # Removes a route created with [`method: BrowserContext.route`]. When `handler` is not specified, removes all
  # routes for the `url`.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#421
  def unroute(url, handler: T.unsafe(nil)); end

  # Removes all routes created with [`method: BrowserContext.route`] and [`method: BrowserContext.routeFromHAR`].
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#414
  def unroute_all(behavior: T.unsafe(nil)); end

  # **NOTE**: In most cases, you should use [`method: BrowserContext.waitForEvent`].
  #
  # Waits for given `event` to fire. If predicate is provided, it passes
  # event's value into the `predicate` function and waits for `predicate(event)` to return a truthy value.
  # Will throw an error if the browser context is closed before the `event` is fired.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#462
  def wait_for_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright_api/browser_context.rb#509
  def event_emitter_proxy; end
end

# BrowserType provides methods to launch a specific browser instance or connect to an existing one. The following is a
# typical example of using Playwright to drive automation:
#
# ```python sync
# from playwright.sync_api import sync_playwright, Playwright
#
# def run(playwright: Playwright):
#     chromium = playwright.chromium
#     browser = chromium.launch()
#     page = browser.new_page()
#     page.goto("https://example.com")
#     # other actions...
#     browser.close()
#
# with sync_playwright() as playwright:
#     run(playwright)
# ```
#
# source://playwright-ruby-client//lib/playwright_api/browser_type.rb#20
class Playwright::BrowserType < ::Playwright::PlaywrightApi
  # This method attaches Playwright to an existing browser instance created via `BrowserType.launchServer` in Node.js.
  #
  # **NOTE**: The major and minor version of the Playwright instance that connects needs to match the version of Playwright that launches the browser (1.2.3 → is compatible with 1.2.x).
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#26
  def connect(wsEndpoint, exposeNetwork: T.unsafe(nil), headers: T.unsafe(nil), slowMo: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method attaches Playwright to an existing browser instance using the Chrome DevTools Protocol.
  #
  # The default browser context is accessible via [`method: Browser.contexts`].
  #
  # **NOTE**: Connecting over the Chrome DevTools Protocol is only supported for Chromium-based browsers.
  #
  # **NOTE**: This connection is significantly lower fidelity than the Playwright protocol connection via [`method: BrowserType.connect`]. If you are experiencing issues or attempting to use advanced functionality, you probably want to use [`method: BrowserType.connect`].
  #
  # **Usage**
  #
  # ```python sync
  # browser = playwright.chromium.connect_over_cdp("http://localhost:9222")
  # default_context = browser.contexts[0]
  # page = default_context.pages[0]
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#51
  def connect_over_cdp(endpointURL, headers: T.unsafe(nil), slowMo: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # A path where Playwright expects to find a bundled browser executable.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#62
  def executable_path; end

  # Returns the browser instance.
  #
  # **Usage**
  #
  # You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:
  #
  # ```python sync
  # browser = playwright.chromium.launch( # or "firefox" or "webkit".
  #     ignore_default_args=["--mute-audio"]
  # )
  # ```
  #
  # > **Chromium-only** Playwright can also be used to control the Google Chrome or Microsoft Edge browsers, but it works best with the version of
  # Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath`
  # option with extreme caution.
  #
  # >
  #
  # > If Google Chrome (rather than Chromium) is preferred, a
  # [Chrome Canary](https://www.google.com/chrome/browser/canary.html) or
  # [Dev Channel](https://www.chromium.org/getting-involved/dev-channel) build is suggested.
  #
  # >
  #
  # > Stock browsers like Google Chrome and Microsoft Edge are suitable for tests that require proprietary media codecs for video playback. See [this article](https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/) for other differences between Chromium and Chrome.
  # [This article](https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md)
  # describes some differences for Linux users.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#94
  def launch(args: T.unsafe(nil), channel: T.unsafe(nil), chromiumSandbox: T.unsafe(nil), devtools: T.unsafe(nil), downloadsPath: T.unsafe(nil), env: T.unsafe(nil), executablePath: T.unsafe(nil), firefoxUserPrefs: T.unsafe(nil), handleSIGHUP: T.unsafe(nil), handleSIGINT: T.unsafe(nil), handleSIGTERM: T.unsafe(nil), headless: T.unsafe(nil), ignoreDefaultArgs: T.unsafe(nil), proxy: T.unsafe(nil), slowMo: T.unsafe(nil), timeout: T.unsafe(nil), tracesDir: T.unsafe(nil), &block); end

  # Returns the persistent browser context instance.
  #
  # Launches browser that uses persistent storage located at `userDataDir` and returns the only context. Closing
  # this context will automatically close the browser.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#121
  def launch_persistent_context(userDataDir, acceptDownloads: T.unsafe(nil), args: T.unsafe(nil), baseURL: T.unsafe(nil), bypassCSP: T.unsafe(nil), channel: T.unsafe(nil), chromiumSandbox: T.unsafe(nil), clientCertificates: T.unsafe(nil), colorScheme: T.unsafe(nil), contrast: T.unsafe(nil), deviceScaleFactor: T.unsafe(nil), devtools: T.unsafe(nil), downloadsPath: T.unsafe(nil), env: T.unsafe(nil), executablePath: T.unsafe(nil), extraHTTPHeaders: T.unsafe(nil), firefoxUserPrefs: T.unsafe(nil), forcedColors: T.unsafe(nil), geolocation: T.unsafe(nil), handleSIGHUP: T.unsafe(nil), handleSIGINT: T.unsafe(nil), handleSIGTERM: T.unsafe(nil), hasTouch: T.unsafe(nil), headless: T.unsafe(nil), httpCredentials: T.unsafe(nil), ignoreDefaultArgs: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), isMobile: T.unsafe(nil), javaScriptEnabled: T.unsafe(nil), locale: T.unsafe(nil), noViewport: T.unsafe(nil), offline: T.unsafe(nil), permissions: T.unsafe(nil), proxy: T.unsafe(nil), record_har_content: T.unsafe(nil), record_har_mode: T.unsafe(nil), record_har_omit_content: T.unsafe(nil), record_har_path: T.unsafe(nil), record_har_url_filter: T.unsafe(nil), record_video_dir: T.unsafe(nil), record_video_size: T.unsafe(nil), reducedMotion: T.unsafe(nil), screen: T.unsafe(nil), serviceWorkers: T.unsafe(nil), slowMo: T.unsafe(nil), strictSelectors: T.unsafe(nil), timeout: T.unsafe(nil), timezoneId: T.unsafe(nil), tracesDir: T.unsafe(nil), userAgent: T.unsafe(nil), viewport: T.unsafe(nil), &block); end

  # Returns browser name. For example: `'chromium'`, `'webkit'` or `'firefox'`.
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#179
  def name; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#197
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#191
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#185
  def once(event, callback); end

  private

  # source://playwright-ruby-client//lib/playwright_api/browser_type.rb#201
  def event_emitter_proxy; end
end

# The `CDPSession` instances are used to talk raw Chrome Devtools Protocol:
# - protocol methods can be called with `session.send` method.
# - protocol events can be subscribed to with `session.on` method.
#
# Useful links:
# - Documentation on DevTools Protocol can be found here: [DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/).
# - Getting Started with DevTools Protocol: https://github.com/aslushnikov/getting-started-with-cdp/blob/master/README.md
#
# ```python sync
# client = page.context.new_cdp_session(page)
# client.send("Animation.enable")
# client.on("Animation.animationCreated", lambda: print("animation created!"))
# response = client.send("Animation.getPlaybackRate")
# print("playback rate is " + str(response["playbackRate"]))
# client.send("Animation.setPlaybackRate", {
#     "playbackRate": response["playbackRate"] / 2
# })
# ```
#
# source://playwright-ruby-client//lib/playwright_api/cdp_session.rb#21
class Playwright::CDPSession < ::Playwright::PlaywrightApi
  # Detaches the CDPSession from the target. Once detached, the CDPSession object won't emit any events and can't be used to
  # send messages.
  #
  # source://playwright-ruby-client//lib/playwright_api/cdp_session.rb#26
  def detach; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/cdp_session.rb#48
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/cdp_session.rb#42
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/cdp_session.rb#36
  def once(event, callback); end

  # source://playwright-ruby-client//lib/playwright_api/cdp_session.rb#30
  def send_message(method, params: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright_api/cdp_session.rb#52
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/version.rb#5
Playwright::COMPATIBLE_PLAYWRIGHT_VERSION = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/channel.rb#2
class Playwright::Channel
  include ::Playwright::EventEmitter

  # @param connection [Playwright::Connection]
  # @param guid [String]
  # @param object [Playwright::ChannelOwner]
  # @return [Channel] a new instance of Channel
  #
  # source://playwright-ruby-client//lib/playwright/channel.rb#8
  def initialize(connection, guid, object:); end

  # @param method [String]
  # @param params [Hash]
  #
  # source://playwright-ruby-client//lib/playwright/channel.rb#42
  def async_send_message_to_server(method, params = T.unsafe(nil)); end

  # Returns the value of attribute guid.
  #
  # source://playwright-ruby-client//lib/playwright/channel.rb#14
  def guid; end

  # Returns the value of attribute object.
  #
  # source://playwright-ruby-client//lib/playwright/channel.rb#14
  def object; end

  # @param method [String]
  # @param params [Hash]
  # @return [Playwright::ChannelOwner|nil]
  #
  # source://playwright-ruby-client//lib/playwright/channel.rb#19
  def send_message_to_server(method, params = T.unsafe(nil)); end

  # @param method [String]
  # @param params [Hash]
  # @return [Hash]
  #
  # source://playwright-ruby-client//lib/playwright/channel.rb#32
  def send_message_to_server_result(title = T.unsafe(nil), method, params); end

  private

  # source://playwright-ruby-client//lib/playwright/channel.rb#73
  def build_metadata_payload_from(api_name, stacks); end

  # source://playwright-ruby-client//lib/playwright/channel.rb#83
  def check_not_collected; end

  # source://playwright-ruby-client//lib/playwright/channel.rb#49
  def with_logging(title = T.unsafe(nil), &block); end
end

# source://playwright-ruby-client//lib/playwright/channel_owner.rb#2
class Playwright::ChannelOwner
  include ::Playwright::EventEmitter

  # @param parent [Playwright::ChannelOwner|Playwright::Connection]
  # @param type [String]
  # @param guid [String]
  # @param initializer [Hash]
  # @return [ChannelOwner] a new instance of ChannelOwner
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#20
  def initialize(parent, type, guid, initializer); end

  # hidden field for caching API instance.
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#14
  def _api; end

  # hidden field for caching API instance.
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#14
  def _api=(_arg0); end

  # Returns the value of attribute channel.
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#44
  def channel; end

  # Suppress long long inspect log and avoid RSpec from hanging up...
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#109
  def inspect; end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#100
  def off(event, callback); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#84
  def on(event, callback); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#92
  def once(event, callback); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#113
  def to_s; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#53
  def was_collected?; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#46
  def adopt!(child); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#117
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#130
  def delete_object_from_child(guid); end

  # used only from Connection. Not intended for public use. So keep private.
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#58
  def dispose!(reason: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#134
  def same_connection?(other); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#68
  def set_event_to_subscription_mapping(event_to_subscription_mapping); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#126
  def update_object_from_child(guid, child); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#120
  def update_parent(new_parent); end

  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#72
  def update_subscription(event, enabled); end

  class << self
    # source://playwright-ruby-client//lib/playwright/channel_owner.rb#5
    def from(channel); end

    # source://playwright-ruby-client//lib/playwright/channel_owner.rb#9
    def from_nullable(channel); end
  end
end

# namespace declaration
#
# source://playwright-ruby-client//lib/playwright/channel_owner.rb#147
module Playwright::ChannelOwners; end

# source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#0
class Playwright::ChannelOwners::APIRequestContext < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#20
  def delete(url, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#15
  def dispose(reason: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#50
  def fetch(urlOrRequest, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), method: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#30
  def get(url, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#25
  def head(url, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#35
  def patch(url, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#45
  def post(url, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#40
  def put(url, **options); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#91
  def _inner_fetch(request, url, data: T.unsafe(nil), failOnStatusCode: T.unsafe(nil), form: T.unsafe(nil), headers: T.unsafe(nil), ignoreHTTPSErrors: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), method: T.unsafe(nil), multipart: T.unsafe(nil), params: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#11
  def _update_timeout_settings(timeout_settings); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#6
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#175
  def file_payload?(value); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#180
  def file_payload_to_json(payload); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#215
  def json_parsable?(data); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#188
  def map_params_to_array(params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#209
  def object_to_array(hash); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/api_request_context.rb#199
  def query_string_to_array(query_string); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/android.rb#0
class Playwright::ChannelOwners::Android < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/android.rb#19
  def devices(host: T.unsafe(nil), omitDriverInstall: T.unsafe(nil), port: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android.rb#7
  def set_default_navigation_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android.rb#11
  def set_default_timeout(timeout); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/android.rb#15
  def _timeout_settings; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android.rb#3
  def after_initialize; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#0
class Playwright::ChannelOwners::AndroidDevice < ::Playwright::ChannelOwner
  include ::Playwright::Utils::PrepareBrowserContextOptions

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#85
  def close; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#70
  def info(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#15
  def input; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#99
  def launch_browser(pkg: T.unsafe(nil), **options, &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#21
  def model; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#74
  def screenshot(path: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#17
  def serial; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#94
  def shell(command); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#11
  def should_close_connection_on_close!; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#61
  def tap_on(selector, duration: T.unsafe(nil), timeout: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#5
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#25
  def to_regex(value); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/android_device.rb#36
  def to_selector_channel(selector); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#0
class Playwright::ChannelOwners::Artifact < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#9
  def absolute_path; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#36
  def cancel; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#32
  def delete; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#28
  def failure; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#11
  def path_after_finished; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#23
  def read_into_buffer; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#18
  def save_as(path); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/artifact.rb#5
  def after_initialize; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/binding_call.rb#0
class Playwright::ChannelOwners::BindingCall < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/binding_call.rb#12
  def call(callback); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/binding_call.rb#7
  def call_async(callback); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/binding_call.rb#3
  def name; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#0
class Playwright::ChannelOwners::Browser < ::Playwright::ChannelOwner
  include ::Playwright::Utils::Errors::TargetClosedErrorMethods
  include ::Playwright::Utils::PrepareBrowserContextOptions

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#27
  def browser_type; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#74
  def close(reason: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#31
  def connected?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#23
  def contexts; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#90
  def new_browser_cdp_session; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#35
  def new_context(**options, &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#59
  def new_page(**options, &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#95
  def start_tracing(page: T.unsafe(nil), categories: T.unsafe(nil), path: T.unsafe(nil), screenshots: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#106
  def stop_tracing; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#86
  def version; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#152
  def add_context(context); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#9
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#19
  def close_reason; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#119
  def connect_to_browser_type(browser_type, traces_dir); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#129
  def did_create_context(context); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#145
  def on_close(_ = T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#161
  def remove_context(context); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#140
  def setup_browser_context(context); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser.rb#156
  def should_close_connection_on_close!; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#0
class Playwright::ChannelOwners::BrowserContext < ::Playwright::ChannelOwner
  include ::Playwright::Utils::PrepareBrowserContextOptions

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#269
  def add_cookies(cookies); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#331
  def add_init_script(path: T.unsafe(nil), script: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#218
  def background_pages; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#6
  def browser; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#6
  def browser=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#273
  def clear_cookies(domain: T.unsafe(nil), name: T.unsafe(nil), path: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#314
  def clear_permissions; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#8
  def clock; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#453
  def close(reason: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#257
  def cookies(urls: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#483
  def enable_debug_console!; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#525
  def expect_console_message(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#430
  def expect_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#533
  def expect_page(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#345
  def expose_binding(name, callback, handle: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#360
  def expose_function(name, callback); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#306
  def grant_permissions(permissions, origin: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#226
  def new_cdp_session(page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#244
  def new_page(&block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#7
  def options=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#7
  def owner_page=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#239
  def pages; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#504
  def pause; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#8
  def request; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#364
  def route(url, handler, times: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#405
  def route_from_har(har, notFound: T.unsafe(nil), update: T.unsafe(nil), updateContent: T.unsafe(nil), updateMode: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#222
  def service_workers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#231
  def set_default_navigation_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#235
  def set_default_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#322
  def set_extra_http_headers(headers); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#318
  def set_geolocation(geolocation); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#327
  def set_offline(offline); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#511
  def storage_state(path: T.unsafe(nil), indexedDB: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#8
  def tracing; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#375
  def unroute(url, handler: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#370
  def unroute_all(behavior: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#555
  def _timeout_settings; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#10
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#420
  def async_update_interception_patterns; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#563
  def base_url; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#602
  def clock_fast_forward(ticks_params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#606
  def clock_install(time_params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#610
  def clock_pause_at(time_params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#614
  def clock_resume; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#618
  def clock_run_for(ticks_params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#622
  def clock_set_fixed_time(time_params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#626
  def clock_set_system_time(time_params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#570
  def create_temp_files(local_directory, files); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#521
  def effective_close_reason; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#559
  def has_record_video_option?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#84
  def initialize_har_from_options(record_har_path:, record_har_content:, record_har_omit_content:, record_har_url_filter:, record_har_mode:); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#464
  def inner_close; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#107
  def on_background_page(page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#148
  def on_binding(binding_call); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#444
  def on_close; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#173
  def on_console_message(message); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#180
  def on_dialog(dialog); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#101
  def on_page(page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#195
  def on_page_error(error, page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#202
  def on_request(request, page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#155
  def on_request_failed(request, response_end_timing, failure_text, page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#162
  def on_request_finished(params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#207
  def on_response(response, page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#112
  def on_route(route); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#212
  def on_service_worker(worker); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#382
  def record_into_har(har, page, url:, update_content:, update_mode:); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#630
  def register_selector_engine(selector_engine); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#546
  def remove_background_page(page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#542
  def remove_page(page); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#550
  def remove_service_worker(worker); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#634
  def set_test_id_attribute_name(test_id_attribute_name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#425
  def update_interception_patterns; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#96
  def update_options(context_options:, browser_options:); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#0
class Playwright::ChannelOwners::BrowserType < ::Playwright::ChannelOwner
  include ::Playwright::Utils::PrepareBrowserContextOptions

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#63
  def connect_over_cdp(endpointURL, headers: T.unsafe(nil), slowMo: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#17
  def executable_path; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#21
  def launch(options, &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#36
  def launch_persistent_context(userDataDir, **options, &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#13
  def name; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#5
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#92
  def did_create_context(context, context_options = T.unsafe(nil), browser_options = T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#96
  def did_launch_browser(browser); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#109
  def playwright_selectors_browser_contexts; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#9
  def update_playwright(playwright); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_type.rb#100
  def update_with_playwright_selectors_options(options); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/cdp_session.rb#0
class Playwright::ChannelOwners::CDPSession < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/cdp_session.rb#15
  def detach; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/cdp_session.rb#11
  def send_message(method, params: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/cdp_session.rb#3
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/cdp_session.rb#7
  def on_event(params); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#0
class Playwright::ChannelOwners::Dialog < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#19
  def accept(promptText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#23
  def accept_async(promptText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#15
  def default_value; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#28
  def dismiss; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#11
  def message; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#3
  def page; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/dialog.rb#7
  def type; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/electron.rb#0
class Playwright::ChannelOwners::Electron < ::Playwright::ChannelOwner; end

# source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#5
class Playwright::ChannelOwners::ElementHandle < ::Playwright::ChannelOwners::JSHandle
  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#11
  def as_element; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#296
  def bounding_box; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#262
  def check(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#41
  def checked?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#104
  def click(button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#20
  def content_frame; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#131
  def dblclick(button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#45
  def disabled?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#65
  def dispatch_event(type, eventInit: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#49
  def editable?; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#53
  def enabled?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#351
  def eval_on_selector(selector, pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#355
  def eval_on_selector_all(selector, pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#195
  def fill(value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#232
  def focus; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#25
  def get_attribute(name); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#57
  def hidden?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#84
  def hover(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#37
  def inner_html; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#33
  def inner_text; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#214
  def input_value(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#15
  def owner_frame; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#250
  def press(key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#340
  def query_selector(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#345
  def query_selector_all(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#300
  def screenshot(animations: T.unsafe(nil), caret: T.unsafe(nil), mask: T.unsafe(nil), maskColor: T.unsafe(nil), omitBackground: T.unsafe(nil), path: T.unsafe(nil), quality: T.unsafe(nil), scale: T.unsafe(nil), style: T.unsafe(nil), timeout: T.unsafe(nil), type: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#75
  def scroll_into_view_if_needed(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#156
  def select_option(element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#207
  def select_text(force: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#288
  def set_checked(checked, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#219
  def set_input_files(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#174
  def tap_point(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#29
  def text_content; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#238
  def type(text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#275
  def uncheck(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#61
  def visible?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#359
  def wait_for_element_state(state, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#366
  def wait_for_selector(selector, state: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/element_handle.rb#6
  def _timeout(timeout); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/fetch_request.rb#5
class Playwright::ChannelOwners::FetchRequest < ::Playwright::ChannelOwners::APIRequestContext; end

# source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#0
class Playwright::ChannelOwners::Frame < ::Playwright::ChannelOwner
  include ::Playwright::LocatorUtils

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#304
  def add_script_tag(content: T.unsafe(nil), path: T.unsafe(nil), type: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#317
  def add_style_tag(content: T.unsafe(nil), path: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#614
  def check(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#221
  def checked?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#296
  def child_frames; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#329
  def click(selector, button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#272
  def content; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#387
  def dblclick(selector, button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#27
  def detached=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#300
  def detached?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#226
  def disabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#251
  def dispatch_event(selector, type, eventInit: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#360
  def drag_and_drop(source, target, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), sourcePosition: T.unsafe(nil), strict: T.unsafe(nil), targetPosition: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#231
  def editable?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#236
  def enabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#264
  def eval_on_selector(selector, pageFunction, arg: T.unsafe(nil), strict: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#268
  def eval_on_selector_all(selector, pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#191
  def evaluate(pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#195
  def evaluate_handle(pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#691
  def expect(selector, expression, options, title); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#103
  def expect_navigation(timeout: T.unsafe(nil), url: T.unsafe(nil), waitUntil: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#440
  def fill(selector, value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#479
  def focus(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#186
  def frame_element; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#475
  def frame_locator(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#500
  def get_attribute(selector, name, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#71
  def goto(url, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil), referer: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#241
  def hidden?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#687
  def highlight(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#510
  def hover(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#495
  def inner_html(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#490
  def inner_text(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#554
  def input_value(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#460
  def locator(selector, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#288
  def name; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#26
  def page; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#26
  def parent_frame; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#593
  def press(selector, key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#199
  def query_selector(selector, strict: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#208
  def query_selector_all(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#534
  def select_option(selector, element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#660
  def set_checked(selector, checked, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#276
  def set_content(html, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#559
  def set_input_files(selector, files, noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#416
  def tap_point(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#485
  def text_content(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#683
  def title; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#572
  def type(selector, text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#637
  def uncheck(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#292
  def url; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#246
  def visible?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#674
  def wait_for_function(pageFunction, arg: T.unsafe(nil), polling: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#157
  def wait_for_load_state(state: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#214
  def wait_for_selector(selector, state: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#668
  def wait_for_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#148
  def wait_for_url(url, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#33
  def _navigation_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#29
  def _timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#8
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#723
  def append_child_frame_from_child(frame); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#61
  def on_frame_navigated(event); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#37
  def on_load_state(add:, remove:); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#94
  def setup_navigation_waiter(wait_name:, timeout_value:); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#717
  def update_page_from_page(page); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#0
class Playwright::ChannelOwners::JSHandle < ::Playwright::ChannelOwner
  include ::Playwright::Utils::Errors::TargetClosedErrorMethods

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#36
  def as_element; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#40
  def dispose; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#18
  def evaluate(pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#22
  def evaluate_handle(pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#26
  def get_properties; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#31
  def get_property(name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#46
  def json_value; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#10
  def to_s; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#5
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/js_handle.rb#14
  def on_preview_updated(params); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#0
class Playwright::ChannelOwners::LocalUtils < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#56
  def add_stack_to_tracing_no_reply(id, stack); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#36
  def async_har_close(har_id); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#3
  def devices; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#22
  def har_lookup(har_id:, url:, method:, headers:, is_navigation_request:, post_data: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#18
  def har_open(file); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#40
  def har_unzip(zip_file, har_file); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#52
  def trace_discarded(stacks_id); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#44
  def tracing_started(traces_dir, trace_name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#10
  def zip(params); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/local_utils.rb#61
  def parse_device_descriptor(descriptor); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#0
class Playwright::ChannelOwners::Page < ::Playwright::ChannelOwner
  include ::Playwright::Utils::Errors::TargetClosedErrorMethods
  include ::Playwright::LocatorUtils

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#81
  def accessibility; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#408
  def add_init_script(path: T.unsafe(nil), script: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#304
  def add_script_tag(content: T.unsafe(nil), path: T.unsafe(nil), type: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#308
  def add_style_tag(content: T.unsafe(nil), path: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#403
  def bring_to_front; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#771
  def check(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#260
  def checked?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#529
  def click(selector, button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#207
  def clock; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#512
  def close(runBeforeUnload: T.unsafe(nil), reason: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#525
  def closed?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#335
  def content; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#203
  def context; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#580
  def dblclick(selector, button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#264
  def disabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#284
  def dispatch_event(selector, type, eventInit: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#557
  def drag_and_drop(source, target, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), sourcePosition: T.unsafe(nil), strict: T.unsafe(nil), targetPosition: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#268
  def editable?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#376
  def emulate_media(colorScheme: T.unsafe(nil), contrast: T.unsafe(nil), forcedColors: T.unsafe(nil), media: T.unsafe(nil), reducedMotion: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#272
  def enabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#296
  def eval_on_selector(selector, pageFunction, arg: T.unsafe(nil), strict: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#300
  def eval_on_selector_all(selector, pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#288
  def evaluate(pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#292
  def evaluate_handle(pageFunction, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#950
  def expect_console_message(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#954
  def expect_download(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#931
  def expect_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#958
  def expect_file_chooser(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#962
  def expect_navigation(timeout: T.unsafe(nil), url: T.unsafe(nil), waitUntil: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#970
  def expect_popup(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#974
  def expect_request(urlOrPredicate, timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#989
  def expect_request_finished(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#993
  def expect_response(urlOrPredicate, timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#1008
  def expect_websocket(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#1012
  def expect_worker(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#317
  def expose_binding(name, callback, handle: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#312
  def expose_function(name, callback); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#626
  def fill(selector, value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#660
  def focus(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#225
  def frame(name: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#656
  def frame_locator(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#236
  def frames; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#676
  def get_attribute(selector, name, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#364
  def go_back(timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#370
  def go_forward(timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#343
  def goto(url, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil), referer: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#1038
  def guid; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#276
  def hidden?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#680
  def hover(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#672
  def inner_html(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#668
  def inner_text(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#724
  def input_value(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#81
  def keyboard; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#642
  def locator(selector, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#81
  def main_frame; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#81
  def mouse; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#211
  def opener; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#9
  def owned_context=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#833
  def pause; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#837
  def pdf(displayHeaderFooter: T.unsafe(nil), footerTemplate: T.unsafe(nil), format: T.unsafe(nil), headerTemplate: T.unsafe(nil), height: T.unsafe(nil), landscape: T.unsafe(nil), margin: T.unsafe(nil), pageRanges: T.unsafe(nil), path: T.unsafe(nil), preferCSSPageSize: T.unsafe(nil), printBackground: T.unsafe(nil), scale: T.unsafe(nil), width: T.unsafe(nil), tagged: T.unsafe(nil), outline: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#754
  def press(selector, key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#248
  def query_selector(selector, strict: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#252
  def query_selector_all(selector); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#347
  def reload(timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#829
  def request; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#422
  def route(url, handler, times: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#440
  def route_from_har(har, notFound: T.unsafe(nil), update: T.unsafe(nil), url: T.unsafe(nil), updateContent: T.unsafe(nil), updateMode: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#465
  def screenshot(animations: T.unsafe(nil), caret: T.unsafe(nil), clip: T.unsafe(nil), fullPage: T.unsafe(nil), mask: T.unsafe(nil), maskColor: T.unsafe(nil), omitBackground: T.unsafe(nil), path: T.unsafe(nil), quality: T.unsafe(nil), scale: T.unsafe(nil), style: T.unsafe(nil), timeout: T.unsafe(nil), type: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#701
  def select_option(selector, element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#809
  def set_checked(selector, checked, **options); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#339
  def set_content(html, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#240
  def set_default_navigation_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#244
  def set_default_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#326
  def set_extra_http_headers(headers); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#728
  def set_input_files(selector, files, noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#397
  def set_viewport_size(viewportSize); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#885
  def snapshot_for_ai; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#902
  def start_css_coverage(resetOnNavigation: T.unsafe(nil), reportAnonymousScripts: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#889
  def start_js_coverage(resetOnNavigation: T.unsafe(nil), reportAnonymousScripts: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#910
  def stop_css_coverage; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#898
  def stop_js_coverage; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#605
  def tap_point(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#664
  def text_content(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#508
  def title; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#81
  def touchscreen; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#737
  def type(selector, text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#790
  def uncheck(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#433
  def unroute(url, handler: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#428
  def unroute_all(behavior: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#331
  def url; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#880
  def video; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#81
  def viewport_size; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#280
  def visible?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#821
  def wait_for_function(pageFunction, arg: T.unsafe(nil), polling: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#356
  def wait_for_load_state(state: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#256
  def wait_for_selector(selector, state: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#817
  def wait_for_timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#360
  def wait_for_url(url, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#825
  def workers; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#1017
  def _timeout_settings; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#11
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#455
  def async_update_interception_patterns; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#926
  def close_error_with_reason; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#219
  def emit_popup_event_from_browser_context; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#1022
  def has_bindings?(name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#389
  def no_override_if_null(target); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#135
  def on_binding(binding_call); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#149
  def on_close; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#159
  def on_crash; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#166
  def on_download(params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#89
  def on_frame_attached(frame); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#95
  def on_frame_detached(frame); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#101
  def on_route(route); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#177
  def on_video(params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#182
  def on_viewport_size_changed(params); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#143
  def on_worker(worker); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#190
  def perform_event_emitter_callback(event, callback, args); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#1032
  def remote_connection?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#1027
  def remove_worker(worker); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#460
  def update_interception_patterns; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#0
class Playwright::ChannelOwners::Playwright < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#21
  def android; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#3
  def chromium; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#33
  def devices; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#25
  def electron; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#9
  def firefox; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#29
  def selectors; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#15
  def webkit; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#45
  def pre_connected_android_device; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/playwright.rb#38
  def pre_launched_browser; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#0
class Playwright::ChannelOwners::Request < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#140
  def all_headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#29
  def apply_fallback_overrides(overrides); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#113
  def failure; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#101
  def frame; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#148
  def header_value(name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#152
  def header_values(name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#119
  def headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#144
  def headers_array; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#50
  def method; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#109
  def navigation_request?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#54
  def post_data; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#72
  def post_data_buffer; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#58
  def post_data_json; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#117
  def redirected_from; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#117
  def redirected_to; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#46
  def resource_type; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#84
  def response; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#156
  def sizes; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#117
  def timing; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#38
  def url; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#128
  def actual_headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#6
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#25
  def fallback_overrides; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#42
  def internal_url; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#136
  def raw_request_headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#169
  def update_failure_text(failure_text); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#165
  def update_redirected_to(request); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#193
  def update_response_end_timing(response_end_timing); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#173
  def update_timings(start_time:, domain_lookup_start:, domain_lookup_end:, connect_start:, secure_connection_start:, connect_end:, request_start:, response_start:); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#0
class Playwright::ChannelOwners::Response < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#61
  def all_headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#89
  def body; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#85
  def finished; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#99
  def frame; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#55
  def from_service_worker; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#55
  def from_service_worker?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#69
  def header_value(name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#73
  def header_values(name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#42
  def headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#65
  def headers_array; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#95
  def json; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#29
  def ok; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#29
  def ok?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#23
  def request; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#81
  def security_details; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#77
  def server_addr; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#34
  def status; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#38
  def status_text; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#89
  def text; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#25
  def url; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#47
  def actual_headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#7
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#114
  def mark_as_finished; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#51
  def raw_response_headers; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/response.rb#103
  def sizes; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#0
class Playwright::ChannelOwners::Route < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#22
  def abort(errorCode: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#127
  def continue(headers: T.unsafe(nil), method: T.unsafe(nil), postData: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#100
  def fallback(headers: T.unsafe(nil), method: T.unsafe(nil), postData: T.unsafe(nil), url: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#113
  def fetch(headers: T.unsafe(nil), method: T.unsafe(nil), postData: T.unsafe(nil), url: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#30
  def fulfill(body: T.unsafe(nil), contentType: T.unsafe(nil), headers: T.unsafe(nil), json: T.unsafe(nil), path: T.unsafe(nil), status: T.unsafe(nil), response: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#165
  def redirect_navigation_request(url); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#18
  def request; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#141
  def async_continue_route(internal: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#10
  def handling_with_result(done, &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#172
  def mime_type_for(filepath); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#6
  def set_handling_future(future); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/route.rb#177
  def update_context(context); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/stream.rb#0
class Playwright::ChannelOwners::Stream < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/stream.rb#13
  def read_all(&block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/stream.rb#5
  def save_as(path); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/stream.rb#21
  def read_with_block(&block); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#0
class Playwright::ChannelOwners::Tracing < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#96
  def group(name, location: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#104
  def group_end; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#3
  def start(name: T.unsafe(nil), title: T.unsafe(nil), screenshots: T.unsafe(nil), snapshots: T.unsafe(nil), sources: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#16
  def start_chunk(title: T.unsafe(nil), name: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#33
  def stop(path: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#29
  def stop_chunk(path: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#38
  def do_stop_chunk(file_path:); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#21
  def start_collecting_stacks(trace_name); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/tracing.rb#92
  def update_traces_dir(traces_dir); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#0
class Playwright::ChannelOwners::WebSocket < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#73
  def closed?; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#36
  def expect_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#20
  def url; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#36
  def wait_for_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#5
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#77
  def on_close; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#65
  def on_frame_received(opcode, data); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#57
  def on_frame_sent(opcode, data); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#0
class Playwright::ChannelOwners::Worker < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#3
  def context=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#19
  def evaluate(expression, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#23
  def evaluate_handle(expression, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#3
  def page=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#15
  def url; end

  private

  # source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#5
  def after_initialize; end

  # source://playwright-ruby-client//lib/playwright/channel_owners/worker.rb#9
  def on_close; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/writable_stream.rb#0
class Playwright::ChannelOwners::WritableStream < ::Playwright::ChannelOwner
  # source://playwright-ruby-client//lib/playwright/channel_owners/writable_stream.rb#6
  def write(readable, bufsize = T.unsafe(nil)); end
end

# Accurately simulating time-dependent behavior is essential for verifying the correctness of applications. Learn more about [clock emulation](../clock.md).
#
# Note that clock is installed for the entire `BrowserContext`, so the time
# in all the pages and iframes is controlled by the same clock.
#
# source://playwright-ruby-client//lib/playwright_api/clock.rb#7
class Playwright::Clock < ::Playwright::PlaywrightApi
  # Advance the clock by jumping forward in time. Only fires due timers at most once. This is equivalent to user closing the laptop lid for a while and
  # reopening it later, after given time.
  #
  # **Usage**
  #
  # ```python sync
  # page.clock.fast_forward(1000)
  # page.clock.fast_forward("30:00")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#19
  def fast_forward(ticks); end

  # Makes `Date.now` and `new Date()` return fixed fake time at all times,
  # keeps all the timers running.
  #
  # Use this method for simple scenarios where you only need to test with a predefined time. For more advanced scenarios, use [`method: Clock.install`] instead. Read docs on [clock emulation](../clock.md) to learn more.
  #
  # **Usage**
  #
  # ```python sync
  # page.clock.set_fixed_time(datetime.datetime.now())
  # page.clock.set_fixed_time(datetime.datetime(2020, 2, 2))
  # page.clock.set_fixed_time("2020-02-02")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#101
  def fixed_time=(time); end

  # Install fake implementations for the following time-related functions:
  # - `Date`
  # - `setTimeout`
  # - `clearTimeout`
  # - `setInterval`
  # - `clearInterval`
  # - `requestAnimationFrame`
  # - `cancelAnimationFrame`
  # - `requestIdleCallback`
  # - `cancelIdleCallback`
  # - `performance`
  #
  # Fake timers are used to manually control the flow of time in tests. They allow you to advance time, fire timers, and control the behavior of time-dependent functions. See [`method: Clock.runFor`] and [`method: Clock.fastForward`] for more information.
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#37
  def install(time: T.unsafe(nil)); end

  # Advance the clock by jumping forward in time and pause the time. Once this method is called, no timers
  # are fired unless [`method: Clock.runFor`], [`method: Clock.fastForward`], [`method: Clock.pauseAt`] or [`method: Clock.resume`] is called.
  #
  # Only fires due timers at most once.
  # This is equivalent to user closing the laptop lid for a while and reopening it at the specified time and
  # pausing.
  #
  # **Usage**
  #
  # ```python sync
  # page.clock.pause_at(datetime.datetime(2020, 2, 2))
  # page.clock.pause_at("2020-02-02")
  # ```
  #
  # For best results, install the clock before navigating the page and set it to a time slightly before the intended test time. This ensures that all timers run normally during page loading, preventing the page from getting stuck. Once the page has fully loaded, you can safely use [`method: Clock.pauseAt`] to pause the clock.
  #
  # ```python sync
  # # Initialize clock with some time before the test time and let the page load
  # # naturally. `Date.now` will progress as the timers fire.
  # page.clock.install(time=datetime.datetime(2024, 12, 10, 8, 0, 0))
  # page.goto("http://localhost:3333")
  # page.clock.pause_at(datetime.datetime(2024, 12, 10, 10, 0, 0))
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#78
  def pause_at(time); end

  # Resumes timers. Once this method is called, time resumes flowing, timers are fired as usual.
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#84
  def resume; end

  # Advance the clock, firing all the time-related callbacks.
  #
  # **Usage**
  #
  # ```python sync
  # page.clock.run_for(1000);
  # page.clock.run_for("30:00")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#50
  def run_for(ticks); end

  # Makes `Date.now` and `new Date()` return fixed fake time at all times,
  # keeps all the timers running.
  #
  # Use this method for simple scenarios where you only need to test with a predefined time. For more advanced scenarios, use [`method: Clock.install`] instead. Read docs on [clock emulation](../clock.md) to learn more.
  #
  # **Usage**
  #
  # ```python sync
  # page.clock.set_fixed_time(datetime.datetime.now())
  # page.clock.set_fixed_time(datetime.datetime(2020, 2, 2))
  # page.clock.set_fixed_time("2020-02-02")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#101
  def set_fixed_time(time); end

  # Sets system time, but does not trigger any timers. Use this to test how the web page reacts to a time shift, for example switching from summer to winter time, or changing time zones.
  #
  # **Usage**
  #
  # ```python sync
  # page.clock.set_system_time(datetime.datetime.now())
  # page.clock.set_system_time(datetime.datetime(2020, 2, 2))
  # page.clock.set_system_time("2020-02-02")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#116
  def set_system_time(time); end

  # Sets system time, but does not trigger any timers. Use this to test how the web page reacts to a time shift, for example switching from summer to winter time, or changing time zones.
  #
  # **Usage**
  #
  # ```python sync
  # page.clock.set_system_time(datetime.datetime.now())
  # page.clock.set_system_time(datetime.datetime(2020, 2, 2))
  # page.clock.set_system_time("2020-02-02")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/clock.rb#116
  def system_time=(time); end
end

# source://playwright-ruby-client//lib/playwright/clock_impl.rb#0
class Playwright::ClockImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#3
  def initialize(browser_context); end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#15
  def fast_forward(ticks); end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#7
  def install(time: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#19
  def pause_at(time); end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#23
  def resume; end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#27
  def run_for(ticks); end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#31
  def set_fixed_time(time); end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#35
  def set_system_time(time); end

  private

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#56
  def parse_ticks(ticks); end

  # source://playwright-ruby-client//lib/playwright/clock_impl.rb#39
  def parse_time(time); end
end

# https://github.com/microsoft/playwright/blob/master/src/client/connection.ts
# https://github.com/microsoft/playwright-python/blob/master/playwright/_impl/_connection.py
# https://github.com/microsoft/playwright-java/blob/master/playwright/src/main/java/com/microsoft/playwright/impl/Connection.java
#
# source://playwright-ruby-client//lib/playwright/connection.rb#7
class Playwright::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://playwright-ruby-client//lib/playwright/connection.rb#8
  def initialize(transport); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#42
  def async_run; end

  # source://playwright-ruby-client//lib/playwright/connection.rb#75
  def async_send_message_to_server(guid, method, params, metadata: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#51
  def cleanup(cause: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#59
  def initialize_playwright; end

  # Returns the value of attribute local_utils.
  #
  # source://playwright-ruby-client//lib/playwright/connection.rb#32
  def local_utils; end

  # source://playwright-ruby-client//lib/playwright/connection.rb#34
  def mark_as_remote; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/connection.rb#38
  def remote?; end

  # source://playwright-ruby-client//lib/playwright/connection.rb#123
  def send_message_to_server(guid, method, params, metadata: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#67
  def set_in_tracing(value); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#46
  def stop; end

  private

  # @return [Playwright::ChannelOwner|nil]
  #
  # source://playwright-ruby-client//lib/playwright/connection.rb#257
  def create_remote_object(parent_guid:, type:, guid:, initializer:); end

  # @note This method should be used internally. Accessed via .send method from Playwright::ChannelOwner, so keep private!
  # @param guid [String]
  #
  # source://playwright-ruby-client//lib/playwright/connection.rb#148
  def delete_object_from_channel_owner(guid); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#152
  def dispatch(msg); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#215
  def replace_channels_with_guids(payload); end

  # source://playwright-ruby-client//lib/playwright/connection.rb#235
  def replace_guids_with_channels(payload); end

  # @note This method should be used internally. Accessed via .send method from Playwright::ChannelOwner, so keep private!
  # @param guid [String]
  # @param parent [Playwright::ChannelOwner]
  #
  # source://playwright-ruby-client//lib/playwright/connection.rb#142
  def update_object_from_channel_owner(guid, parent); end

  # ```usage
  # connection.with_generated_id do |id|
  #   # play with id
  # end
  # ````
  #
  # source://playwright-ruby-client//lib/playwright/connection.rb#134
  def with_generated_id(&block); end
end

# `ConsoleMessage` objects are dispatched by page via the [`event: Page.console`] event.
# For each console message logged in the page there will be corresponding event in the Playwright
# context.
#
# ```python sync
# # Listen for all console logs
# page.on("console", lambda msg: print(msg.text))
#
# # Listen for all console events and handle errors
# page.on("console", lambda msg: print(f"error: {msg.text}") if msg.type == "error" else None)
#
# # Get the next console log
# with page.expect_console_message() as msg_info:
#     # Issue console.log inside the page
#     page.evaluate("console.log('hello', 42, { foo: 'bar' })")
# msg = msg_info.value
#
# # Deconstruct print arguments
# msg.args[0].json_value() # hello
# msg.args[1].json_value() # 42
# ```
#
# source://playwright-ruby-client//lib/playwright_api/console_message.rb#24
class Playwright::ConsoleMessage < ::Playwright::PlaywrightApi
  # List of arguments passed to a `console` function call. See also [`event: Page.console`].
  #
  # source://playwright-ruby-client//lib/playwright_api/console_message.rb#28
  def args; end

  # source://playwright-ruby-client//lib/playwright_api/console_message.rb#32
  def location; end

  # The page that produced this console message, if any.
  #
  # source://playwright-ruby-client//lib/playwright_api/console_message.rb#38
  def page; end

  # The text of the console message.
  #
  # source://playwright-ruby-client//lib/playwright_api/console_message.rb#44
  def text; end

  # source://playwright-ruby-client//lib/playwright_api/console_message.rb#48
  def type; end
end

# source://playwright-ruby-client//lib/playwright/console_message_impl.rb#0
class Playwright::ConsoleMessageImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/console_message_impl.rb#3
  def initialize(event); end

  # source://playwright-ruby-client//lib/playwright/console_message_impl.rb#19
  def args; end

  # source://playwright-ruby-client//lib/playwright/console_message_impl.rb#25
  def location; end

  # source://playwright-ruby-client//lib/playwright/console_message_impl.rb#7
  def page; end

  # source://playwright-ruby-client//lib/playwright/console_message_impl.rb#15
  def text; end

  # source://playwright-ruby-client//lib/playwright/console_message_impl.rb#11
  def type; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#82
class Playwright::CrashedError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#915
  def initialize; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#498
class Playwright::DebugConsoleNotEnabledError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/channel_owners/browser_context.rb#499
  def initialize; end
end

# `Dialog` objects are dispatched by page via the [`event: Page.dialog`] event.
#
# An example of using `Dialog` class:
#
# ```python sync
# from playwright.sync_api import sync_playwright, Playwright
#
# def handle_dialog(dialog):
#     print(dialog.message)
#     dialog.dismiss()
#
# def run(playwright: Playwright):
#     chromium = playwright.chromium
#     browser = chromium.launch()
#     page = browser.new_page()
#     page.on("dialog", handle_dialog)
#     page.evaluate("alert('1')")
#     browser.close()
#
# with sync_playwright() as playwright:
#     run(playwright)
# ```
#
# **NOTE**: Dialogs are dismissed automatically, unless there is a [`event: Page.dialog`] listener.
# When listener is present, it **must** either [`method: Dialog.accept`] or [`method: Dialog.dismiss`] the dialog - otherwise the page will [freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking) waiting for the dialog, and actions like click will never finish.
#
# source://playwright-ruby-client//lib/playwright_api/dialog.rb#28
class Playwright::Dialog < ::Playwright::PlaywrightApi
  # Returns when the dialog has been accepted.
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#32
  def accept(promptText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#67
  def accept_async(promptText: T.unsafe(nil)); end

  # If dialog is prompt, returns default prompt value. Otherwise, returns empty string.
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#38
  def default_value; end

  # Returns when the dialog has been dismissed.
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#44
  def dismiss; end

  # A message displayed in the dialog.
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#50
  def message; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#85
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#79
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#73
  def once(event, callback); end

  # The page that initiated this dialog, if available.
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#56
  def page; end

  # Returns dialog's type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.
  #
  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#62
  def type; end

  private

  # source://playwright-ruby-client//lib/playwright_api/dialog.rb#89
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/locator_impl.rb#56
class Playwright::DifferentFrameError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#57
  def initialize(method_name); end
end

# `Download` objects are dispatched by page via the [`event: Page.download`] event.
#
# All the downloaded files belonging to the browser context are deleted when the
# browser context is closed.
#
# Download event is emitted once the download starts. Download path becomes available once download completes.
#
# ```python sync
# # Start waiting for the download
# with page.expect_download() as download_info:
#     # Perform the action that initiates download
#     page.get_by_text("Download file").click()
# download = download_info.value
#
# # Wait for the download process to complete and save the downloaded file somewhere
# download.save_as("/path/to/save/at/" + download.suggested_filename)
# ```
#
# source://playwright-ruby-client//lib/playwright_api/download.rb#20
class Playwright::Download < ::Playwright::PlaywrightApi
  # Cancels a download. Will not fail if the download is already finished or canceled.
  # Upon successful cancellations, `download.failure()` would resolve to `'canceled'`.
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#25
  def cancel; end

  # Deletes the downloaded file. Will wait for the download to finish if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#31
  def delete; end

  # Returns download error if any. Will wait for the download to finish if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#37
  def failure; end

  # Get the page that the download belongs to.
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#43
  def page; end

  # Returns path to the downloaded file for a successful download, or throws for a failed/canceled download. The method will wait for the download to finish if necessary. The method throws when connected remotely.
  #
  # Note that the download's file name is a random GUID, use [`method: Download.suggestedFilename`]
  # to get suggested file name.
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#52
  def path; end

  # Copy the download to a user-specified path. It is safe to call this method while the download
  # is still in progress. Will wait for the download to finish if necessary.
  #
  # **Usage**
  #
  # ```python sync
  # download.save_as("/path/to/save/at/" + download.suggested_filename)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#65
  def save_as(path); end

  # Returns suggested filename for this download. It is typically computed by the browser from the
  # [`Content-Disposition`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) response header
  # or the `download` attribute. See the spec on [whatwg](https://html.spec.whatwg.org/#downloading-resources). Different
  # browsers can use different logic for computing it.
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#74
  def suggested_filename; end

  # Returns downloaded url.
  #
  # source://playwright-ruby-client//lib/playwright_api/download.rb#80
  def url; end
end

# source://playwright-ruby-client//lib/playwright/download_impl.rb#0
class Playwright::DownloadImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#3
  def initialize(page:, url:, suggested_filename:, artifact:); end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#28
  def cancel; end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#12
  def delete; end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#16
  def failure; end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#10
  def page; end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#20
  def path; end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#24
  def save_as(path); end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#10
  def suggested_filename; end

  # source://playwright-ruby-client//lib/playwright/download_impl.rb#10
  def url; end
end

# source://playwright-ruby-client//lib/playwright/errors.rb#43
class Playwright::DriverCrashedError < ::StandardError
  # @return [DriverCrashedError] a new instance of DriverCrashedError
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#44
  def initialize; end
end

# - extends: `JSHandle`
#
# ElementHandle represents an in-page DOM element. ElementHandles can be created with the [`method: Page.querySelector`] method.
#
# **NOTE**: The use of ElementHandle is discouraged, use `Locator` objects and web-first assertions instead.
#
# ```python sync
# href_element = page.query_selector("a")
# href_element.click()
# ```
#
# ElementHandle prevents DOM element from garbage collection unless the handle is disposed with
# [`method: JSHandle.dispose`]. ElementHandles are auto-disposed when their origin frame gets navigated.
#
# ElementHandle instances can be used as an argument in [`method: Page.evalOnSelector`] and [`method: Page.evaluate`] methods.
#
# The difference between the `Locator` and ElementHandle is that the ElementHandle points to a particular element, while `Locator` captures the logic of how to retrieve an element.
#
# In the example below, handle points to a particular DOM element on page. If that element changes text or is used by React to render an entirely different component, handle is still pointing to that very DOM element. This can lead to unexpected behaviors.
#
# ```python sync
# handle = page.query_selector("text=Submit")
# handle.hover()
# handle.click()
# ```
#
# With the locator, every time the `element` is used, up-to-date DOM element is located in the page using the selector. So in the snippet below, underlying DOM element is going to be located twice.
#
# ```python sync
# locator = page.get_by_text("Submit")
# locator.hover()
# locator.click()
# ```
#
# source://playwright-ruby-client//lib/playwright_api/element_handle.rb#37
class Playwright::ElementHandle < ::Playwright::JSHandle
  # Returns element attribute value.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#241
  def [](name); end

  # This method returns the bounding box of the element, or `null` if the element is not visible. The bounding box is
  # calculated relative to the main frame viewport - which is usually the same as the browser window.
  #
  # Scrolling affects the returned bounding box, similarly to
  # [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect). That
  # means `x` and/or `y` may be negative.
  #
  # Elements from child frames return the bounding box relative to the main frame, unlike the
  # [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  #
  # Assuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the following
  # snippet should click the center of the element.
  #
  # **Usage**
  #
  # ```python sync
  # box = element_handle.bounding_box()
  # page.mouse.click(box["x"] + box["width"] / 2, box["y"] + box["height"] / 2)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#59
  def bounding_box; end

  # This method checks the element by performing the following steps:
  # 1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already checked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked. If not, this method throws.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#75
  def check(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # This method checks or unchecks an element by performing the following steps:
  # 1. Ensure that element is a checkbox or a radio input. If not, this method throws.
  # 1. If the element already has the right checked state, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked or unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#451
  def checked=(checked, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is checked. Throws if the element is not a checkbox or radio input.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#288
  def checked?; end

  # This method clicks the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element, or the specified `position`.
  # 1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#95
  def click(button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns the content frame for element handles referencing iframe nodes, or `null` otherwise
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#110
  def content_frame; end

  # This method double clicks the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to double click in the center of the element, or the specified `position`.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#126
  def dblclick(button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is disabled, the opposite of [enabled](../actionability.md#enabled).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#294
  def disabled?; end

  # The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the element, `click`
  # is dispatched. This is equivalent to calling
  # [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).
  #
  # **Usage**
  #
  # ```python sync
  # element_handle.dispatch_event("click")
  # ```
  #
  # Under the hood, it creates an instance of an event based on the given `type`, initializes it with
  # `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by
  # default.
  #
  # Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial
  # properties:
  # - [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
  # - [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
  # - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
  # - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
  # - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
  # - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
  # - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
  # - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
  # - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
  # - [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)
  #
  # You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:
  #
  # ```python sync
  # # note you can only create data_transfer in chromium and firefox
  # data_transfer = page.evaluate_handle("new DataTransfer()")
  # element_handle.dispatch_event("#source", "dragstart", {"dataTransfer": data_transfer})
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#173
  def dispatch_event(type, eventInit: T.unsafe(nil)); end

  # Returns whether the element is [editable](../actionability.md#editable).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#300
  def editable?; end

  # Returns whether the element is [enabled](../actionability.md#enabled).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#306
  def enabled?; end

  # Returns the return value of `expression`.
  #
  # The method finds an element matching the specified selector in the `ElementHandle`s subtree and passes it as a first
  # argument to `expression`. If no elements match the selector, the method throws an error.
  #
  # If `expression` returns a [Promise], then [`method: ElementHandle.evalOnSelector`] would wait for the promise to resolve and return its
  # value.
  #
  # **Usage**
  #
  # ```python sync
  # tweet_handle = page.query_selector(".tweet")
  # assert tweet_handle.eval_on_selector(".like", "node => node.innerText") == "100"
  # assert tweet_handle.eval_on_selector(".retweets", "node => node.innerText") == "10"
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#193
  def eval_on_selector(selector, expression, arg: T.unsafe(nil)); end

  # Returns the return value of `expression`.
  #
  # The method finds all elements matching the specified selector in the `ElementHandle`'s subtree and passes an array of
  # matched elements as a first argument to `expression`.
  #
  # If `expression` returns a [Promise], then [`method: ElementHandle.evalOnSelectorAll`] would wait for the promise to resolve and return its
  # value.
  #
  # **Usage**
  #
  # ```html
  # <div class="feed">
  #   <div class="tweet">Hello!</div>
  #   <div class="tweet">Hi!</div>
  # </div>
  # ```
  #
  # ```python sync
  # feed_handle = page.query_selector(".feed")
  # assert feed_handle.eval_on_selector_all(".tweet", "nodes => nodes.map(n => n.innerText)") == ["hello!", "hi!"]
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#219
  def eval_on_selector_all(selector, expression, arg: T.unsafe(nil)); end

  # This method waits for [actionability](../actionability.md) checks, focuses the element, fills it and triggers an `input` event after filling. Note that you can pass an empty string to clear the input field.
  #
  # If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be filled instead.
  #
  # To send fine-grained keyboard events, use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#229
  def fill(value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Calls [focus](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on the element.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#235
  def focus; end

  # Returns element attribute value.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#241
  def get_attribute(name); end

  # Returns whether the element is hidden, the opposite of [visible](../actionability.md#visible).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#312
  def hidden?; end

  # This method hovers over the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to hover over the center of the element, or the specified `position`.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#256
  def hover(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns the `element.innerHTML`.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#268
  def inner_html; end

  # Returns the `element.innerText`.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#274
  def inner_text; end

  # Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
  # are resolved relative to the current working directory. For empty array, clears the selected files.
  # For inputs with a `[webkitdirectory]` attribute, only a single directory path is supported.
  #
  # This method expects `ElementHandle` to point to an
  # [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), targets the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#469
  def input_files=(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns `input.value` for the selected `<input>` or `<textarea>` or `<select>` element.
  #
  # Throws for non-input elements. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), returns the value of the control.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#282
  def input_value(timeout: T.unsafe(nil)); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#589
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#583
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#577
  def once(event, callback); end

  # Returns the frame containing the given element.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#324
  def owner_frame; end

  # Focuses the element, and then uses [`method: Keyboard.down`] and [`method: Keyboard.up`].
  #
  # `key` can specify the intended
  # [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) value or a single character to
  # generate the text for. A superset of the `key` values can be found
  # [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:
  #
  # `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
  # `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
  #
  # Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.
  #
  # Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
  #
  # If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different
  # respective texts.
  #
  # Shortcuts such as `key: "Control+o"`, `key: "Control++` or `key: "Control+Shift+T"` are supported as well. When specified with the
  # modifier, modifier is pressed and being held while the subsequent key is being pressed.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#348
  def press(key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The method finds an element matching the specified selector in the `ElementHandle`'s subtree. If no elements match the selector,
  # returns `null`.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#355
  def query_selector(selector); end

  # The method finds all elements matching the specified selector in the `ElementHandle`s subtree. If no elements match the selector,
  # returns empty array.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#362
  def query_selector_all(selector); end

  # This method captures a screenshot of the page, clipped to the size and position of this particular element. If the element is covered by other elements, it will not be actually visible on the screenshot. If the element is a scrollable container, only the currently scrolled content will be visible on the screenshot.
  #
  # This method waits for the [actionability](../actionability.md) checks, then scrolls element into view before taking a
  # screenshot. If the element is detached from DOM, the method throws an error.
  #
  # Returns the buffer with the captured screenshot.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#373
  def screenshot(animations: T.unsafe(nil), caret: T.unsafe(nil), mask: T.unsafe(nil), maskColor: T.unsafe(nil), omitBackground: T.unsafe(nil), path: T.unsafe(nil), quality: T.unsafe(nil), scale: T.unsafe(nil), style: T.unsafe(nil), timeout: T.unsafe(nil), type: T.unsafe(nil)); end

  # This method waits for [actionability](../actionability.md) checks, then tries to scroll element into view, unless it is
  # completely visible as defined by
  # [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)'s `ratio`.
  #
  # Throws when `elementHandle` does not point to an element
  # [connected](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) to a Document or a ShadowRoot.
  #
  # See [scrolling](../input.md#scrolling) for alternative ways to scroll.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#397
  def scroll_into_view_if_needed(timeout: T.unsafe(nil)); end

  # This method waits for [actionability](../actionability.md) checks, waits until all specified options are present in the `<select>` element and selects these options.
  #
  # If the target element is not a `<select>` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be used instead.
  #
  # Returns the array of option values that have been successfully selected.
  #
  # Triggers a `change` and `input` event once all the provided options have been selected.
  #
  # **Usage**
  #
  # ```python sync
  # # Single selection matching the value or label
  # handle.select_option("blue")
  # # single selection matching both the label
  # handle.select_option(label="blue")
  # # multiple selection
  # handle.select_option(value=["red", "green", "blue"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#420
  def select_option(element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method waits for [actionability](../actionability.md) checks, then focuses the element and selects all its text
  # content.
  #
  # If the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), focuses and selects text in the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#436
  def select_text(force: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method checks or unchecks an element by performing the following steps:
  # 1. Ensure that element is a checkbox or a radio input. If not, this method throws.
  # 1. If the element already has the right checked state, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked or unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#451
  def set_checked(checked, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
  # are resolved relative to the current working directory. For empty array, clears the selected files.
  # For inputs with a `[webkitdirectory]` attribute, only a single directory path is supported.
  #
  # This method expects `ElementHandle` to point to an
  # [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), targets the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#469
  def set_input_files(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method taps the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.touchscreen`] to tap the center of the element, or the specified `position`.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: `elementHandle.tap()` requires that the `hasTouch` option of the browser context be set to true.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#486
  def tap_point(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns the `node.textContent`.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#498
  def text_content; end

  # Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
  #
  # To press a special key, like `Control` or `ArrowDown`, use [`method: ElementHandle.press`].
  #
  # **Usage**
  #
  # @deprecated In most cases, you should use [`method: Locator.fill`] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#510
  def type(text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method checks the element by performing the following steps:
  # 1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already unchecked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now unchecked. If not, this method throws.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#526
  def uncheck(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is [visible](../actionability.md#visible).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#318
  def visible?; end

  # Returns when the element satisfies the `state`.
  #
  # Depending on the `state` parameter, this method waits for one of the [actionability](../actionability.md) checks
  # to pass. This method throws when the element is detached while waiting, unless waiting for the `"hidden"` state.
  # - `"visible"` Wait until the element is [visible](../actionability.md#visible).
  # - `"hidden"` Wait until the element is [not visible](../actionability.md#visible) or not attached. Note that waiting for hidden does not throw when the element detaches.
  # - `"stable"` Wait until the element is both [visible](../actionability.md#visible) and [stable](../actionability.md#stable).
  # - `"enabled"` Wait until the element is [enabled](../actionability.md#enabled).
  # - `"disabled"` Wait until the element is [not enabled](../actionability.md#enabled).
  # - `"editable"` Wait until the element is [editable](../actionability.md#editable).
  #
  # If the element does not satisfy the condition for the `timeout` milliseconds, this method will throw.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#548
  def wait_for_element_state(state, timeout: T.unsafe(nil)); end

  # Returns element specified by selector when it satisfies `state` option. Returns `null` if waiting for `hidden`
  # or `detached`.
  #
  # Wait for the `selector` relative to the element handle to satisfy `state` option (either
  # appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already
  # satisfies the condition, the method will return immediately. If the selector doesn't satisfy the condition for the
  # `timeout` milliseconds, the function will throw.
  #
  # **Usage**
  #
  # ```python sync
  # page.set_content("<div><span></span></div>")
  # div = page.query_selector("div")
  # # waiting for the "span" selector relative to the div.
  # span = div.wait_for_selector("span", state="attached")
  # ```
  #
  # **NOTE**: This method does not work across navigations, use [`method: Page.waitForSelector`] instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#571
  def wait_for_selector(selector, state: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright_api/element_handle.rb#593
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/errors.rb#2
class Playwright::Error < ::StandardError
  # @param name [String]
  # @param message [String]
  # @param stack [Array<String>]
  # @return [Error] a new instance of Error
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#27
  def initialize(message:, name: T.unsafe(nil), stack: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/errors.rb#36
  def log=(log); end

  # Returns the value of attribute message.
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#34
  def message; end

  # Returns the value of attribute name.
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#34
  def name; end

  # Returns the value of attribute stack.
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#34
  def stack; end

  class << self
    # ref: https://github.com/microsoft/playwright-python/blob/0b4a980fed366c4c1dee9bfcdd72662d629fdc8d/playwright/_impl/_helper.py#L155
    #
    # source://playwright-ruby-client//lib/playwright/errors.rb#4
    def parse(error_payload); end
  end
end

# A subset of Events/EventEmitter in Node.js
#
# source://playwright-ruby-client//lib/playwright/event_emitter.rb#35
module Playwright::EventEmitter
  # @param event [String]
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#38
  def emit(event, *args); end

  # @param event [String]
  # @param callback [Proc]
  # @raise [ArgumentError]
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#79
  def off(event, callback); end

  # @param event [String]
  # @param callback [Proc]
  # @raise [ArgumentError]
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#60
  def on(event, callback); end

  # @param event [String]
  # @param callback [Proc]
  # @raise [ArgumentError]
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#69
  def once(event, callback); end

  private

  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#49
  def listener_count(event); end

  # can be overriden
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#54
  def perform_event_emitter_callback(event, callback, args); end
end

# source://playwright-ruby-client//lib/playwright/event_emitter.rb#2
class Playwright::EventEmitterCallback
  # @return [EventEmitterCallback] a new instance of EventEmitterCallback
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#3
  def initialize(callback_proc); end

  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#7
  def call(*args); end
end

# source://playwright-ruby-client//lib/playwright/event_emitter.rb#13
class Playwright::EventEmitterOnceCallback < ::Playwright::EventEmitterCallback
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#14
  def call(*args); end
end

# source://playwright-ruby-client//lib/playwright/event_emitter_proxy.rb#2
class Playwright::EventEmitterProxy
  include ::Playwright::EventEmitter

  # @param src [PlaywrightApi]
  # @param dest [EventEmitter]
  # @return [EventEmitterProxy] a new instance of EventEmitterProxy
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter_proxy.rb#7
  def initialize(api, impl); end

  # source://playwright-ruby-client//lib/playwright/event_emitter_proxy.rb#27
  def off(event, callback); end

  # source://playwright-ruby-client//lib/playwright/event_emitter_proxy.rb#13
  def on(event, callback); end

  # source://playwright-ruby-client//lib/playwright/event_emitter_proxy.rb#20
  def once(event, callback); end

  private

  # source://playwright-ruby-client//lib/playwright/event_emitter_proxy.rb#34
  def subscribe(event); end

  # source://playwright-ruby-client//lib/playwright/event_emitter_proxy.rb#42
  def unsubscribe(event); end
end

# source://playwright-ruby-client//lib/playwright/event_emitter.rb#20
module Playwright::EventListenerInterface
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#25
  def off(event, callback); end

  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#21
  def on(event, callback); end

  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright/event_emitter.rb#29
  def once(event, callback); end
end

# source://playwright-ruby-client//lib/playwright/events.rb#2
module Playwright::Events; end

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::AndroidDevice
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::AndroidDevice::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::AndroidDevice::WebView = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::AndroidSocket
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::AndroidSocket::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::AndroidSocket::Data = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::AndroidWebView
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::AndroidWebView::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::Browser
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Browser::Disconnected = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::BrowserContext
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::BackgroundPage = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::Console = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::Dialog = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::Page = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::Request = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::RequestFailed = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::RequestFinished = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::Response = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::ServiceWorker = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserContext::WebError = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::BrowserServer
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::BrowserServer::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::ElectronApplication
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::ElectronApplication::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::ElectronApplication::Window = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::Page
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Console = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Crash = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::DOMContentLoaded = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Dialog = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Download = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::FileChooser = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::FrameAttached = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::FrameDetached = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::FrameNavigated = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Load = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::PageError = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Popup = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Request = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::RequestFailed = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::RequestFinished = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Response = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::WebSocket = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Page::Worker = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::WebSocket
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::WebSocket::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::WebSocket::Error = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::WebSocket::FrameReceived = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::WebSocket::FrameSent = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/events.rb#84
module Playwright::Events::Worker
  class << self
    # source://playwright-ruby-client//lib/playwright/events.rb#88
    def keys; end
  end
end

# source://playwright-ruby-client//lib/playwright/events.rb#86
Playwright::Events::Worker::Close = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright.rb#39
class Playwright::Execution
  # @return [Execution] a new instance of Execution
  #
  # source://playwright-ruby-client//lib/playwright.rb#40
  def initialize(connection, playwright, browser = T.unsafe(nil)); end

  # Returns the value of attribute browser.
  #
  # source://playwright-ruby-client//lib/playwright.rb#51
  def browser; end

  # Returns the value of attribute playwright.
  #
  # source://playwright-ruby-client//lib/playwright.rb#51
  def playwright; end

  # source://playwright-ruby-client//lib/playwright.rb#46
  def stop; end
end

# `FileChooser` objects are dispatched by the page in the [`event: Page.fileChooser`] event.
#
# ```python sync
# with page.expect_file_chooser() as fc_info:
#     page.get_by_text("Upload file").click()
# file_chooser = fc_info.value
# file_chooser.set_files("myfile.pdf")
# ```
#
# source://playwright-ruby-client//lib/playwright_api/file_chooser.rb#11
class Playwright::FileChooser < ::Playwright::PlaywrightApi
  # Returns input element associated with this file chooser.
  #
  # source://playwright-ruby-client//lib/playwright_api/file_chooser.rb#15
  def element; end

  # Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths, then
  # they are resolved relative to the current working directory. For empty array, clears the selected files.
  #
  # source://playwright-ruby-client//lib/playwright_api/file_chooser.rb#34
  def files=(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns whether this file chooser accepts multiple files.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/file_chooser.rb#21
  def multiple?; end

  # Returns page this file chooser belongs to.
  #
  # source://playwright-ruby-client//lib/playwright_api/file_chooser.rb#27
  def page; end

  # Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths, then
  # they are resolved relative to the current working directory. For empty array, clears the selected files.
  #
  # source://playwright-ruby-client//lib/playwright_api/file_chooser.rb#34
  def set_files(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end
end

# source://playwright-ruby-client//lib/playwright/file_chooser_impl.rb#0
class Playwright::FileChooserImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/file_chooser_impl.rb#3
  def initialize(page:, timeout_settings:, element_handle:, is_multiple:); end

  # source://playwright-ruby-client//lib/playwright/file_chooser_impl.rb#12
  def element; end

  # source://playwright-ruby-client//lib/playwright/file_chooser_impl.rb#16
  def multiple?; end

  # source://playwright-ruby-client//lib/playwright/file_chooser_impl.rb#10
  def page; end

  # source://playwright-ruby-client//lib/playwright/file_chooser_impl.rb#20
  def set_files(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end
end

# At every point of time, page exposes its current frame tree via the [`method: Page.mainFrame`] and
# [`method: Frame.childFrames`] methods.
#
# `Frame` object's lifecycle is controlled by three events, dispatched on the page object:
# - [`event: Page.frameAttached`] - fired when the frame gets attached to the page. A Frame can be attached to the page only once.
# - [`event: Page.frameNavigated`] - fired when the frame commits navigation to a different URL.
# - [`event: Page.frameDetached`] - fired when the frame gets detached from the page.  A Frame can be detached from the page only once.
#
# An example of dumping frame tree:
#
# ```python sync
# from playwright.sync_api import sync_playwright, Playwright
#
# def run(playwright: Playwright):
#     firefox = playwright.firefox
#     browser = firefox.launch()
#     page = browser.new_page()
#     page.goto("https://www.theverge.com")
#     dump_frame_tree(page.main_frame, "")
#     browser.close()
#
# def dump_frame_tree(frame, indent):
#     print(indent + frame.name + '@' + frame.url)
#     for child in frame.child_frames:
#         dump_frame_tree(child, indent + "    ")
#
# with sync_playwright() as playwright:
#     run(playwright)
# ```
#
# source://playwright-ruby-client//lib/playwright_api/frame.rb#32
class Playwright::Frame < ::Playwright::PlaywrightApi
  # Returns the added tag when the script's onload fires or when the script content was injected into frame.
  #
  # Adds a `<script>` tag into the page with the desired url or content.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#38
  def add_script_tag(content: T.unsafe(nil), path: T.unsafe(nil), type: T.unsafe(nil), url: T.unsafe(nil)); end

  # Returns the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.
  #
  # Adds a `<link rel="stylesheet">` tag into the page with the desired url or a `<style type="text/css">` tag with the
  # content.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#47
  def add_style_tag(content: T.unsafe(nil), path: T.unsafe(nil), url: T.unsafe(nil)); end

  # This method checks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is already checked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#62
  def check(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is checked. Throws if the element is not a checkbox or radio input.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#621
  def checked?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/frame.rb#73
  def child_frames; end

  # This method clicks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element, or the specified `position`.
  # 1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#87
  def click(selector, button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Gets the full HTML contents of the frame, including the doctype.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#104
  def content; end

  # This method internally calls [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), inheriting all its specific characteristics and behaviors.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#808
  def content=(html, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # This method double clicks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to double click in the center of the element, or the specified `position`. if the first click of the `dblclick()` triggers a navigation event, this method will throw.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#119
  def dblclick(selector, button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1043
  def detached=(req); end

  # Returns `true` if the frame has been detached, or `false` otherwise.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#627
  def detached?; end

  # Returns whether the element is disabled, the opposite of [enabled](../actionability.md#enabled).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#633
  def disabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the element, `click`
  # is dispatched. This is equivalent to calling
  # [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).
  #
  # **Usage**
  #
  # ```python sync
  # frame.dispatch_event("button#submit", "click")
  # ```
  #
  # Under the hood, it creates an instance of an event based on the given `type`, initializes it with
  # `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by
  # default.
  #
  # Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial
  # properties:
  # - [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
  # - [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
  # - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
  # - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
  # - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
  # - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
  # - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
  # - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
  # - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
  # - [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)
  #
  # You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:
  #
  # ```python sync
  # # note you can only create data_transfer in chromium and firefox
  # data_transfer = frame.evaluate_handle("new DataTransfer()")
  # frame.dispatch_event("#source", "dragstart", { "dataTransfer": data_transfer })
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#168
  def dispatch_event(selector, type, eventInit: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/frame.rb#177
  def drag_and_drop(source, target, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), sourcePosition: T.unsafe(nil), strict: T.unsafe(nil), targetPosition: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is [editable](../actionability.md#editable).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#639
  def editable?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns whether the element is [enabled](../actionability.md#enabled).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#645
  def enabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns the return value of `expression`.
  #
  # The method finds an element matching the specified selector within the frame and passes it as a first argument to
  # `expression`. If no
  # elements match the selector, the method throws an error.
  #
  # If `expression` returns a [Promise], then [`method: Frame.evalOnSelector`] would wait for the promise to resolve and return its
  # value.
  #
  # **Usage**
  #
  # ```python sync
  # search_value = frame.eval_on_selector("#search", "el => el.value")
  # preload_href = frame.eval_on_selector("link[rel=preload]", "el => el.href")
  # html = frame.eval_on_selector(".main-container", "(e, suffix) => e.outerHTML + suffix", "hello")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#207
  def eval_on_selector(selector, expression, arg: T.unsafe(nil), strict: T.unsafe(nil)); end

  # Returns the return value of `expression`.
  #
  # The method finds all elements matching the specified selector within the frame and passes an array of matched elements
  # as a first argument to `expression`.
  #
  # If `expression` returns a [Promise], then [`method: Frame.evalOnSelectorAll`] would wait for the promise to resolve and return its
  # value.
  #
  # **Usage**
  #
  # ```python sync
  # divs_counts = frame.eval_on_selector_all("div", "(divs, min) => divs.length >= min", 10)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#225
  def eval_on_selector_all(selector, expression, arg: T.unsafe(nil)); end

  # Returns the return value of `expression`.
  #
  # If the function passed to the [`method: Frame.evaluate`] returns a [Promise], then [`method: Frame.evaluate`] would wait for the promise to
  # resolve and return its value.
  #
  # If the function passed to the [`method: Frame.evaluate`] returns a non-[Serializable] value, then
  # [`method: Frame.evaluate`] returns `undefined`. Playwright also supports transferring some
  # additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.
  #
  # **Usage**
  #
  # ```python sync
  # result = frame.evaluate("([x, y]) => Promise.resolve(x * y)", [7, 8])
  # print(result) # prints "56"
  # ```
  #
  # A string can also be passed in instead of a function.
  #
  # ```python sync
  # print(frame.evaluate("1 + 2")) # prints "3"
  # x = 10
  # print(frame.evaluate(f"1 + {x}")) # prints "11"
  # ```
  #
  # `ElementHandle` instances can be passed as an argument to the [`method: Frame.evaluate`]:
  #
  # ```python sync
  # body_handle = frame.evaluate("document.body")
  # html = frame.evaluate("([body, suffix]) => body.innerHTML + suffix", [body_handle, "hello"])
  # body_handle.dispose()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#261
  def evaluate(expression, arg: T.unsafe(nil)); end

  # Returns the return value of `expression` as a `JSHandle`.
  #
  # The only difference between [`method: Frame.evaluate`] and [`method: Frame.evaluateHandle`] is that
  # [`method: Frame.evaluateHandle`] returns `JSHandle`.
  #
  # If the function, passed to the [`method: Frame.evaluateHandle`], returns a [Promise], then
  # [`method: Frame.evaluateHandle`] would wait for the promise to resolve and return its value.
  #
  # **Usage**
  #
  # ```python sync
  # a_window_handle = frame.evaluate_handle("Promise.resolve(window)")
  # a_window_handle # handle for the window object.
  # ```
  #
  # A string can also be passed in instead of a function.
  #
  # ```python sync
  # a_handle = page.evaluate_handle("document") # handle for the "document"
  # ```
  #
  # `JSHandle` instances can be passed as an argument to the [`method: Frame.evaluateHandle`]:
  #
  # ```python sync
  # a_handle = page.evaluate_handle("document.body")
  # result_handle = page.evaluate_handle("body => body.innerHTML", a_handle)
  # print(result_handle.json_value())
  # result_handle.dispose()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#295
  def evaluate_handle(expression, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1053
  def expect(selector, expression, options, title); end

  # Waits for the frame navigation and returns the main resource response. In case of multiple redirects, the navigation
  # will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to
  # History API usage, the navigation will resolve with `null`.
  #
  # **Usage**
  #
  # This method waits for the frame to navigate to a new URL. It is useful for when you run code which will indirectly cause
  # the frame to navigate. Consider this example:
  #
  # ```python sync
  # with frame.expect_navigation():
  #     frame.click("a.delayed-navigation") # clicking the link will indirectly cause a navigation
  # # Resolves after navigation has finished
  # ```
  #
  # **NOTE**: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is considered
  # a navigation.
  #
  # @deprecated This method is inherently racy, please use [`method: Frame.waitForURL`] instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#980
  def expect_navigation(timeout: T.unsafe(nil), url: T.unsafe(nil), waitUntil: T.unsafe(nil), &block); end

  # This method waits for an element matching `selector`, waits for [actionability](../actionability.md) checks, focuses the element, fills it and triggers an `input` event after filling. Note that you can pass an empty string to clear the input field.
  #
  # If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be filled instead.
  #
  # To send fine-grained keyboard events, use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#305
  def fill(selector, value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method fetches an element with `selector` and focuses it. If there's no element matching
  # `selector`, the method waits until a matching element appears in the DOM.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#318
  def focus(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns the `frame` or `iframe` element handle which corresponds to this frame.
  #
  # This is an inverse of [`method: ElementHandle.contentFrame`]. Note that returned handle actually belongs to the parent
  # frame.
  #
  # This method throws an error if the frame has been detached before `frameElement()` returns.
  #
  # **Usage**
  #
  # ```python sync
  # frame_element = frame.frame_element()
  # content_frame = frame_element.content_frame()
  # assert frame == content_frame
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#337
  def frame_element; end

  # When working with iframes, you can create a frame locator that will enter the iframe and allow selecting elements
  # in that iframe.
  #
  # **Usage**
  #
  # Following snippet locates element with text "Submit" in the iframe with id `my-frame`, like `<iframe id="my-frame">`:
  #
  # ```python sync
  # locator = frame.frame_locator("#my-iframe").get_by_text("Submit")
  # locator.click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#353
  def frame_locator(selector); end

  # Returns element attribute value.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#359
  def get_attribute(selector, name, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Allows locating elements by their alt text.
  #
  # **Usage**
  #
  # For example, this method will find the image by alt text "Playwright logo":
  #
  # ```html
  # <img alt='Playwright logo'>
  # ```
  #
  # ```python sync
  # page.get_by_alt_text("Playwright logo").click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#377
  def get_by_alt_text(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the `aria-label` attribute.
  #
  # **Usage**
  #
  # For example, this method will find inputs by label "Username" and "Password" in the following DOM:
  #
  # ```html
  # <input aria-label="Username">
  # <label for="password-input">Password:</label>
  # <input id="password-input">
  # ```
  #
  # ```python sync
  # page.get_by_label("Username").fill("john")
  # page.get_by_label("Password").fill("secret")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#398
  def get_by_label(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the placeholder text.
  #
  # **Usage**
  #
  # For example, consider the following DOM structure.
  #
  # ```html
  # <input type="email" placeholder="name@example.com" />
  # ```
  #
  # You can fill the input after locating it by the placeholder text:
  #
  # ```python sync
  # page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#418
  def get_by_placeholder(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <h3>Sign up</h3>
  # <label>
  #   <input type="checkbox" /> Subscribe
  # </label>
  # <br/>
  # <button>Submit</button>
  # ```
  #
  # You can locate each element by it's implicit role:
  #
  # ```python sync
  # expect(page.get_by_role("heading", name="Sign up")).to_be_visible()
  #
  # page.get_by_role("checkbox", name="Subscribe").check()
  #
  # page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
  # ```
  #
  # **Details**
  #
  # Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback about the ARIA guidelines.
  #
  # Many html elements have an implicitly [defined role](https://w3c.github.io/html-aam/#html-element-role-mappings) that is recognized by the role selector. You can find all the [supported roles here](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). ARIA guidelines **do not recommend** duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#453
  def get_by_role(role, checked: T.unsafe(nil), disabled: T.unsafe(nil), exact: T.unsafe(nil), expanded: T.unsafe(nil), includeHidden: T.unsafe(nil), level: T.unsafe(nil), name: T.unsafe(nil), pressed: T.unsafe(nil), selected: T.unsafe(nil)); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#487
  def get_by_test_id(testId); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#487
  def get_by_testid(testId); end

  # Allows locating elements that contain given text.
  #
  # See also [`method: Locator.filter`] that allows to match by another criteria, like an accessible role, and then filter by the text content.
  #
  # **Usage**
  #
  # Consider the following DOM structure:
  #
  # ```html
  # <div>Hello <span>world</span></div>
  # <div>Hello</div>
  # ```
  #
  # You can locate by text substring, exact string, or a regular expression:
  #
  # ```python sync
  # # Matches <span>
  # page.get_by_text("world")
  #
  # # Matches first <div>
  # page.get_by_text("Hello world")
  #
  # # Matches second <div>
  # page.get_by_text("Hello", exact=True)
  #
  # # Matches both <div>s
  # page.get_by_text(re.compile("Hello"))
  #
  # # Matches second <div>
  # page.get_by_text(re.compile("^hello$", re.IGNORECASE))
  # ```
  #
  # **Details**
  #
  # Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into one, turns line breaks into spaces and ignores leading and trailing whitespace.
  #
  # Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For example, locating by text `"Log in"` matches `<input type=button value="Log in">`.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#530
  def get_by_text(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their title attribute.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <span title='Issues count'>25 issues</span>
  # ```
  #
  # You can check the issues count after locating it by the title text:
  #
  # ```python sync
  # expect(page.get_by_title("Issues count")).to_have_text("25 issues")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#550
  def get_by_title(text, exact: T.unsafe(nil)); end

  # Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
  # last redirect.
  #
  # The method will throw an error if:
  # - there's an SSL error (e.g. in case of self-signed certificates).
  # - target URL is invalid.
  # - the `timeout` is exceeded during navigation.
  # - the remote server does not respond or is unreachable.
  # - the main resource failed to load.
  #
  # The method will not throw an error when any valid HTTP status code is returned by the remote server, including 404
  # "Not Found" and 500 "Internal Server Error".  The status code for such responses can be retrieved by calling
  # [`method: Response.status`].
  #
  # **NOTE**: The method either throws an error or returns a main resource response. The only exceptions are navigation to
  # `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
  #
  # **NOTE**: Headless mode doesn't support navigation to a PDF document. See the
  # [upstream issue](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#574
  def goto(url, referer: T.unsafe(nil), timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # Returns whether the element is hidden, the opposite of [visible](../actionability.md#visible).  `selector` that does not match any elements is considered hidden.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#651
  def hidden?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1048
  def highlight(selector); end

  # This method hovers over an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to hover over the center of the element, or the specified `position`.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#587
  def hover(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns `element.innerHTML`.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#601
  def inner_html(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns `element.innerText`.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#607
  def inner_text(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns `input.value` for the selected `<input>` or `<textarea>` or `<select>` element.
  #
  # Throws for non-input elements. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), returns the value of the control.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#615
  def input_value(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The method returns an element locator that can be used to perform actions on this page / frame.
  # Locator is resolved to the element immediately before performing an action, so a series of actions on the same locator can in fact be performed on different DOM elements. That would happen if the DOM structure between those actions has changed.
  #
  # [Learn more about locators](../locators.md).
  #
  # [Learn more about locators](../locators.md).
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#668
  def locator(selector, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # Returns frame's name attribute as specified in the tag.
  #
  # If the name is empty, returns the id attribute instead.
  #
  # **NOTE**: This value is calculated once when the frame is created, and will not update if the attribute is changed later.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#683
  def name; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1071
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1065
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1059
  def once(event, callback); end

  # Returns the page containing this frame.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#689
  def page; end

  # Parent frame, if any. Detached frames and main frames return `null`.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#695
  def parent_frame; end

  # `key` can specify the intended
  # [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) value or a single character to
  # generate the text for. A superset of the `key` values can be found
  # [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:
  #
  # `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
  # `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
  #
  # Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.
  # `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.
  #
  # Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
  #
  # If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different
  # respective texts.
  #
  # Shortcuts such as `key: "Control+o"`, `key: "Control++` or `key: "Control+Shift+T"` are supported as well. When specified with the
  # modifier, modifier is pressed and being held while the subsequent key is being pressed.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#718
  def press(selector, key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns the ElementHandle pointing to the frame element.
  #
  # **NOTE**: The use of `ElementHandle` is discouraged, use `Locator` objects and web-first assertions instead.
  #
  # The method finds an element matching the specified selector within the frame. If no elements match the selector,
  # returns `null`.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#735
  def query_selector(selector, strict: T.unsafe(nil)); end

  # Returns the ElementHandles pointing to the frame elements.
  #
  # **NOTE**: The use of `ElementHandle` is discouraged, use `Locator` objects instead.
  #
  # The method finds all elements matching the specified selector within the frame. If no elements match the selector,
  # returns empty array.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#746
  def query_selector_all(selector); end

  # This method waits for an element matching `selector`, waits for [actionability](../actionability.md) checks, waits until all specified options are present in the `<select>` element and selects these options.
  #
  # If the target element is not a `<select>` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be used instead.
  #
  # Returns the array of option values that have been successfully selected.
  #
  # Triggers a `change` and `input` event once all the provided options have been selected.
  #
  # **Usage**
  #
  # ```python sync
  # # Single selection matching the value or label
  # frame.select_option("select#colors", "blue")
  # # single selection matching both the label
  # frame.select_option("select#colors", label="blue")
  # # multiple selection
  # frame.select_option("select#colors", value=["red", "green", "blue"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#769
  def select_option(selector, element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method checks or unchecks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws.
  # 1. If the element already has the right checked state, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked or unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#794
  def set_checked(selector, checked, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # This method internally calls [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), inheriting all its specific characteristics and behaviors.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#808
  def set_content(html, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
  # are resolved relative to the current working directory. For empty array, clears the selected files.
  #
  # This method expects `selector` to point to an
  # [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), targets the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#819
  def set_input_files(selector, files, noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method taps an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.touchscreen`] to tap the center of the element, or the specified `position`.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: `frame.tap()` requires that the `hasTouch` option of the browser context be set to true.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#839
  def tap_point(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns `element.textContent`.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#853
  def text_content(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns the page title.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#859
  def title; end

  # Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used to
  # send fine-grained keyboard events. To fill values in form fields, use [`method: Frame.fill`].
  #
  # To press a special key, like `Control` or `ArrowDown`, use [`method: Keyboard.press`].
  #
  # **Usage**
  #
  # @deprecated In most cases, you should use [`method: Locator.fill`] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#872
  def type(selector, text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method checks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is already unchecked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#893
  def uncheck(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns frame's url.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#906
  def url; end

  # Returns whether the element is [visible](../actionability.md#visible). `selector` that does not match any elements is considered not visible.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#657
  def visible?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns when the `expression` returns a truthy value, returns that value.
  #
  # **Usage**
  #
  # The [`method: Frame.waitForFunction`] can be used to observe viewport size change:
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     webkit = playwright.webkit
  #     browser = webkit.launch()
  #     page = browser.new_page()
  #     page.evaluate("window.x = 0; setTimeout(() => { window.x = 100 }, 1000);")
  #     page.main_frame.wait_for_function("() => window.x > 0")
  #     browser.close()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # To pass an argument to the predicate of `frame.waitForFunction` function:
  #
  # ```python sync
  # selector = ".foo"
  # frame.wait_for_function("selector => !!document.querySelector(selector)", selector)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#938
  def wait_for_function(expression, arg: T.unsafe(nil), polling: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Waits for the required load state to be reached.
  #
  # This returns when the frame reaches a required load state, `load` by default. The navigation must have been committed
  # when this method is called. If current document has already reached the required state, resolves immediately.
  #
  # **NOTE**: Most of the time, this method is not needed because Playwright [auto-waits before every action](../actionability.md).
  #
  # **Usage**
  #
  # ```python sync
  # frame.click("button") # click triggers navigation.
  # frame.wait_for_load_state() # the promise resolves after "load" event.
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#956
  def wait_for_load_state(state: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns when element specified by selector satisfies `state` option. Returns `null` if waiting for `hidden` or
  # `detached`.
  #
  # **NOTE**: Playwright automatically waits for element to be ready before performing an action. Using
  # `Locator` objects and web-first assertions make the code wait-for-selector-free.
  #
  # Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become
  # visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method
  # will return immediately. If the selector doesn't satisfy the condition for the `timeout` milliseconds, the
  # function will throw.
  #
  # **Usage**
  #
  # This method works across navigations:
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     chromium = playwright.chromium
  #     browser = chromium.launch()
  #     page = browser.new_page()
  #     for current_url in ["https://google.com", "https://bbc.com"]:
  #         page.goto(current_url, wait_until="domcontentloaded")
  #         element = page.main_frame.wait_for_selector("img")
  #         print("Loaded image: " + str(element.get_attribute("src")))
  #     browser.close()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1016
  def wait_for_selector(selector, state: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Waits for the given `timeout` in milliseconds.
  #
  # Note that `frame.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to
  # be flaky. Use signals such as network events, selectors becoming visible and others instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1025
  def wait_for_timeout(timeout); end

  # Waits for the frame to navigate to the given URL.
  #
  # **Usage**
  #
  # ```python sync
  # frame.click("a.delayed-navigation") # clicking the link will indirectly cause a navigation
  # frame.wait_for_url("**/target.html")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1038
  def wait_for_url(url, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright_api/frame.rb#1075
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/frame.rb#88
class Playwright::FrameAlreadyDetachedError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/channel_owners/page.rb#921
  def initialize; end
end

# FrameLocator represents a view to the `iframe` on the page. It captures the logic sufficient to retrieve the `iframe` and locate elements in that iframe. FrameLocator can be created with either [`method: Locator.contentFrame`], [`method: Page.frameLocator`] or [`method: Locator.frameLocator`] method.
#
# ```python sync
# locator = page.locator("my-frame").content_frame.get_by_text("Submit")
# locator.click()
# ```
#
# **Strictness**
#
# Frame locators are strict. This means that all operations on frame locators will throw if more than one element matches a given selector.
#
# ```python sync
# # Throws if there are several frames in DOM:
# page.locator('.result-frame').content_frame.get_by_role('button').click()
#
# # Works because we explicitly tell locator to pick the first frame:
# page.locator('.result-frame').first.content_frame.get_by_role('button').click()
# ```
#
# **Converting Locator to FrameLocator**
#
# If you have a `Locator` object pointing to an `iframe` it can be converted to `FrameLocator` using [`method: Locator.contentFrame`].
#
# **Converting FrameLocator to Locator**
#
# If you have a `FrameLocator` object it can be converted to `Locator` pointing to the same `iframe` using [`method: FrameLocator.owner`].
#
# source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#29
class Playwright::FrameLocator < ::Playwright::PlaywrightApi
  # Returns locator to the first matching frame.
  #
  # @deprecated Use [`method: Locator.first`] followed by [`method: Locator.contentFrame`] instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#35
  def first; end

  # When working with iframes, you can create a frame locator that will enter the iframe and allow selecting elements
  # in that iframe.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#42
  def frame_locator(selector); end

  # Allows locating elements by their alt text.
  #
  # **Usage**
  #
  # For example, this method will find the image by alt text "Playwright logo":
  #
  # ```html
  # <img alt='Playwright logo'>
  # ```
  #
  # ```python sync
  # page.get_by_alt_text("Playwright logo").click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#60
  def get_by_alt_text(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the `aria-label` attribute.
  #
  # **Usage**
  #
  # For example, this method will find inputs by label "Username" and "Password" in the following DOM:
  #
  # ```html
  # <input aria-label="Username">
  # <label for="password-input">Password:</label>
  # <input id="password-input">
  # ```
  #
  # ```python sync
  # page.get_by_label("Username").fill("john")
  # page.get_by_label("Password").fill("secret")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#81
  def get_by_label(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the placeholder text.
  #
  # **Usage**
  #
  # For example, consider the following DOM structure.
  #
  # ```html
  # <input type="email" placeholder="name@example.com" />
  # ```
  #
  # You can fill the input after locating it by the placeholder text:
  #
  # ```python sync
  # page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#101
  def get_by_placeholder(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <h3>Sign up</h3>
  # <label>
  #   <input type="checkbox" /> Subscribe
  # </label>
  # <br/>
  # <button>Submit</button>
  # ```
  #
  # You can locate each element by it's implicit role:
  #
  # ```python sync
  # expect(page.get_by_role("heading", name="Sign up")).to_be_visible()
  #
  # page.get_by_role("checkbox", name="Subscribe").check()
  #
  # page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
  # ```
  #
  # **Details**
  #
  # Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback about the ARIA guidelines.
  #
  # Many html elements have an implicitly [defined role](https://w3c.github.io/html-aam/#html-element-role-mappings) that is recognized by the role selector. You can find all the [supported roles here](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). ARIA guidelines **do not recommend** duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#136
  def get_by_role(role, checked: T.unsafe(nil), disabled: T.unsafe(nil), exact: T.unsafe(nil), expanded: T.unsafe(nil), includeHidden: T.unsafe(nil), level: T.unsafe(nil), name: T.unsafe(nil), pressed: T.unsafe(nil), selected: T.unsafe(nil)); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#170
  def get_by_test_id(testId); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#170
  def get_by_testid(testId); end

  # Allows locating elements that contain given text.
  #
  # See also [`method: Locator.filter`] that allows to match by another criteria, like an accessible role, and then filter by the text content.
  #
  # **Usage**
  #
  # Consider the following DOM structure:
  #
  # ```html
  # <div>Hello <span>world</span></div>
  # <div>Hello</div>
  # ```
  #
  # You can locate by text substring, exact string, or a regular expression:
  #
  # ```python sync
  # # Matches <span>
  # page.get_by_text("world")
  #
  # # Matches first <div>
  # page.get_by_text("Hello world")
  #
  # # Matches second <div>
  # page.get_by_text("Hello", exact=True)
  #
  # # Matches both <div>s
  # page.get_by_text(re.compile("Hello"))
  #
  # # Matches second <div>
  # page.get_by_text(re.compile("^hello$", re.IGNORECASE))
  # ```
  #
  # **Details**
  #
  # Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into one, turns line breaks into spaces and ignores leading and trailing whitespace.
  #
  # Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For example, locating by text `"Log in"` matches `<input type=button value="Log in">`.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#213
  def get_by_text(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their title attribute.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <span title='Issues count'>25 issues</span>
  # ```
  #
  # You can check the issues count after locating it by the title text:
  #
  # ```python sync
  # expect(page.get_by_title("Issues count")).to_have_text("25 issues")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#233
  def get_by_title(text, exact: T.unsafe(nil)); end

  # Returns locator to the last matching frame.
  #
  # @deprecated Use [`method: Locator.last`] followed by [`method: Locator.contentFrame`] instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#241
  def last; end

  # The method finds an element matching the specified selector in the locator's subtree. It also accepts filter options, similar to [`method: Locator.filter`] method.
  #
  # [Learn more about locators](../locators.md).
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#249
  def locator(selectorOrLocator, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # Returns locator to the n-th matching frame. It's zero based, `nth(0)` selects the first frame.
  #
  # @deprecated Use [`method: Locator.nth`] followed by [`method: Locator.contentFrame`] instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#262
  def nth(index); end

  # Returns a `Locator` object pointing to the same `iframe` as this frame locator.
  #
  # Useful when you have a `FrameLocator` object obtained somewhere, and later on would like to interact with the `iframe` element.
  #
  # For a reverse operation, use [`method: Locator.contentFrame`].
  #
  # **Usage**
  #
  # ```python sync
  # frame_locator = page.locator("iframe[name=\"embedded\"]").content_frame
  # # ...
  # locator = frame_locator.owner
  # expect(locator).to_be_visible()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/frame_locator.rb#281
  def owner; end
end

# source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#0
class Playwright::FrameLocatorImpl
  include ::Playwright::ApiImplementation
  include ::Playwright::LocatorUtils

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#7
  def initialize(frame:, frame_selector:); end

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#45
  def first; end

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#38
  def frame_locator(selector); end

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#52
  def last; end

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#16
  def locator(selector, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#59
  def nth(index); end

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#31
  def owner; end

  private

  # source://playwright-ruby-client//lib/playwright/frame_locator_impl.rb#12
  def _timeout(timeout); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#89
class Playwright::FramePageNotReadyError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#96
  def initialize; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/request.rb#90
Playwright::FramePageNotReadyError::MESSAGE = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/har_router.rb#2
class Playwright::HarRouter
  # @param local_utils [LocalUtils]
  # @param har_id [String]
  # @param not_found_action [String] 'abort' or 'fallback'
  # @param url_match [String||Regexp|nil]
  # @return [HarRouter] a new instance of HarRouter
  #
  # source://playwright-ruby-client//lib/playwright/har_router.rb#22
  def initialize(local_utils:, har_id:, not_found_action:, url_match: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/har_router.rb#75
  def add_context_route(context); end

  # source://playwright-ruby-client//lib/playwright/har_router.rb#80
  def add_page_route(page); end

  # source://playwright-ruby-client//lib/playwright/har_router.rb#85
  def dispose; end

  private

  # source://playwright-ruby-client//lib/playwright/har_router.rb#34
  def handle(route, request); end

  class << self
    # @param local_utils [LocalUtils]
    # @param file [String]
    # @param not_found_action [String] 'abort' or 'fallback'
    # @param url_match [String||Regexp|nil]
    #
    # source://playwright-ruby-client//lib/playwright/har_router.rb#7
    def create(local_utils, file, not_found_action, url_match: T.unsafe(nil)); end
  end
end

# source://playwright-ruby-client//lib/playwright/http_headers.rb#2
class Playwright::HttpHeaders
  # @param headers [Hash]
  # @return [HttpHeaders] a new instance of HttpHeaders
  #
  # source://playwright-ruby-client//lib/playwright/http_headers.rb#4
  def initialize(headers); end

  # source://playwright-ruby-client//lib/playwright/http_headers.rb#8
  def as_serialized; end
end

# source://playwright-ruby-client//lib/playwright/input_files.rb#4
class Playwright::InputFiles
  # @return [InputFiles] a new instance of InputFiles
  #
  # source://playwright-ruby-client//lib/playwright/input_files.rb#5
  def initialize(context, files); end

  # source://playwright-ruby-client//lib/playwright/input_files.rb#17
  def as_method_and_params; end

  private

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/input_files.rb#25
  def has_large_file?; end

  # source://playwright-ruby-client//lib/playwright/input_files.rb#68
  def params_for_set_input_file_paths; end

  # source://playwright-ruby-client//lib/playwright/input_files.rb#106
  def params_for_set_input_files; end

  # @raise [ArgumentError]
  #
  # source://playwright-ruby-client//lib/playwright/input_files.rb#125
  def raise_argument_error; end

  # source://playwright-ruby-client//lib/playwright/input_files.rb#38
  def resolve_paths_and_directory_for_input_files(files); end
end

# JSHandle represents an in-page JavaScript object. JSHandles can be created with the [`method: Page.evaluateHandle`]
# method.
#
# ```python sync
# window_handle = page.evaluate_handle("window")
# # ...
# ```
#
# JSHandle prevents the referenced JavaScript object being garbage collected unless the handle is exposed with
# [`method: JSHandle.dispose`]. JSHandles are auto-disposed when their origin frame gets navigated or the parent context
# gets destroyed.
#
# JSHandle instances can be used as an argument in [`method: Page.evalOnSelector`], [`method: Page.evaluate`] and
# [`method: Page.evaluateHandle`] methods.
#
# source://playwright-ruby-client//lib/playwright_api/js_handle.rb#17
class Playwright::JSHandle < ::Playwright::PlaywrightApi
  # Returns either `null` or the object handle itself, if the object handle is an instance of `ElementHandle`.
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#21
  def as_element; end

  # The `jsHandle.dispose` method stops referencing the element handle.
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#27
  def dispose; end

  # Returns the return value of `expression`.
  #
  # This method passes this handle as the first argument to `expression`.
  #
  # If `expression` returns a [Promise], then `handle.evaluate` would wait for the promise to resolve and return
  # its value.
  #
  # **Usage**
  #
  # ```python sync
  # tweet_handle = page.query_selector(".tweet .retweets")
  # assert tweet_handle.evaluate("node => node.innerText") == "10 retweets"
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#45
  def evaluate(expression, arg: T.unsafe(nil)); end

  # Returns the return value of `expression` as a `JSHandle`.
  #
  # This method passes this handle as the first argument to `expression`.
  #
  # The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle` returns `JSHandle`.
  #
  # If the function passed to the `jsHandle.evaluateHandle` returns a [Promise], then `jsHandle.evaluateHandle` would wait
  # for the promise to resolve and return its value.
  #
  # See [`method: Page.evaluateHandle`] for more details.
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#60
  def evaluate_handle(expression, arg: T.unsafe(nil)); end

  # The method returns a map with **own property names** as keys and JSHandle instances for the property values.
  #
  # **Usage**
  #
  # ```python sync
  # handle = page.evaluate_handle("({ window, document })")
  # properties = handle.get_properties()
  # window_handle = properties.get("window")
  # document_handle = properties.get("document")
  # handle.dispose()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#76
  def get_properties; end

  # Fetches a single property from the referenced object.
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#83
  def get_property(propertyName); end

  # Returns a JSON representation of the object. If the object has a `toJSON` function, it **will not be called**.
  #
  # **NOTE**: The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an error if the
  # object has circular references.
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#92
  def json_value; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#115
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#109
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#103
  def once(event, callback); end

  # The method returns a map with **own property names** as keys and JSHandle instances for the property values.
  #
  # **Usage**
  #
  # ```python sync
  # handle = page.evaluate_handle("({ window, document })")
  # properties = handle.get_properties()
  # window_handle = properties.get("window")
  # document_handle = properties.get("document")
  # handle.dispose()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#76
  def properties; end

  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#97
  def to_s; end

  private

  # source://playwright-ruby-client//lib/playwright_api/js_handle.rb#119
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/javascript/expression.rb#2
module Playwright::JavaScript; end

# source://playwright-ruby-client//lib/playwright/javascript/expression.rb#3
class Playwright::JavaScript::Expression
  # @return [Expression] a new instance of Expression
  #
  # source://playwright-ruby-client//lib/playwright/javascript/expression.rb#4
  def initialize(expression, arg); end

  # source://playwright-ruby-client//lib/playwright/javascript/expression.rb#27
  def eval_on_selector(channel, selector, strict: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/javascript/expression.rb#38
  def eval_on_selector_all(channel, selector); end

  # source://playwright-ruby-client//lib/playwright/javascript/expression.rb#9
  def evaluate(channel); end

  # source://playwright-ruby-client//lib/playwright/javascript/expression.rb#18
  def evaluate_handle(channel); end

  # source://playwright-ruby-client//lib/playwright/javascript/expression.rb#48
  def wait_for_function(channel, polling:, timeout:); end
end

# source://playwright-ruby-client//lib/playwright/javascript/regex.rb#3
class Playwright::JavaScript::Regex
  # @return [Regex] a new instance of Regex
  #
  # source://playwright-ruby-client//lib/playwright/javascript/regex.rb#4
  def initialize(regexp); end

  # Returns the value of attribute flag.
  #
  # source://playwright-ruby-client//lib/playwright/javascript/regex.rb#13
  def flag; end

  # Returns the value of attribute source.
  #
  # source://playwright-ruby-client//lib/playwright/javascript/regex.rb#13
  def source; end

  private

  # source://playwright-ruby-client//lib/playwright/javascript/regex.rb#15
  def flag_for(regexp); end
end

# source://playwright-ruby-client//lib/playwright/javascript/source_url.rb#3
class Playwright::JavaScript::SourceUrl
  # @param source [String]
  # @param path [String]
  # @return [SourceUrl] a new instance of SourceUrl
  #
  # source://playwright-ruby-client//lib/playwright/javascript/source_url.rb#6
  def initialize(source, path); end

  # source://playwright-ruby-client//lib/playwright/javascript/source_url.rb#11
  def to_s; end
end

# source://playwright-ruby-client//lib/playwright/javascript/value_parser.rb#6
class Playwright::JavaScript::ValueParser
  # @return [ValueParser] a new instance of ValueParser
  #
  # source://playwright-ruby-client//lib/playwright/javascript/value_parser.rb#7
  def initialize(hash); end

  # @return [Hash]
  #
  # source://playwright-ruby-client//lib/playwright/javascript/value_parser.rb#13
  def parse; end

  private

  # ref: https://github.com/microsoft/playwright/blob/b45905ae3f1a066a8ecb358035ce745ddd21cf3a/src/protocol/serializers.ts#L42
  # ref: https://github.com/microsoft/playwright-python/blob/25a99d53e00e35365cf5113b9525272628c0e65f/playwright/_impl/_js_handle.py#L140
  #
  # @raise [ArgumentError]
  #
  # source://playwright-ruby-client//lib/playwright/javascript/value_parser.rb#23
  def parse_hash(hash); end
end

# source://playwright-ruby-client//lib/playwright/javascript/value_serializer.rb#6
class Playwright::JavaScript::ValueSerializer
  # @return [ValueSerializer] a new instance of ValueSerializer
  #
  # source://playwright-ruby-client//lib/playwright/javascript/value_serializer.rb#7
  def initialize(ruby_value); end

  # @return [Hash]
  #
  # source://playwright-ruby-client//lib/playwright/javascript/value_serializer.rb#13
  def serialize; end

  private

  # ref: https://github.com/microsoft/playwright/blob/b45905ae3f1a066a8ecb358035ce745ddd21cf3a/src/protocol/serializers.ts#L84
  # ref: https://github.com/microsoft/playwright-python/blob/25a99d53e00e35365cf5113b9525272628c0e65f/playwright/_impl/_js_handle.py#L99
  #
  # source://playwright-ruby-client//lib/playwright/javascript/value_serializer.rb#20
  def serialize_value(value); end
end

# source://playwright-ruby-client//lib/playwright/javascript/visitor_info.rb#3
class Playwright::JavaScript::VisitorInfo
  # @return [VisitorInfo] a new instance of VisitorInfo
  #
  # source://playwright-ruby-client//lib/playwright/javascript/visitor_info.rb#4
  def initialize; end

  # source://playwright-ruby-client//lib/playwright/javascript/visitor_info.rb#14
  def log(object); end

  # returns [Integer|nil]
  #
  # source://playwright-ruby-client//lib/playwright/javascript/visitor_info.rb#10
  def ref(object); end
end

# Keyboard provides an api for managing a virtual keyboard. The high level api is [`method: Keyboard.type`], which takes
# raw characters and generates proper `keydown`, `keypress`/`input`, and `keyup` events on your page.
#
# For finer control, you can use [`method: Keyboard.down`], [`method: Keyboard.up`], and [`method: Keyboard.insertText`]
# to manually fire events as if they were generated from a real keyboard.
#
# An example of holding down `Shift` in order to select and delete some text:
#
# ```python sync
# page.keyboard.type("Hello World!")
# page.keyboard.press("ArrowLeft")
# page.keyboard.down("Shift")
# for i in range(6):
#     page.keyboard.press("ArrowLeft")
# page.keyboard.up("Shift")
# page.keyboard.press("Backspace")
# # result text will end up saying "Hello!"
# ```
#
# An example of pressing uppercase `A`
#
# ```python sync
# page.keyboard.press("Shift+KeyA")
# # or
# page.keyboard.press("Shift+A")
# ```
#
# An example to trigger select-all with the keyboard
#
# ```python sync
# page.keyboard.press("ControlOrMeta+A")
# ```
#
# source://playwright-ruby-client//lib/playwright_api/keyboard.rb#35
class Playwright::Keyboard < ::Playwright::PlaywrightApi
  # Dispatches a `keydown` event.
  #
  # `key` can specify the intended
  # [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) value or a single character to
  # generate the text for. A superset of the `key` values can be found
  # [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:
  #
  # `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
  # `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
  #
  # Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.
  # `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.
  #
  # Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
  #
  # If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different
  # respective texts.
  #
  # If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that
  # modifier active. To release the modifier key, use [`method: Keyboard.up`].
  #
  # After the key is pressed once, subsequent calls to [`method: Keyboard.down`] will have
  # [repeat](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat) set to true. To release the key, use
  # [`method: Keyboard.up`].
  #
  # **NOTE**: Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.
  #
  # source://playwright-ruby-client//lib/playwright_api/keyboard.rb#64
  def down(key); end

  # Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.
  #
  # **Usage**
  #
  # ```python sync
  # page.keyboard.insert_text("嗨")
  # ```
  #
  # **NOTE**: Modifier keys DO NOT effect `keyboard.insertText`. Holding down `Shift` will not type the text in upper case.
  #
  # source://playwright-ruby-client//lib/playwright_api/keyboard.rb#78
  def insert_text(text); end

  # **NOTE**: In most cases, you should use [`method: Locator.press`] instead.
  #
  # `key` can specify the intended
  # [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) value or a single character to
  # generate the text for. A superset of the `key` values can be found
  # [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:
  #
  # `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
  # `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
  #
  # Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.
  # `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.
  #
  # Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
  #
  # If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different
  # respective texts.
  #
  # Shortcuts such as `key: "Control+o"`, `key: "Control++` or `key: "Control+Shift+T"` are supported as well. When specified with the
  # modifier, modifier is pressed and being held while the subsequent key is being pressed.
  #
  # **Usage**
  #
  # ```python sync
  # page = browser.new_page()
  # page.goto("https://keycode.info")
  # page.keyboard.press("a")
  # page.screenshot(path="a.png")
  # page.keyboard.press("ArrowLeft")
  # page.screenshot(path="arrow_left.png")
  # page.keyboard.press("Shift+O")
  # page.screenshot(path="o.png")
  # browser.close()
  # ```
  #
  # Shortcut for [`method: Keyboard.down`] and [`method: Keyboard.up`].
  #
  # source://playwright-ruby-client//lib/playwright_api/keyboard.rb#119
  def press(key, delay: T.unsafe(nil)); end

  # **NOTE**: In most cases, you should use [`method: Locator.fill`] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [`method: Locator.pressSequentially`].
  #
  # Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
  #
  # To press a special key, like `Control` or `ArrowDown`, use [`method: Keyboard.press`].
  #
  # **Usage**
  #
  # ```python sync
  # page.keyboard.type("Hello") # types instantly
  # page.keyboard.type("World", delay=100) # types slower, like a user
  # ```
  #
  # **NOTE**: Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.
  #
  # **NOTE**: For characters that are not on a US keyboard, only an `input` event will be sent.
  #
  # source://playwright-ruby-client//lib/playwright_api/keyboard.rb#140
  def type(text, delay: T.unsafe(nil)); end

  # Dispatches a `keyup` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/keyboard.rb#146
  def up(key); end
end

# source://playwright-ruby-client//lib/playwright/keyboard_impl.rb#0
class Playwright::KeyboardImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/keyboard_impl.rb#3
  def initialize(channel); end

  # source://playwright-ruby-client//lib/playwright/keyboard_impl.rb#7
  def down(key); end

  # source://playwright-ruby-client//lib/playwright/keyboard_impl.rb#16
  def insert_text(text); end

  # source://playwright-ruby-client//lib/playwright/keyboard_impl.rb#28
  def press(key, delay: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/keyboard_impl.rb#20
  def type(text, delay: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/keyboard_impl.rb#12
  def up(key); end
end

# Locators are the central piece of Playwright's auto-waiting and retry-ability. In a nutshell, locators represent
# a way to find element(s) on the page at any moment. A locator can be created with the [`method: Page.locator`] method.
#
# [Learn more about locators](../locators.md).
#
# source://playwright-ruby-client//lib/playwright_api/locator.rb#7
class Playwright::Locator < ::Playwright::PlaywrightApi
  # Returns the matching element's attribute value.
  #
  # **NOTE**: If you need to assert an element's attribute, prefer [`method: LocatorAssertions.toHaveAttribute`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#532
  def [](name, timeout: T.unsafe(nil)); end

  # When the locator points to a list of elements, this returns an array of locators, pointing to their respective elements.
  #
  # **NOTE**: [`method: Locator.all`] does not wait for elements to match the locator, and instead immediately returns whatever is present in the page.
  #
  # When the list of elements changes dynamically, [`method: Locator.all`] will produce unpredictable and flaky results.
  #
  # When the list of elements is stable, but loaded dynamically, wait for the full list to finish loading before calling [`method: Locator.all`].
  #
  # **Usage**
  #
  # ```python sync
  # for li in page.get_by_role('listitem').all():
  #   li.click();
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#24
  def all; end

  # Returns an array of `node.innerText` values for all matching nodes.
  #
  # **NOTE**: If you need to assert text on the page, prefer [`method: LocatorAssertions.toHaveText`] with `useInnerText` option to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # texts = page.get_by_role("link").all_inner_texts()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#38
  def all_inner_texts; end

  # Returns an array of `node.textContent` values for all matching nodes.
  #
  # **NOTE**: If you need to assert text on the page, prefer [`method: LocatorAssertions.toHaveText`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # texts = page.get_by_role("link").all_text_contents()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#52
  def all_text_contents; end

  # Creates a locator that matches both this locator and the argument locator.
  #
  # **Usage**
  #
  # The following example finds a button with a specific title.
  #
  # ```python sync
  # button = page.get_by_role("button").and_(page.getByTitle("Subscribe"))
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#66
  def and(locator); end

  # Captures the aria snapshot of the given element.
  # Read more about [aria snapshots](../aria-snapshots.md) and [`method: LocatorAssertions.toMatchAriaSnapshot`] for the corresponding assertion.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("link").aria_snapshot()
  # ```
  #
  # **Details**
  #
  # This method captures the aria snapshot of the given element. The snapshot is a string that represents the state of the element and its children.
  # The snapshot can be used to assert the state of the element in the test, or to compare it to state in the future.
  #
  # The ARIA snapshot is represented using [YAML](https://yaml.org/spec/1.2.2/) markup language:
  # - The keys of the objects are the roles and optional accessible names of the elements.
  # - The values are either text content or an array of child elements.
  # - Generic static text can be represented with the `text` key.
  #
  # Below is the HTML markup and the respective ARIA snapshot:
  #
  # ```html
  # <ul aria-label="Links">
  #   <li><a href="/">Home</a></li>
  #   <li><a href="/about">About</a></li>
  # <ul>
  # ```
  #
  # ```yml
  # - list "Links":
  #   - listitem:
  #     - link "Home"
  #   - listitem:
  #     - link "About"
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#106
  def aria_snapshot(timeout: T.unsafe(nil)); end

  # Calls [blur](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/blur) on the element.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#112
  def blur(timeout: T.unsafe(nil)); end

  # This method returns the bounding box of the element matching the locator, or `null` if the element is not visible. The bounding box is
  # calculated relative to the main frame viewport - which is usually the same as the browser window.
  #
  # **Details**
  #
  # Scrolling affects the returned bounding box, similarly to
  # [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect). That
  # means `x` and/or `y` may be negative.
  #
  # Elements from child frames return the bounding box relative to the main frame, unlike the
  # [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  #
  # Assuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the following
  # snippet should click the center of the element.
  #
  # **Usage**
  #
  # ```python sync
  # box = page.get_by_role("button").bounding_box()
  # page.mouse.click(box["x"] + box["width"] / 2, box["y"] + box["height"] / 2)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#138
  def bounding_box(timeout: T.unsafe(nil)); end

  # Ensure that checkbox or radio element is checked.
  #
  # **Details**
  #
  # Performs the following steps:
  # 1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already checked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked. If not, this method throws.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("checkbox").check()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#164
  def check(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Set the state of a checkbox or a radio element.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("checkbox").set_checked(True)
  # ```
  #
  # **Details**
  #
  # This method checks or unchecks an element by performing the following steps:
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws.
  # 1. If the element already has the right checked state, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked or unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1127
  def checked=(checked, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is checked. Throws if the element is not a checkbox or radio input.
  #
  # **NOTE**: If you need to assert that checkbox is checked, prefer [`method: LocatorAssertions.toBeChecked`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # checked = page.get_by_role("checkbox").is_checked()
  # ```
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#806
  def checked?(timeout: T.unsafe(nil)); end

  # Clear the input field.
  #
  # **Details**
  #
  # This method waits for [actionability](../actionability.md) checks, focuses the element, clears it and triggers an `input` event after clearing.
  #
  # If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be cleared instead.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("textbox").clear()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#187
  def clear(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Click an element.
  #
  # **Details**
  #
  # This method clicks the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element, or the specified `position`.
  # 1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **Usage**
  #
  # Click a button:
  #
  # ```python sync
  # page.get_by_role("button").click()
  # ```
  #
  # Shift-right-click at a specific position on a canvas:
  #
  # ```python sync
  # page.locator("canvas").click(
  #     button="right", modifiers=["Shift"], position={"x": 23, "y": 32}
  # )
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#222
  def click(button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns a `FrameLocator` object pointing to the same `iframe` as this locator.
  #
  # Useful when you have a `Locator` object obtained somewhere, and later on would like to interact with the content inside the frame.
  #
  # For a reverse operation, use [`method: FrameLocator.owner`].
  #
  # **Usage**
  #
  # ```python sync
  # locator = page.locator("iframe[name=\"embedded\"]")
  # # ...
  # frame_locator = locator.content_frame
  # frame_locator.get_by_role("button").click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#394
  def content_frame; end

  # Returns the number of elements matching the locator.
  #
  # **NOTE**: If you need to assert the number of elements on the page, prefer [`method: LocatorAssertions.toHaveCount`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # count = page.get_by_role("listitem").count()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#245
  def count; end

  # Double-click an element.
  #
  # **Details**
  #
  # This method double clicks the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to double click in the center of the element, or the specified `position`.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: `element.dblclick()` dispatches two `click` events and a single `dblclick` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#265
  def dblclick(button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Describes the locator, description is used in the trace viewer and reports.
  # Returns the locator pointing to the same element.
  #
  # **Usage**
  #
  # ```python sync
  # button = page.get_by_test_id("btn-sub").describe("Subscribe button")
  # button.click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#287
  def describe(description); end

  # Returns whether the element is disabled, the opposite of [enabled](../actionability.md#enabled).
  #
  # **NOTE**: If you need to assert that an element is disabled, prefer [`method: LocatorAssertions.toBeDisabled`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # disabled = page.get_by_role("button").is_disabled()
  # ```
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#820
  def disabled?(timeout: T.unsafe(nil)); end

  # Programmatically dispatch an event on the matching element.
  #
  # **Usage**
  #
  # ```python sync
  # locator.dispatch_event("click")
  # ```
  #
  # **Details**
  #
  # The snippet above dispatches the `click` event on the element. Regardless of the visibility state of the element, `click`
  # is dispatched. This is equivalent to calling
  # [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).
  #
  # Under the hood, it creates an instance of an event based on the given `type`, initializes it with
  # `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by
  # default.
  #
  # Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial
  # properties:
  # - [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
  # - [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
  # - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
  # - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
  # - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
  # - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
  # - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
  # - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
  # - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
  # - [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)
  #
  # You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:
  #
  # ```python sync
  # data_transfer = page.evaluate_handle("new DataTransfer()")
  # locator.dispatch_event("#source", "dragstart", {"dataTransfer": data_transfer})
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#329
  def dispatch_event(type, eventInit: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Drag the source element towards the target element and drop it.
  #
  # **Details**
  #
  # This method drags the locator to another target locator or target position. It will
  # first move to the source element, perform a `mousedown`, then move to the target
  # element or position and perform a `mouseup`.
  #
  # **Usage**
  #
  # ```python sync
  # source = page.locator("#source")
  # target = page.locator("#target")
  #
  # source.drag_to(target)
  # # or specify exact positions relative to the top-left corners of the elements:
  # source.drag_to(
  #   target,
  #   source_position={"x": 34, "y": 7},
  #   target_position={"x": 10, "y": 20}
  # )
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#356
  def drag_to(target, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), sourcePosition: T.unsafe(nil), targetPosition: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is [editable](../actionability.md#editable). If the target element is not an `<input>`, `<textarea>`, `<select>`, `[contenteditable]` and does not have a role allowing `[aria-readonly]`, this method throws an error.
  #
  # **NOTE**: If you need to assert that an element is editable, prefer [`method: LocatorAssertions.toBeEditable`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # editable = page.get_by_role("textbox").is_editable()
  # ```
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#834
  def editable?(timeout: T.unsafe(nil)); end

  # Resolves given locator to the first matching DOM element. If there are no matching elements, waits for one. If multiple elements match the locator, throws.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#369
  def element_handle(timeout: T.unsafe(nil)); end

  # Resolves given locator to all matching DOM elements. If there are no matching elements, returns an empty list.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#375
  def element_handles; end

  # Returns whether the element is [enabled](../actionability.md#enabled).
  #
  # **NOTE**: If you need to assert that an element is enabled, prefer [`method: LocatorAssertions.toBeEnabled`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # enabled = page.get_by_role("button").is_enabled()
  # ```
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#848
  def enabled?(timeout: T.unsafe(nil)); end

  # Execute JavaScript code in the page, taking the matching element as an argument.
  #
  # **Details**
  #
  # Returns the return value of `expression`, called with the matching element as a first argument, and `arg` as a second argument.
  #
  # If `expression` returns a [Promise], this method will wait for the promise to resolve and return its value.
  #
  # If `expression` throws or rejects, this method throws.
  #
  # **Usage**
  #
  # Passing argument to `expression`:
  #
  # ```python sync
  # result = page.get_by_testid("myId").evaluate("(element, [x, y]) => element.textContent + ' ' + x * y", [7, 8])
  # print(result) # prints "myId text 56"
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#417
  def evaluate(expression, arg: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Execute JavaScript code in the page, taking all matching elements as an argument.
  #
  # **Details**
  #
  # Returns the return value of `expression`, called with an array of all matching elements as a first argument, and `arg` as a second argument.
  #
  # If `expression` returns a [Promise], this method will wait for the promise to resolve and return its value.
  #
  # If `expression` throws or rejects, this method throws.
  #
  # **Usage**
  #
  # ```python sync
  # locator = page.locator("div")
  # more_than_ten = locator.evaluate_all("(divs, min) => divs.length > min", 10)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#438
  def evaluate_all(expression, arg: T.unsafe(nil)); end

  # Execute JavaScript code in the page, taking the matching element as an argument, and return a `JSHandle` with the result.
  #
  # **Details**
  #
  # Returns the return value of `expression` as a`JSHandle`, called with the matching element as a first argument, and `arg` as a second argument.
  #
  # The only difference between [`method: Locator.evaluate`] and [`method: Locator.evaluateHandle`] is that [`method: Locator.evaluateHandle`] returns `JSHandle`.
  #
  # If `expression` returns a [Promise], this method will wait for the promise to resolve and return its value.
  #
  # If `expression` throws or rejects, this method throws.
  #
  # See [`method: Page.evaluateHandle`] for more details.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#456
  def evaluate_handle(expression, arg: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1271
  def expect(expression, options, title); end

  # Set a value to the input field.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("textbox").fill("example value")
  # ```
  #
  # **Details**
  #
  # This method waits for [actionability](../actionability.md) checks, focuses the element, fills it and triggers an `input` event after filling. Note that you can pass an empty string to clear the input field.
  #
  # If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be filled instead.
  #
  # To send fine-grained keyboard events, use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#476
  def fill(value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method narrows existing locator according to the options, for example filters by text.
  # It can be chained to filter multiple times.
  #
  # **Usage**
  #
  # ```python sync
  # row_locator = page.locator("tr")
  # # ...
  # row_locator.filter(has_text="text in column 1").filter(
  #     has=page.get_by_role("button", name="column 2 button")
  # ).screenshot()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#493
  def filter(has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil), visible: T.unsafe(nil)); end

  # Returns locator to the first matching element.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#504
  def first; end

  # Calls [focus](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on the matching element.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#510
  def focus(timeout: T.unsafe(nil)); end

  # When working with iframes, you can create a frame locator that will enter the iframe and allow locating elements
  # in that iframe:
  #
  # **Usage**
  #
  # ```python sync
  # locator = page.frame_locator("iframe").get_by_text("Submit")
  # locator.click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#524
  def frame_locator(selector); end

  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1276
  def generate_locator_string; end

  # Returns the matching element's attribute value.
  #
  # **NOTE**: If you need to assert an element's attribute, prefer [`method: LocatorAssertions.toHaveAttribute`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#532
  def get_attribute(name, timeout: T.unsafe(nil)); end

  # Allows locating elements by their alt text.
  #
  # **Usage**
  #
  # For example, this method will find the image by alt text "Playwright logo":
  #
  # ```html
  # <img alt='Playwright logo'>
  # ```
  #
  # ```python sync
  # page.get_by_alt_text("Playwright logo").click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#551
  def get_by_alt_text(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the `aria-label` attribute.
  #
  # **Usage**
  #
  # For example, this method will find inputs by label "Username" and "Password" in the following DOM:
  #
  # ```html
  # <input aria-label="Username">
  # <label for="password-input">Password:</label>
  # <input id="password-input">
  # ```
  #
  # ```python sync
  # page.get_by_label("Username").fill("john")
  # page.get_by_label("Password").fill("secret")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#572
  def get_by_label(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the placeholder text.
  #
  # **Usage**
  #
  # For example, consider the following DOM structure.
  #
  # ```html
  # <input type="email" placeholder="name@example.com" />
  # ```
  #
  # You can fill the input after locating it by the placeholder text:
  #
  # ```python sync
  # page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#592
  def get_by_placeholder(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <h3>Sign up</h3>
  # <label>
  #   <input type="checkbox" /> Subscribe
  # </label>
  # <br/>
  # <button>Submit</button>
  # ```
  #
  # You can locate each element by it's implicit role:
  #
  # ```python sync
  # expect(page.get_by_role("heading", name="Sign up")).to_be_visible()
  #
  # page.get_by_role("checkbox", name="Subscribe").check()
  #
  # page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
  # ```
  #
  # **Details**
  #
  # Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback about the ARIA guidelines.
  #
  # Many html elements have an implicitly [defined role](https://w3c.github.io/html-aam/#html-element-role-mappings) that is recognized by the role selector. You can find all the [supported roles here](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). ARIA guidelines **do not recommend** duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#627
  def get_by_role(role, checked: T.unsafe(nil), disabled: T.unsafe(nil), exact: T.unsafe(nil), expanded: T.unsafe(nil), includeHidden: T.unsafe(nil), level: T.unsafe(nil), name: T.unsafe(nil), pressed: T.unsafe(nil), selected: T.unsafe(nil)); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#661
  def get_by_test_id(testId); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#661
  def get_by_testid(testId); end

  # Allows locating elements that contain given text.
  #
  # See also [`method: Locator.filter`] that allows to match by another criteria, like an accessible role, and then filter by the text content.
  #
  # **Usage**
  #
  # Consider the following DOM structure:
  #
  # ```html
  # <div>Hello <span>world</span></div>
  # <div>Hello</div>
  # ```
  #
  # You can locate by text substring, exact string, or a regular expression:
  #
  # ```python sync
  # # Matches <span>
  # page.get_by_text("world")
  #
  # # Matches first <div>
  # page.get_by_text("Hello world")
  #
  # # Matches second <div>
  # page.get_by_text("Hello", exact=True)
  #
  # # Matches both <div>s
  # page.get_by_text(re.compile("Hello"))
  #
  # # Matches second <div>
  # page.get_by_text(re.compile("^hello$", re.IGNORECASE))
  # ```
  #
  # **Details**
  #
  # Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into one, turns line breaks into spaces and ignores leading and trailing whitespace.
  #
  # Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For example, locating by text `"Log in"` matches `<input type=button value="Log in">`.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#704
  def get_by_text(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their title attribute.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <span title='Issues count'>25 issues</span>
  # ```
  #
  # You can check the issues count after locating it by the title text:
  #
  # ```python sync
  # expect(page.get_by_title("Issues count")).to_have_text("25 issues")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#724
  def get_by_title(text, exact: T.unsafe(nil)); end

  # Returns whether the element is hidden, the opposite of [visible](../actionability.md#visible).
  #
  # **NOTE**: If you need to assert that element is hidden, prefer [`method: LocatorAssertions.toBeHidden`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # hidden = page.get_by_role("button").is_hidden()
  # ```
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#862
  def hidden?(timeout: T.unsafe(nil)); end

  # Highlight the corresponding element(s) on the screen. Useful for debugging, don't commit the code that uses [`method: Locator.highlight`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#730
  def highlight; end

  # Hover over the matching element.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("link").hover()
  # ```
  #
  # **Details**
  #
  # This method hovers over the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to hover over the center of the element, or the specified `position`.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#754
  def hover(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns the [`element.innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML).
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#766
  def inner_html(timeout: T.unsafe(nil)); end

  # Returns the [`element.innerText`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText).
  #
  # **NOTE**: If you need to assert text on the page, prefer [`method: LocatorAssertions.toHaveText`] with `useInnerText` option to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#774
  def inner_text(timeout: T.unsafe(nil)); end

  # Upload file or multiple files into `<input type=file>`.
  # For inputs with a `[webkitdirectory]` attribute, only a single directory path is supported.
  #
  # **Usage**
  #
  # ```python sync
  # # Select one file
  # page.get_by_label("Upload file").set_input_files('myfile.pdf')
  #
  # # Select multiple files
  # page.get_by_label("Upload files").set_input_files(['file1.txt', 'file2.txt'])
  #
  # # Select a directory
  # page.get_by_label("Upload directory").set_input_files('mydir')
  #
  # # Remove all the selected files
  # page.get_by_label("Upload file").set_input_files([])
  #
  # # Upload buffer from memory
  # page.get_by_label("Upload file").set_input_files(
  #     files=[
  #         {"name": "test.txt", "mimeType": "text/plain", "buffer": b"this is a test"}
  #     ],
  # )
  # ```
  #
  # **Details**
  #
  # Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
  # are resolved relative to the current working directory. For empty array, clears the selected files.
  #
  # This method expects `Locator` to point to an
  # [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), targets the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1172
  def input_files=(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns the value for the matching `<input>` or `<textarea>` or `<select>` element.
  #
  # **NOTE**: If you need to assert input value, prefer [`method: LocatorAssertions.toHaveValue`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # value = page.get_by_role("textbox").input_value()
  # ```
  #
  # **Details**
  #
  # Throws elements that are not an input, textarea or a select. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), returns the value of the control.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#792
  def input_value(timeout: T.unsafe(nil)); end

  # Returns locator to the last matching element.
  #
  # **Usage**
  #
  # ```python sync
  # banana = page.get_by_role("listitem").last
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#888
  def last; end

  # The method finds an element matching the specified selector in the locator's subtree. It also accepts filter options, similar to [`method: Locator.filter`] method.
  #
  # [Learn more about locators](../locators.md).
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#896
  def locator(selectorOrLocator, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # Returns locator to the n-th matching element. It's zero based, `nth(0)` selects the first element.
  #
  # **Usage**
  #
  # ```python sync
  # banana = page.get_by_role("listitem").nth(2)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#913
  def nth(index); end

  # Creates a locator matching all elements that match one or both of the two locators.
  #
  # Note that when both locators match something, the resulting locator will have multiple matches, potentially causing a [locator strictness](../locators.md#strictness) violation.
  #
  # **Usage**
  #
  # Consider a scenario where you'd like to click on a "New email" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a "New email" button, or a dialog and act accordingly.
  #
  # **NOTE**: If both "New email" button and security dialog appear on screen, the "or" locator will match both of them,
  # possibly throwing the ["strict mode violation" error](../locators.md#strictness). In this case, you can use [`method: Locator.first`] to only match one of them.
  #
  # ```python sync
  # new_email = page.get_by_role("button", name="New")
  # dialog = page.get_by_text("Confirm security settings")
  # expect(new_email.or_(dialog).first).to_be_visible()
  # if (dialog.is_visible()):
  #   page.get_by_role("button", name="Dismiss").click()
  # new_email.click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#937
  def or(locator); end

  # A page this locator belongs to.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#943
  def page; end

  # Focuses the matching element and presses a combination of the keys.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("textbox").press("Backspace")
  # ```
  #
  # **Details**
  #
  # Focuses the element, and then uses [`method: Keyboard.down`] and [`method: Keyboard.up`].
  #
  # `key` can specify the intended
  # [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) value or a single character to
  # generate the text for. A superset of the `key` values can be found
  # [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:
  #
  # `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
  # `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
  #
  # Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.
  # `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.
  #
  # Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
  #
  # If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different
  # respective texts.
  #
  # Shortcuts such as `key: "Control+o"`, `key: "Control++` or `key: "Control+Shift+T"` are supported as well. When specified with the
  # modifier, modifier is pressed and being held while the subsequent key is being pressed.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#978
  def press(key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # **NOTE**: In most cases, you should use [`method: Locator.fill`] instead. You only need to press keys one by one if there is special keyboard handling on the page.
  #
  # Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
  #
  # To press a special key, like `Control` or `ArrowDown`, use [`method: Locator.press`].
  #
  # **Usage**
  #
  # ```python sync
  # locator.press_sequentially("hello") # types instantly
  # locator.press_sequentially("world", delay=100) # types slower, like a user
  # ```
  #
  # An example of typing into a text field and then submitting the form:
  #
  # ```python sync
  # locator = page.get_by_label("Password")
  # locator.press_sequentially("my password")
  # locator.press("Enter")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1003
  def press_sequentially(text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Take a screenshot of the element matching the locator.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("link").screenshot()
  # ```
  #
  # Disable animations and save screenshot to a file:
  #
  # ```python sync
  # page.get_by_role("link").screenshot(animations="disabled", path="link.png")
  # ```
  #
  # **Details**
  #
  # This method captures a screenshot of the page, clipped to the size and position of a particular element matching the locator. If the element is covered by other elements, it will not be actually visible on the screenshot. If the element is a scrollable container, only the currently scrolled content will be visible on the screenshot.
  #
  # This method waits for the [actionability](../actionability.md) checks, then scrolls element into view before taking a
  # screenshot. If the element is detached from DOM, the method throws an error.
  #
  # Returns the buffer with the captured screenshot.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1030
  def screenshot(animations: T.unsafe(nil), caret: T.unsafe(nil), mask: T.unsafe(nil), maskColor: T.unsafe(nil), omitBackground: T.unsafe(nil), path: T.unsafe(nil), quality: T.unsafe(nil), scale: T.unsafe(nil), style: T.unsafe(nil), timeout: T.unsafe(nil), type: T.unsafe(nil)); end

  # This method waits for [actionability](../actionability.md) checks, then tries to scroll element into view, unless it is
  # completely visible as defined by
  # [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)'s `ratio`.
  #
  # See [scrolling](../input.md#scrolling) for alternative ways to scroll.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1051
  def scroll_into_view_if_needed(timeout: T.unsafe(nil)); end

  # Selects option or options in `<select>`.
  #
  # **Details**
  #
  # This method waits for [actionability](../actionability.md) checks, waits until all specified options are present in the `<select>` element and selects these options.
  #
  # If the target element is not a `<select>` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be used instead.
  #
  # Returns the array of option values that have been successfully selected.
  #
  # Triggers a `change` and `input` event once all the provided options have been selected.
  #
  # **Usage**
  #
  # ```html
  # <select multiple>
  #   <option value="red">Red</option>
  #   <option value="green">Green</option>
  #   <option value="blue">Blue</option>
  # </select>
  # ```
  #
  # ```python sync
  # # single selection matching the value or label
  # element.select_option("blue")
  # # single selection matching the label
  # element.select_option(label="blue")
  # # multiple selection for blue, red and second option
  # element.select_option(value=["red", "green", "blue"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1086
  def select_option(element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method waits for [actionability](../actionability.md) checks, then focuses the element and selects all its text
  # content.
  #
  # If the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), focuses and selects text in the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1102
  def select_text(force: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Set the state of a checkbox or a radio element.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("checkbox").set_checked(True)
  # ```
  #
  # **Details**
  #
  # This method checks or unchecks an element by performing the following steps:
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws.
  # 1. If the element already has the right checked state, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked or unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1127
  def set_checked(checked, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Upload file or multiple files into `<input type=file>`.
  # For inputs with a `[webkitdirectory]` attribute, only a single directory path is supported.
  #
  # **Usage**
  #
  # ```python sync
  # # Select one file
  # page.get_by_label("Upload file").set_input_files('myfile.pdf')
  #
  # # Select multiple files
  # page.get_by_label("Upload files").set_input_files(['file1.txt', 'file2.txt'])
  #
  # # Select a directory
  # page.get_by_label("Upload directory").set_input_files('mydir')
  #
  # # Remove all the selected files
  # page.get_by_label("Upload file").set_input_files([])
  #
  # # Upload buffer from memory
  # page.get_by_label("Upload file").set_input_files(
  #     files=[
  #         {"name": "test.txt", "mimeType": "text/plain", "buffer": b"this is a test"}
  #     ],
  # )
  # ```
  #
  # **Details**
  #
  # Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
  # are resolved relative to the current working directory. For empty array, clears the selected files.
  #
  # This method expects `Locator` to point to an
  # [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), targets the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1172
  def set_input_files(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Perform a tap gesture on the element matching the locator. For examples of emulating other gestures by manually dispatching touch events, see the [emulating legacy touch events](../touch-events.md) page.
  #
  # **Details**
  #
  # This method taps the element by performing the following steps:
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.touchscreen`] to tap the center of the element, or the specified `position`.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: `element.tap()` requires that the `hasTouch` option of the browser context be set to true.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1193
  def tap_point(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns the [`node.textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent).
  #
  # **NOTE**: If you need to assert text on the page, prefer [`method: LocatorAssertions.toHaveText`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1207
  def text_content(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1281
  def to_s; end

  # Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
  #
  # To press a special key, like `Control` or `ArrowDown`, use [`method: Locator.press`].
  #
  # **Usage**
  #
  # @deprecated In most cases, you should use [`method: Locator.fill`] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1219
  def type(text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensure that checkbox or radio element is unchecked.
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("checkbox").uncheck()
  # ```
  #
  # **Details**
  #
  # This method unchecks the element by performing the following steps:
  # 1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already unchecked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the element, unless `force` option is set.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now unchecked. If not, this method throws.
  #
  # If the element is detached from the DOM at any moment during the action, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1245
  def uncheck(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is [visible](../actionability.md#visible).
  #
  # **NOTE**: If you need to assert that element is visible, prefer [`method: LocatorAssertions.toBeVisible`] to avoid flakiness. See [assertions guide](../test-assertions.md) for more details.
  #
  # **Usage**
  #
  # ```python sync
  # visible = page.get_by_role("button").is_visible()
  # ```
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#876
  def visible?(timeout: T.unsafe(nil)); end

  # Returns when element specified by locator satisfies the `state` option.
  #
  # If target element already satisfies the condition, the method returns immediately. Otherwise, waits for up to
  # `timeout` milliseconds until the condition is met.
  #
  # **Usage**
  #
  # ```python sync
  # order_sent = page.locator("#order-sent")
  # order_sent.wait_for()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator.rb#1266
  def wait_for(state: T.unsafe(nil), timeout: T.unsafe(nil)); end
end

# The `LocatorAssertions` class provides assertion methods that can be used to make assertions about the `Locator` state in the tests.
#
# ```python sync
# from playwright.sync_api import Page, expect
#
# def test_status_becomes_submitted(page: Page) -> None:
#     # ..
#     page.get_by_role("button").click()
#     expect(page.locator(".status")).to_have_text("Submitted")
# ```
#
# source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#13
class Playwright::LocatorAssertions < ::Playwright::PlaywrightApi
  # The opposite of [`method: LocatorAssertions.toBeAttached`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#17
  def not_to_be_attached(attached: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeChecked`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#23
  def not_to_be_checked(timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeDisabled`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#29
  def not_to_be_disabled(timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeEditable`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#35
  def not_to_be_editable(editable: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeEmpty`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#41
  def not_to_be_empty(timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeEnabled`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#47
  def not_to_be_enabled(enabled: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeFocused`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#53
  def not_to_be_focused(timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeHidden`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#59
  def not_to_be_hidden(timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeInViewport`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#65
  def not_to_be_in_viewport(ratio: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toBeVisible`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#71
  def not_to_be_visible(timeout: T.unsafe(nil), visible: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toContainClass`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#77
  def not_to_contain_class(expected, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toContainText`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#83
  def not_to_contain_text(expected, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil), useInnerText: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveAccessibleDescription`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#89
  def not_to_have_accessible_description(name, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveAccessibleErrorMessage`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#95
  def not_to_have_accessible_error_message(errorMessage, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveAccessibleName`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#101
  def not_to_have_accessible_name(name, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveAttribute`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#107
  def not_to_have_attribute(name, value, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveClass`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#113
  def not_to_have_class(expected, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveCount`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#119
  def not_to_have_count(count, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveCSS`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#125
  def not_to_have_css(name, value, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveId`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#131
  def not_to_have_id(id, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveJSProperty`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#137
  def not_to_have_js_property(name, value, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveRole`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#143
  def not_to_have_role(role, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveText`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#149
  def not_to_have_text(expected, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil), useInnerText: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveValue`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#155
  def not_to_have_value(value, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toHaveValues`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#161
  def not_to_have_values(values, timeout: T.unsafe(nil)); end

  # The opposite of [`method: LocatorAssertions.toMatchAriaSnapshot`].
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#167
  def not_to_match_aria_snapshot(expected, timeout: T.unsafe(nil)); end

  # Ensures that `Locator` points to an element that is [connected](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) to a Document or a ShadowRoot.
  #
  # **Usage**
  #
  # ```python sync
  # expect(page.get_by_text("Hidden text")).to_be_attached()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#179
  def to_be_attached(attached: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to a checked input.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.get_by_label("Subscribe to newsletter")
  # expect(locator).to_be_checked()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#194
  def to_be_checked(checked: T.unsafe(nil), indeterminate: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to a disabled element. Element is disabled if it has "disabled" attribute
  # or is disabled via ['aria-disabled'](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-disabled).
  # Note that only native control elements such as HTML `button`, `input`, `select`, `textarea`, `option`, `optgroup`
  # can be disabled by setting "disabled" attribute. "disabled" attribute on other elements is ignored
  # by the browser.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator("button.submit")
  # expect(locator).to_be_disabled()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#213
  def to_be_disabled(timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an editable element.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.get_by_role("textbox")
  # expect(locator).to_be_editable()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#228
  def to_be_editable(editable: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an empty editable element or to a DOM node that has no text.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator("div.warning")
  # expect(locator).to_be_empty()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#243
  def to_be_empty(timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an enabled element.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator("button.submit")
  # expect(locator).to_be_enabled()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#258
  def to_be_enabled(enabled: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to a focused DOM node.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.get_by_role("textbox")
  # expect(locator).to_be_focused()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#273
  def to_be_focused(timeout: T.unsafe(nil)); end

  # Ensures that `Locator` either does not resolve to any DOM node, or resolves to a [non-visible](../actionability.md#visible) one.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator('.my-element')
  # expect(locator).to_be_hidden()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#288
  def to_be_hidden(timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element that intersects viewport, according to the [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.get_by_role("button")
  # # Make sure at least some part of element intersects viewport.
  # expect(locator).to_be_in_viewport()
  # # Make sure element is fully outside of viewport.
  # expect(locator).not_to_be_in_viewport()
  # # Make sure that at least half of the element intersects viewport.
  # expect(locator).to_be_in_viewport(ratio=0.5)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#308
  def to_be_in_viewport(ratio: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures that `Locator` points to an attached and [visible](../actionability.md#visible) DOM node.
  #
  # To check that at least one element from the list is visible, use [`method: Locator.first`].
  #
  # **Usage**
  #
  # ```python sync
  # # A specific element is visible.
  # expect(page.get_by_text("Welcome")).to_be_visible()
  #
  # # At least one item in the list is visible.
  # expect(page.get_by_test_id("todo-item").first).to_be_visible()
  #
  # # At least one of the two elements is visible, possibly both.
  # expect(
  #     page.get_by_role("button", name="Sign in")
  #     .or_(page.get_by_role("button", name="Sign up"))
  #     .first
  # ).to_be_visible()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#333
  def to_be_visible(timeout: T.unsafe(nil), visible: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with given CSS classes. All classes from the asserted value, separated by spaces, must be present in the [Element.classList](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) in any order.
  #
  # **Usage**
  #
  # ```html
  # <div class='middle selected row' id='component'></div>
  # ```
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator("#component")
  # expect(locator).to_contain_class("middle selected row")
  # expect(locator).to_contain_class("selected")
  # expect(locator).to_contain_class("row middle")
  # ```
  #
  # When an array is passed, the method asserts that the list of elements located matches the corresponding list of expected class lists. Each element's class attribute is matched against the corresponding class in the array:
  #
  # ```html
  # <div class='list'>
  #   <div class='component inactive'></div>
  #   <div class='component active'></div>
  #   <div class='component inactive'></div>
  # </div>
  # ```
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator(".list > .component")
  # await expect(locator).to_contain_class(["inactive", "active", "inactive"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#371
  def to_contain_class(expected, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element that contains the given text. All nested elements will be considered when computing the text content of the element. You can use regular expressions for the value as well.
  #
  # **Details**
  #
  # When `expected` parameter is a string, Playwright will normalize whitespaces and line breaks both in the actual text and
  # in the expected string before matching. When regular expression is used, the actual text is matched as is.
  #
  # **Usage**
  #
  # ```python sync
  # import re
  # from playwright.sync_api import expect
  #
  # locator = page.locator('.title')
  # expect(locator).to_contain_text("substring")
  # expect(locator).to_contain_text(re.compile(r"\d messages"))
  # ```
  #
  # If you pass an array as an expected value, the expectations are:
  # 1. Locator resolves to a list of elements.
  # 1. Elements from a **subset** of this list contain text from the expected array, respectively.
  # 1. The matching subset of elements has the same order as the expected array.
  # 1. Each text value from the expected array is matched by some element from the list.
  #
  # For example, consider the following list:
  #
  # ```html
  # <ul>
  #   <li>Item Text 1</li>
  #   <li>Item Text 2</li>
  #   <li>Item Text 3</li>
  # </ul>
  # ```
  #
  # Let's see how we can use the assertion:
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # # ✓ Contains the right items in the right order
  # expect(page.locator("ul > li")).to_contain_text(["Text 1", "Text 3", "Text 4"])
  #
  # # ✖ Wrong order
  # expect(page.locator("ul > li")).to_contain_text(["Text 3", "Text 2"])
  #
  # # ✖ No item contains this text
  # expect(page.locator("ul > li")).to_contain_text(["Some 33"])
  #
  # # ✖ Locator points to the outer list element, not to the list items
  # expect(page.locator("ul")).to_contain_text(["Text 3"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#427
  def to_contain_text(expected, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil), useInnerText: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with a given [accessible description](https://w3c.github.io/accname/#dfn-accessible-description).
  #
  # **Usage**
  #
  # ```python sync
  # locator = page.get_by_test_id("save-button")
  # expect(locator).to_have_accessible_description("Save results to disk")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#440
  def to_have_accessible_description(description, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with a given [aria errormessage](https://w3c.github.io/aria/#aria-errormessage).
  #
  # **Usage**
  #
  # ```python sync
  # locator = page.get_by_test_id("username-input")
  # expect(locator).to_have_accessible_error_message("Username is required.")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#453
  def to_have_accessible_error_message(errorMessage, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with a given [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
  #
  # **Usage**
  #
  # ```python sync
  # locator = page.get_by_test_id("save-button")
  # expect(locator).to_have_accessible_name("Save to disk")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#466
  def to_have_accessible_name(name, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with given attribute.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator("input")
  # expect(locator).to_have_attribute("type", "text")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#481
  def to_have_attribute(name, value, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with given CSS classes. When a string is provided, it must fully match the element's `class` attribute. To match individual classes use [`method: LocatorAssertions.toContainClass`].
  #
  # **Usage**
  #
  # ```html
  # <div class='middle selected row' id='component'></div>
  # ```
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator("#component")
  # expect(locator).to_have_class("middle selected row")
  # expect(locator).to_have_class(re.compile(r"(^|\\s)selected(\\s|$)"))
  # ```
  #
  # When an array is passed, the method asserts that the list of elements located matches the corresponding list of expected class values. Each element's class attribute is matched against the corresponding string or regular expression in the array:
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator(".list > .component")
  # expect(locator).to_have_class(["component", "component selected", "component"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#510
  def to_have_class(expected, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` resolves to an exact number of DOM nodes.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator("list > .component")
  # expect(locator).to_have_count(3)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#525
  def to_have_count(count, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` resolves to an element with the given computed CSS style.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.get_by_role("button")
  # expect(locator).to_have_css("display", "flex")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#540
  def to_have_css(name, value, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with the given DOM Node ID.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.get_by_role("textbox")
  # expect(locator).to_have_id("lastname")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#555
  def to_have_id(id, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with given JavaScript property. Note that this property can be
  # of a primitive type as well as a plain serializable JavaScript object.
  #
  # **Usage**
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # locator = page.locator(".component")
  # expect(locator).to_have_js_property("loaded", True)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#571
  def to_have_js_property(name, value, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with a given [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles).
  #
  # Note that role is matched as a string, disregarding the ARIA role hierarchy. For example, asserting  a superclass role `"checkbox"` on an element with a subclass role `"switch"` will fail.
  #
  # **Usage**
  #
  # ```python sync
  # locator = page.get_by_test_id("save-button")
  # expect(locator).to_have_role("button")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#586
  def to_have_role(role, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with the given text. All nested elements will be considered when computing the text content of the element. You can use regular expressions for the value as well.
  #
  # **Details**
  #
  # When `expected` parameter is a string, Playwright will normalize whitespaces and line breaks both in the actual text and
  # in the expected string before matching. When regular expression is used, the actual text is matched as is.
  #
  # **Usage**
  #
  # ```python sync
  # import re
  # from playwright.sync_api import expect
  #
  # locator = page.locator(".title")
  # expect(locator).to_have_text(re.compile(r"Welcome, Test User"))
  # expect(locator).to_have_text(re.compile(r"Welcome, .*"))
  # ```
  #
  # If you pass an array as an expected value, the expectations are:
  # 1. Locator resolves to a list of elements.
  # 1. The number of elements equals the number of expected values in the array.
  # 1. Elements from the list have text matching expected array values, one by one, in order.
  #
  # For example, consider the following list:
  #
  # ```html
  # <ul>
  #   <li>Text 1</li>
  #   <li>Text 2</li>
  #   <li>Text 3</li>
  # </ul>
  # ```
  #
  # Let's see how we can use the assertion:
  #
  # ```python sync
  # from playwright.sync_api import expect
  #
  # # ✓ Has the right items in the right order
  # expect(page.locator("ul > li")).to_have_text(["Text 1", "Text 2", "Text 3"])
  #
  # # ✖ Wrong order
  # expect(page.locator("ul > li")).to_have_text(["Text 3", "Text 2", "Text 1"])
  #
  # # ✖ Last item does not match
  # expect(page.locator("ul > li")).to_have_text(["Text 1", "Text 2", "Text"])
  #
  # # ✖ Locator points to the outer list element, not to the list items
  # expect(page.locator("ul")).to_have_text(["Text 1", "Text 2", "Text 3"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#641
  def to_have_text(expected, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil), useInnerText: T.unsafe(nil)); end

  # Ensures the `Locator` points to an element with the given input value. You can use regular expressions for the value as well.
  #
  # **Usage**
  #
  # ```python sync
  # import re
  # from playwright.sync_api import expect
  #
  # locator = page.locator("input[type=number]")
  # expect(locator).to_have_value(re.compile(r"[0-9]"))
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#657
  def to_have_value(value, timeout: T.unsafe(nil)); end

  # Ensures the `Locator` points to multi-select/combobox (i.e. a `select` with the `multiple` attribute) and the specified values are selected.
  #
  # **Usage**
  #
  # For example, given the following element:
  #
  # ```html
  # <select id="favorite-colors" multiple>
  #   <option value="R">Red</option>
  #   <option value="G">Green</option>
  #   <option value="B">Blue</option>
  # </select>
  # ```
  #
  # ```python sync
  # import re
  # from playwright.sync_api import expect
  #
  # locator = page.locator("id=favorite-colors")
  # locator.select_option(["R", "G"])
  # expect(locator).to_have_values([re.compile(r"R"), re.compile(r"G")])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#684
  def to_have_values(values, timeout: T.unsafe(nil)); end

  # Asserts that the target element matches the given [accessibility snapshot](../aria-snapshots.md).
  #
  # **Usage**
  #
  # ```python sync
  # page.goto("https://demo.playwright.dev/todomvc/")
  # expect(page.locator('body')).to_match_aria_snapshot('''
  #   - heading "todos"
  #   - textbox "What needs to be done?"
  # ''')
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/locator_assertions.rb#700
  def to_match_aria_snapshot(expected, timeout: T.unsafe(nil)); end
end

# source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#0
class Playwright::LocatorAssertionsImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#14
  def initialize(locator, default_expect_timeout, is_not, message); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_attached(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_checked(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_disabled(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_editable(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_empty(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_enabled(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_focused(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_hidden(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_in_viewport(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_be_visible(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_contain_class(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_contain_text(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_accessible_description(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_accessible_error_message(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_accessible_name(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_attribute(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_class(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_count(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_css(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_id(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_js_property(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_role(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_text(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_value(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_have_values(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#5
  def not_to_match_aria_snapshot(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#444
  def to_be_attached(attached: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#455
  def to_be_checked(checked: T.unsafe(nil), indeterminate: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#479
  def to_be_disabled(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#490
  def to_be_editable(editable: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#501
  def to_be_empty(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#512
  def to_be_enabled(enabled: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#545
  def to_be_focused(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#523
  def to_be_hidden(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#556
  def to_be_in_viewport(ratio: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#534
  def to_be_visible(timeout: T.unsafe(nil), visible: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#243
  def to_contain_class(expected, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#108
  def to_contain_text(expected, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil), useInnerText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#168
  def to_have_accessible_description(name, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#183
  def to_have_accessible_error_message(errorMessage, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#153
  def to_have_accessible_name(name, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#198
  def to_have_attribute(name, value, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#214
  def to_have_class(expected, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#278
  def to_have_count(count, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#292
  def to_have_css(name, value, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#308
  def to_have_id(id, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#323
  def to_have_js_property(name, value, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#338
  def to_have_role(role, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#389
  def to_have_text(expected, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil), useInnerText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#357
  def to_have_value(value, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#373
  def to_have_values(values, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#430
  def to_match_aria_snapshot(expected, timeout: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#59
  def _not; end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#21
  def expect_impl(expression, expect_options, expected, message, title); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#68
  def expected_regex(pattern, match_substring, normalize_white_space, ignore_case); end

  # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#82
  def to_expected_text_values(items, match_substring: T.unsafe(nil), normalize_white_space: T.unsafe(nil), ignore_case: T.unsafe(nil)); end

  class << self
    # source://playwright-ruby-client//lib/playwright/locator_assertions_impl.rb#4
    def _define_negation(method_name); end
  end
end

# source://playwright-ruby-client//lib/playwright/locator_impl.rb#0
class Playwright::LocatorImpl
  include ::Playwright::ApiImplementation
  include ::Playwright::LocatorUtils

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#8
  def initialize(frame:, selector:, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil), visible: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#325
  def all; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#508
  def all_inner_texts; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#512
  def all_text_contents; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#292
  def and(locator); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#409
  def aria_snapshot(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#316
  def blur(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#98
  def bounding_box(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#104
  def check(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#371
  def checked?(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#211
  def clear(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#120
  def click(button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#245
  def content_frame; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#329
  def count; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#144
  def dblclick(button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#252
  def describe(description); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#371
  def disabled?(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#166
  def dispatch_event(type, eventInit: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#170
  def drag_to(target, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), sourcePosition: T.unsafe(nil), targetPosition: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#371
  def editable?(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#237
  def element_handle(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#241
  def element_handles; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#371
  def enabled?(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#191
  def evaluate(expression, arg: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#197
  def evaluate_all(expression, arg: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#201
  def evaluate_handle(expression, arg: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#520
  def expect(expression, options, title); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#207
  def fill(value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#259
  def filter(has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil), visible: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#271
  def first; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#312
  def focus(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#230
  def frame_locator(selector); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#337
  def generate_locator_string; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#333
  def get_attribute(name, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#371
  def hidden?(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#516
  def highlight; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#341
  def hover(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#358
  def inner_html(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#362
  def inner_text(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#366
  def input_value(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#278
  def last; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#215
  def locator(selector, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#285
  def nth(index); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#302
  def or(locator); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#94
  def page; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#376
  def press(key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#477
  def press_sequentially(text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#380
  def screenshot(animations: T.unsafe(nil), caret: T.unsafe(nil), mask: T.unsafe(nil), maskColor: T.unsafe(nil), omitBackground: T.unsafe(nil), path: T.unsafe(nil), quality: T.unsafe(nil), scale: T.unsafe(nil), style: T.unsafe(nil), timeout: T.unsafe(nil), type: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#416
  def scroll_into_view_if_needed(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#422
  def select_option(element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#442
  def select_text(force: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#500
  def set_checked(checked, **options); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#448
  def set_input_files(files, noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#452
  def tap_point(force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#469
  def text_content(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#41
  def to_s; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#473
  def type(text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#481
  def uncheck(force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#371
  def visible?(timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#496
  def wait_for(state: T.unsafe(nil), timeout: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#70
  def _timeout(timeout); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#62
  def same_frame?(other); end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#66
  def selector_json; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#49
  def to_protocol; end

  # source://playwright-ruby-client//lib/playwright/locator_impl.rb#74
  def with_element(timeout: T.unsafe(nil), &block); end
end

# source://playwright-ruby-client//lib/playwright/locator_utils.rb#4
module Playwright::LocatorUtils
  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#10
  def get_by_alt_text(text, exact: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#14
  def get_by_label(text, exact: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#18
  def get_by_placeholder(text, exact: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#30
  def get_by_role(role, **options); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#5
  def get_by_test_id(test_id); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#22
  def get_by_text(text, exact: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#26
  def get_by_title(text, exact: T.unsafe(nil)); end

  private

  # @param text [String]
  #
  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#123
  def escape_for_attribute_selector(text, exact); end

  # @param text [Regexp|String]
  #
  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#113
  def escape_for_attribute_selector_or_regex(text, exact); end

  # @param text [String]
  #
  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#94
  def escape_for_regex(text); end

  # @param text [Regexp|String]
  #
  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#99
  def escape_for_text_selector(text, exact); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#49
  def get_by_alt_text_selector(text, exact:); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#37
  def get_by_attribute_text_selector(attr_name, text, exact: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#45
  def get_by_label_selector(text, exact:); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#57
  def get_by_placeholder_selector(text, exact:); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#65
  def get_by_role_selector(role, **options); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#41
  def get_by_test_id_selector(test_id_attribute_name, test_id); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#61
  def get_by_text_selector(text, exact:); end

  # source://playwright-ruby-client//lib/playwright/locator_utils.rb#53
  def get_by_title_selector(text, exact:); end
end

# The Mouse class operates in main-frame CSS pixels relative to the top-left corner of the viewport.
#
# **NOTE**: If you want to debug where the mouse moved, you can use the [Trace viewer](../trace-viewer-intro.md) or [Playwright Inspector](../running-tests.md). A red dot showing the location of the mouse will be shown for every mouse action.
#
# Every `page` object has its own Mouse, accessible with [`property: Page.mouse`].
#
# ```python sync
# # using ‘page.mouse’ to trace a 100x100 square.
# page.mouse.move(0, 0)
# page.mouse.down()
# page.mouse.move(0, 100)
# page.mouse.move(100, 100)
# page.mouse.move(100, 0)
# page.mouse.move(0, 0)
# page.mouse.up()
# ```
#
# source://playwright-ruby-client//lib/playwright_api/mouse.rb#19
class Playwright::Mouse < ::Playwright::PlaywrightApi
  # Shortcut for [`method: Mouse.move`], [`method: Mouse.down`], [`method: Mouse.up`].
  #
  # source://playwright-ruby-client//lib/playwright_api/mouse.rb#23
  def click(x, y, button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil)); end

  # Shortcut for [`method: Mouse.move`], [`method: Mouse.down`], [`method: Mouse.up`], [`method: Mouse.down`] and
  # [`method: Mouse.up`].
  #
  # source://playwright-ruby-client//lib/playwright_api/mouse.rb#35
  def dblclick(x, y, button: T.unsafe(nil), delay: T.unsafe(nil)); end

  # Dispatches a `mousedown` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/mouse.rb#41
  def down(button: T.unsafe(nil), clickCount: T.unsafe(nil)); end

  # Dispatches a `mousemove` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/mouse.rb#47
  def move(x, y, steps: T.unsafe(nil)); end

  # Dispatches a `mouseup` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/mouse.rb#53
  def up(button: T.unsafe(nil), clickCount: T.unsafe(nil)); end

  # Dispatches a `wheel` event. This method is usually used to manually scroll the page. See [scrolling](../input.md#scrolling) for alternative ways to scroll.
  #
  # **NOTE**: Wheel events may cause scrolling if they are not handled, and this method does not
  # wait for the scrolling to finish before returning.
  #
  # source://playwright-ruby-client//lib/playwright_api/mouse.rb#62
  def wheel(deltaX, deltaY); end
end

# source://playwright-ruby-client//lib/playwright/mouse_impl.rb#0
class Playwright::MouseImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/mouse_impl.rb#3
  def initialize(channel); end

  # source://playwright-ruby-client//lib/playwright/mouse_impl.rb#25
  def click(x, y, button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/mouse_impl.rb#44
  def dblclick(x, y, button: T.unsafe(nil), delay: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/mouse_impl.rb#13
  def down(button: T.unsafe(nil), clickCount: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/mouse_impl.rb#7
  def move(x, y, steps: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/mouse_impl.rb#19
  def up(button: T.unsafe(nil), clickCount: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/mouse_impl.rb#48
  def wheel(deltaX, deltaY); end
end

# Page provides methods to interact with a single tab in a `Browser`, or an
# [extension background page](https://developer.chrome.com/extensions/background_pages) in Chromium. One `Browser`
# instance might have multiple `Page` instances.
#
# This example creates a page, navigates it to a URL, and then saves a screenshot:
#
# ```python sync
# from playwright.sync_api import sync_playwright, Playwright
#
# def run(playwright: Playwright):
#     webkit = playwright.webkit
#     browser = webkit.launch()
#     context = browser.new_context()
#     page = context.new_page()
#     page.goto("https://example.com")
#     page.screenshot(path="screenshot.png")
#     browser.close()
#
# with sync_playwright() as playwright:
#     run(playwright)
# ```
#
# The Page class emits various events (described below) which can be handled using any of Node's native
# [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) methods, such as `on`, `once` or
# `removeListener`.
#
# This example logs a message for a single page `load` event:
#
# ```py
# page.once("load", lambda: print("page loaded!"))
# ```
#
# To unsubscribe from events use the `removeListener` method:
#
# ```py
# def log_request(intercepted_request):
#     print("a request was made:", intercepted_request.url)
# page.on("request", log_request)
# # sometime later...
# page.remove_listener("request", log_request)
# ```
#
# source://playwright-ruby-client//lib/playwright_api/page.rb#44
class Playwright::Page < ::Playwright::PlaywrightApi
  # property
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#52
  def accessibility; end

  # Adds a script which would be evaluated in one of the following scenarios:
  # - Whenever the page is navigated.
  # - Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly attached frame.
  #
  # The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
  # the JavaScript environment, e.g. to seed `Math.random`.
  #
  # **Usage**
  #
  # An example of overriding `Math.random` before the page loads:
  #
  # ```python sync
  # # in your playwright script, assuming the preload.js file is in same directory
  # page.add_init_script(path="./preload.js")
  # ```
  #
  # **NOTE**: The order of evaluation of multiple scripts installed via [`method: BrowserContext.addInitScript`] and
  # [`method: Page.addInitScript`] is not defined.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#94
  def add_init_script(path: T.unsafe(nil), script: T.unsafe(nil)); end

  # When testing a web page, sometimes unexpected overlays like a "Sign up" dialog appear and block actions you want to automate, e.g. clicking a button. These overlays don't always show up in the same way or at the same time, making them tricky to handle in automated tests.
  #
  # This method lets you set up a special function, called a handler, that activates when it detects that overlay is visible. The handler's job is to remove the overlay, allowing your test to continue as if the overlay wasn't there.
  #
  # Things to keep in mind:
  # - When an overlay is shown predictably, we recommend explicitly waiting for it in your test and dismissing it as a part of your normal test flow, instead of using [`method: Page.addLocatorHandler`].
  # - Playwright checks for the overlay every time before executing or retrying an action that requires an [actionability check](../actionability.md), or before performing an auto-waiting assertion check. When overlay is visible, Playwright calls the handler first, and then proceeds with the action/assertion. Note that the handler is only called when you perform an action/assertion - if the overlay becomes visible but you don't perform any actions, the handler will not be triggered.
  # - After executing the handler, Playwright will ensure that overlay that triggered the handler is not visible anymore. You can opt-out of this behavior with `noWaitAfter`.
  # - The execution time of the handler counts towards the timeout of the action/assertion that executed the handler. If your handler takes too long, it might cause timeouts.
  # - You can register multiple handlers. However, only a single handler will be running at a time. Make sure the actions within a handler don't depend on another handler.
  #
  # **NOTE**: Running the handler will alter your page state mid-test. For example it will change the currently focused element and move the mouse. Make sure that actions that run after the handler are self-contained and do not rely on the focus and mouse state being unchanged.
  #
  # For example, consider a test that calls [`method: Locator.focus`] followed by [`method: Keyboard.press`]. If your handler clicks a button between these two actions, the focused element most likely will be wrong, and key press will happen on the unexpected element. Use [`method: Locator.press`] instead to avoid this problem.
  #
  # Another example is a series of mouse actions, where [`method: Mouse.move`] is followed by [`method: Mouse.down`]. Again, when the handler runs between these two actions, the mouse position will be wrong during the mouse down. Prefer self-contained actions like [`method: Locator.click`] that do not rely on the state being unchanged by a handler.
  #
  # **Usage**
  #
  # An example that closes a "Sign up to the newsletter" dialog when it appears:
  #
  # ```python sync
  # # Setup the handler.
  # def handler():
  #   page.get_by_role("button", name="No thanks").click()
  # page.add_locator_handler(page.get_by_text("Sign up to the newsletter"), handler)
  #
  # # Write the test as usual.
  # page.goto("https://example.com")
  # page.get_by_role("button", name="Start here").click()
  # ```
  #
  # An example that skips the "Confirm your security details" page when it is shown:
  #
  # ```python sync
  # # Setup the handler.
  # def handler():
  #   page.get_by_role("button", name="Remind me later").click()
  # page.add_locator_handler(page.get_by_text("Confirm your security details"), handler)
  #
  # # Write the test as usual.
  # page.goto("https://example.com")
  # page.get_by_role("button", name="Start here").click()
  # ```
  #
  # An example with a custom callback on every actionability check. It uses a `<body>` locator that is always visible, so the handler is called before every actionability check. It is important to specify `noWaitAfter`, because the handler does not hide the `<body>` element.
  #
  # ```python sync
  # # Setup the handler.
  # def handler():
  #   page.evaluate("window.removeObstructionsForTestIfNeeded()")
  # page.add_locator_handler(page.locator("body"), handler, no_wait_after=True)
  #
  # # Write the test as usual.
  # page.goto("https://example.com")
  # page.get_by_role("button", name="Start here").click()
  # ```
  #
  # Handler takes the original locator as an argument. You can also automatically remove the handler after a number of invocations by setting `times`:
  #
  # ```python sync
  # def handler(locator):
  #   locator.click()
  # page.add_locator_handler(page.get_by_label("Close"), handler, times=1)
  # ```
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1154
  def add_locator_handler(locator, handler, noWaitAfter: T.unsafe(nil), times: T.unsafe(nil)); end

  # Adds a `<script>` tag into the page with the desired url or content. Returns the added tag when the script's onload
  # fires or when the script content was injected into frame.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#101
  def add_script_tag(content: T.unsafe(nil), path: T.unsafe(nil), type: T.unsafe(nil), url: T.unsafe(nil)); end

  # Adds a `<link rel="stylesheet">` tag into the page with the desired url or a `<style type="text/css">` tag with the
  # content. Returns the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#108
  def add_style_tag(content: T.unsafe(nil), path: T.unsafe(nil), url: T.unsafe(nil)); end

  # Brings page to front (activates tab).
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#114
  def bring_to_front; end

  # This method checks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is already checked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#129
  def check(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is checked. Throws if the element is not a checkbox or radio input.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#885
  def checked?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method clicks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element, or the specified `position`.
  # 1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#150
  def click(selector, button: T.unsafe(nil), clickCount: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Playwright has ability to mock clock and passage of time.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#48
  def clock; end

  # If `runBeforeUnload` is `false`, does not run any unload handlers and waits for the page to be closed. If
  # `runBeforeUnload` is `true` the method will run unload handlers, but will **not** wait for the page to close.
  #
  # By default, `page.close()` **does not** run `beforeunload` handlers.
  #
  # **NOTE**: if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned and should be handled
  # manually via [`event: Page.dialog`] event.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#173
  def close(reason: T.unsafe(nil), runBeforeUnload: T.unsafe(nil)); end

  # Indicates that the page has been closed.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#891
  def closed?; end

  # Gets the full HTML contents of the page, including the doctype.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#179
  def content; end

  # This method internally calls [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), inheriting all its specific characteristics and behaviors.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1338
  def content=(html, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # Get the browser context that the page belongs to.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#185
  def context; end

  # This method double clicks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to double click in the center of the element, or the specified `position`.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: `page.dblclick()` dispatches two `click` events and a single `dblclick` event.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#200
  def dblclick(selector, button: T.unsafe(nil), delay: T.unsafe(nil), force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # This setting will change the default maximum navigation time for the following methods and related shortcuts:
  # - [`method: Page.goBack`]
  # - [`method: Page.goForward`]
  # - [`method: Page.goto`]
  # - [`method: Page.reload`]
  # - [`method: Page.setContent`]
  # - [`method: Page.waitForNavigation`]
  # - [`method: Page.waitForURL`]
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`] takes priority over [`method: Page.setDefaultTimeout`],
  # [`method: BrowserContext.setDefaultTimeout`] and [`method: BrowserContext.setDefaultNavigationTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1355
  def default_navigation_timeout=(timeout); end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`] takes priority over [`method: Page.setDefaultTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1364
  def default_timeout=(timeout); end

  # Returns whether the element is disabled, the opposite of [enabled](../actionability.md#enabled).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#897
  def disabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the element, `click`
  # is dispatched. This is equivalent to calling
  # [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).
  #
  # **Usage**
  #
  # ```python sync
  # page.dispatch_event("button#submit", "click")
  # ```
  #
  # Under the hood, it creates an instance of an event based on the given `type`, initializes it with
  # `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by
  # default.
  #
  # Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial
  # properties:
  # - [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
  # - [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
  # - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
  # - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
  # - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
  # - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
  # - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
  # - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
  # - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
  # - [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)
  #
  # You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:
  #
  # ```python sync
  # # note you can only create data_transfer in chromium and firefox
  # data_transfer = page.evaluate_handle("new DataTransfer()")
  # page.dispatch_event("#source", "dragstart", { "dataTransfer": data_transfer })
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#249
  def dispatch_event(selector, type, eventInit: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method drags the source element to the target element.
  # It will first move to the source element, perform a `mousedown`,
  # then move to the target element and perform a `mouseup`.
  #
  # **Usage**
  #
  # ```python sync
  # page.drag_and_drop("#source", "#target")
  # # or specify exact positions relative to the top-left corners of the elements:
  # page.drag_and_drop(
  #   "#source",
  #   "#target",
  #   source_position={"x": 34, "y": 7},
  #   target_position={"x": 10, "y": 20}
  # )
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#275
  def drag_and_drop(source, target, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), sourcePosition: T.unsafe(nil), strict: T.unsafe(nil), targetPosition: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns whether the element is [editable](../actionability.md#editable).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#903
  def editable?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method changes the `CSS media type` through the `media` argument, and/or the `'prefers-colors-scheme'` media feature, using the `colorScheme` argument.
  #
  # **Usage**
  #
  # ```python sync
  # page.evaluate("matchMedia('screen').matches")
  # # → True
  # page.evaluate("matchMedia('print').matches")
  # # → False
  #
  # page.emulate_media(media="print")
  # page.evaluate("matchMedia('screen').matches")
  # # → False
  # page.evaluate("matchMedia('print').matches")
  # # → True
  #
  # page.emulate_media()
  # page.evaluate("matchMedia('screen').matches")
  # # → True
  # page.evaluate("matchMedia('print').matches")
  # # → False
  # ```
  #
  # ```python sync
  # page.emulate_media(color_scheme="dark")
  # page.evaluate("matchMedia('(prefers-color-scheme: dark)').matches")
  # # → True
  # page.evaluate("matchMedia('(prefers-color-scheme: light)').matches")
  # # → False
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#319
  def emulate_media(colorScheme: T.unsafe(nil), contrast: T.unsafe(nil), forcedColors: T.unsafe(nil), media: T.unsafe(nil), reducedMotion: T.unsafe(nil)); end

  # Returns whether the element is [enabled](../actionability.md#enabled).
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#909
  def enabled?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The method finds an element matching the specified selector within the page and passes it as a first argument to
  # `expression`. If no elements match the selector, the method throws an error. Returns the value of
  # `expression`.
  #
  # If `expression` returns a [Promise], then [`method: Page.evalOnSelector`] would wait for the promise to resolve and
  # return its value.
  #
  # **Usage**
  #
  # ```python sync
  # search_value = page.eval_on_selector("#search", "el => el.value")
  # preload_href = page.eval_on_selector("link[rel=preload]", "el => el.href")
  # html = page.eval_on_selector(".main-container", "(e, suffix) => e.outer_html + suffix", "hello")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#343
  def eval_on_selector(selector, expression, arg: T.unsafe(nil), strict: T.unsafe(nil)); end

  # The method finds all elements matching the specified selector within the page and passes an array of matched elements as
  # a first argument to `expression`. Returns the result of `expression` invocation.
  #
  # If `expression` returns a [Promise], then [`method: Page.evalOnSelectorAll`] would wait for the promise to resolve and
  # return its value.
  #
  # **Usage**
  #
  # ```python sync
  # div_counts = page.eval_on_selector_all("div", "(divs, min) => divs.length >= min", 10)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#359
  def eval_on_selector_all(selector, expression, arg: T.unsafe(nil)); end

  # Returns the value of the `expression` invocation.
  #
  # If the function passed to the [`method: Page.evaluate`] returns a [Promise], then [`method: Page.evaluate`] would wait
  # for the promise to resolve and return its value.
  #
  # If the function passed to the [`method: Page.evaluate`] returns a non-[Serializable] value, then
  # [`method: Page.evaluate`] resolves to `undefined`. Playwright also supports transferring some
  # additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.
  #
  # **Usage**
  #
  # Passing argument to `expression`:
  #
  # ```python sync
  # result = page.evaluate("([x, y]) => Promise.resolve(x * y)", [7, 8])
  # print(result) # prints "56"
  # ```
  #
  # A string can also be passed in instead of a function:
  #
  # ```python sync
  # print(page.evaluate("1 + 2")) # prints "3"
  # x = 10
  # print(page.evaluate(f"1 + {x}")) # prints "11"
  # ```
  #
  # `ElementHandle` instances can be passed as an argument to the [`method: Page.evaluate`]:
  #
  # ```python sync
  # body_handle = page.evaluate("document.body")
  # html = page.evaluate("([body, suffix]) => body.innerHTML + suffix", [body_handle, "hello"])
  # body_handle.dispose()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#397
  def evaluate(expression, arg: T.unsafe(nil)); end

  # Returns the value of the `expression` invocation as a `JSHandle`.
  #
  # The only difference between [`method: Page.evaluate`] and [`method: Page.evaluateHandle`] is that [`method: Page.evaluateHandle`] returns `JSHandle`.
  #
  # If the function passed to the [`method: Page.evaluateHandle`] returns a [Promise], then [`method: Page.evaluateHandle`] would wait for the
  # promise to resolve and return its value.
  #
  # **Usage**
  #
  # ```python sync
  # a_window_handle = page.evaluate_handle("Promise.resolve(window)")
  # a_window_handle # handle for the window object.
  # ```
  #
  # A string can also be passed in instead of a function:
  #
  # ```python sync
  # a_handle = page.evaluate_handle("document") # handle for the "document"
  # ```
  #
  # `JSHandle` instances can be passed as an argument to the [`method: Page.evaluateHandle`]:
  #
  # ```python sync
  # a_handle = page.evaluate_handle("document.body")
  # result_handle = page.evaluate_handle("body => body.innerHTML", a_handle)
  # print(result_handle.json_value())
  # result_handle.dispose()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#430
  def evaluate_handle(expression, arg: T.unsafe(nil)); end

  # Performs action and waits for a `ConsoleMessage` to be logged by in the page. If predicate is provided, it passes
  # `ConsoleMessage` value into the `predicate` function and waits for `predicate(message)` to return a truthy value.
  # Will throw an error if the page is closed before the [`event: Page.console`] event is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1520
  def expect_console_message(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Performs action and waits for a new `Download`. If predicate is provided, it passes
  # `Download` value into the `predicate` function and waits for `predicate(download)` to return a truthy value.
  # Will throw an error if the page is closed before the download event is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1528
  def expect_download(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
  # value. Will throw an error if the page is closed before the event is fired. Returns the event data value.
  #
  # **Usage**
  #
  # ```python sync
  # with page.expect_event("framenavigated") as event_info:
  #     page.get_by_role("button")
  # frame = event_info.value
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1543
  def expect_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Performs action and waits for a new `FileChooser` to be created. If predicate is provided, it passes
  # `FileChooser` value into the `predicate` function and waits for `predicate(fileChooser)` to return a truthy value.
  # Will throw an error if the page is closed before the file chooser is opened.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1551
  def expect_file_chooser(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Waits for the main frame navigation and returns the main resource response. In case of multiple redirects, the navigation
  # will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to
  # History API usage, the navigation will resolve with `null`.
  #
  # **Usage**
  #
  # This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
  # cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`.
  # Consider this example:
  #
  # ```python sync
  # with page.expect_navigation():
  #     # This action triggers the navigation after a timeout.
  #     page.get_by_text("Navigate after timeout").click()
  # # Resolves after navigation has finished
  # ```
  #
  # **NOTE**: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is considered
  # a navigation.
  #
  # @deprecated This method is inherently racy, please use [`method: Page.waitForURL`] instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1636
  def expect_navigation(timeout: T.unsafe(nil), url: T.unsafe(nil), waitUntil: T.unsafe(nil), &block); end

  # Performs action and waits for a popup `Page`. If predicate is provided, it passes
  # [Popup] value into the `predicate` function and waits for `predicate(page)` to return a truthy value.
  # Will throw an error if the page is closed before the popup event is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1644
  def expect_popup(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Waits for the matching request and returns it. See [waiting for event](../events.md#waiting-for-event) for more details about events.
  #
  # **Usage**
  #
  # ```python sync
  # with page.expect_request("http://example.com/resource") as first:
  #     page.get_by_text("trigger request").click()
  # first_request = first.value
  #
  # # or with a lambda
  # with page.expect_request(lambda request: request.url == "http://example.com" and request.method == "get") as second:
  #     page.get_by_text("trigger request").click()
  # second_request = second.value
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1663
  def expect_request(urlOrPredicate, timeout: T.unsafe(nil), &block); end

  # Performs action and waits for a `Request` to finish loading. If predicate is provided, it passes
  # `Request` value into the `predicate` function and waits for `predicate(request)` to return a truthy value.
  # Will throw an error if the page is closed before the [`event: Page.requestFinished`] event is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1671
  def expect_request_finished(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Returns the matched response. See [waiting for event](../events.md#waiting-for-event) for more details about events.
  #
  # **Usage**
  #
  # ```python sync
  # with page.expect_response("https://example.com/resource") as response_info:
  #     page.get_by_text("trigger response").click()
  # response = response_info.value
  # return response.ok
  #
  # # or with a lambda
  # with page.expect_response(lambda response: response.url == "https://example.com" and response.status == 200 and response.request.method == "get") as response_info:
  #     page.get_by_text("trigger response").click()
  # response = response_info.value
  # return response.ok
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1692
  def expect_response(urlOrPredicate, timeout: T.unsafe(nil), &block); end

  # Performs action and waits for a new `WebSocket`. If predicate is provided, it passes
  # `WebSocket` value into the `predicate` function and waits for `predicate(webSocket)` to return a truthy value.
  # Will throw an error if the page is closed before the WebSocket event is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1765
  def expect_websocket(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # Performs action and waits for a new `Worker`. If predicate is provided, it passes
  # `Worker` value into the `predicate` function and waits for `predicate(worker)` to return a truthy value.
  # Will throw an error if the page is closed before the worker event is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1773
  def expect_worker(predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # The method adds a function called `name` on the `window` object of every frame in this page. When called, the
  # function executes `callback` and returns a [Promise] which resolves to the return value of `callback`.
  # If the `callback` returns a [Promise], it will be awaited.
  #
  # The first argument of the `callback` function contains information about the caller: `{ browserContext:
  # BrowserContext, page: Page, frame: Frame }`.
  #
  # See [`method: BrowserContext.exposeBinding`] for the context-wide version.
  #
  # **NOTE**: Functions installed via [`method: Page.exposeBinding`] survive navigations.
  #
  # **Usage**
  #
  # An example of exposing page URL to all frames in a page:
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     webkit = playwright.webkit
  #     browser = webkit.launch(headless=False)
  #     context = browser.new_context()
  #     page = context.new_page()
  #     page.expose_binding("pageURL", lambda source: source["page"].url)
  #     page.set_content("""
  #     <script>
  #       async function onClick() {
  #         document.querySelector('div').textContent = await window.pageURL();
  #       }
  #     </script>
  #     <button onclick="onClick()">Click me</button>
  #     <div></div>
  #     """)
  #     page.click("button")
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#473
  def expose_binding(name, callback, handle: T.unsafe(nil)); end

  # The method adds a function called `name` on the `window` object of every frame in the page. When called, the
  # function executes `callback` and returns a [Promise] which resolves to the return value of `callback`.
  #
  # If the `callback` returns a [Promise], it will be awaited.
  #
  # See [`method: BrowserContext.exposeFunction`] for context-wide exposed function.
  #
  # **NOTE**: Functions installed via [`method: Page.exposeFunction`] survive navigations.
  #
  # **Usage**
  #
  # An example of adding a `sha256` function to the page:
  #
  # ```python sync
  # import hashlib
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def sha256(text):
  #     m = hashlib.sha256()
  #     m.update(bytes(text, "utf8"))
  #     return m.hexdigest()
  #
  #
  # def run(playwright: Playwright):
  #     webkit = playwright.webkit
  #     browser = webkit.launch(headless=False)
  #     page = browser.new_page()
  #     page.expose_function("sha256", sha256)
  #     page.set_content("""
  #         <script>
  #           async function onClick() {
  #             document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
  #           }
  #         </script>
  #         <button onclick="onClick()">Click me</button>
  #         <div></div>
  #     """)
  #     page.click("button")
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#520
  def expose_function(name, callback); end

  # The extra HTTP headers will be sent with every request the page initiates.
  #
  # **NOTE**: [`method: Page.setExtraHTTPHeaders`] does not guarantee the order of headers in the outgoing requests.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1373
  def extra_http_headers=(headers); end

  # This method waits for an element matching `selector`, waits for [actionability](../actionability.md) checks, focuses the element, fills it and triggers an `input` event after filling. Note that you can pass an empty string to clear the input field.
  #
  # If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be filled instead.
  #
  # To send fine-grained keyboard events, use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#530
  def fill(selector, value, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method fetches an element with `selector` and focuses it. If there's no element matching
  # `selector`, the method waits until a matching element appears in the DOM.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#543
  def focus(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns frame matching the specified criteria. Either `name` or `url` must be specified.
  #
  # **Usage**
  #
  # ```py
  # frame = page.frame(name="frame-name")
  # ```
  #
  # ```py
  # frame = page.frame(url=r".*domain.*")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#559
  def frame(name: T.unsafe(nil), url: T.unsafe(nil)); end

  # When working with iframes, you can create a frame locator that will enter the iframe and allow selecting elements
  # in that iframe.
  #
  # **Usage**
  #
  # Following snippet locates element with text "Submit" in the iframe with id `my-frame`,
  # like `<iframe id="my-frame">`:
  #
  # ```python sync
  # locator = page.frame_locator("#my-iframe").get_by_text("Submit")
  # locator.click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#576
  def frame_locator(selector); end

  # An array of all frames attached to the page.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#582
  def frames; end

  # Returns element attribute value.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#588
  def get_attribute(selector, name, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Allows locating elements by their alt text.
  #
  # **Usage**
  #
  # For example, this method will find the image by alt text "Playwright logo":
  #
  # ```html
  # <img alt='Playwright logo'>
  # ```
  #
  # ```python sync
  # page.get_by_alt_text("Playwright logo").click()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#606
  def get_by_alt_text(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the `aria-label` attribute.
  #
  # **Usage**
  #
  # For example, this method will find inputs by label "Username" and "Password" in the following DOM:
  #
  # ```html
  # <input aria-label="Username">
  # <label for="password-input">Password:</label>
  # <input id="password-input">
  # ```
  #
  # ```python sync
  # page.get_by_label("Username").fill("john")
  # page.get_by_label("Password").fill("secret")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#627
  def get_by_label(text, exact: T.unsafe(nil)); end

  # Allows locating input elements by the placeholder text.
  #
  # **Usage**
  #
  # For example, consider the following DOM structure.
  #
  # ```html
  # <input type="email" placeholder="name@example.com" />
  # ```
  #
  # You can fill the input after locating it by the placeholder text:
  #
  # ```python sync
  # page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#647
  def get_by_placeholder(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <h3>Sign up</h3>
  # <label>
  #   <input type="checkbox" /> Subscribe
  # </label>
  # <br/>
  # <button>Submit</button>
  # ```
  #
  # You can locate each element by it's implicit role:
  #
  # ```python sync
  # expect(page.get_by_role("heading", name="Sign up")).to_be_visible()
  #
  # page.get_by_role("checkbox", name="Subscribe").check()
  #
  # page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
  # ```
  #
  # **Details**
  #
  # Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback about the ARIA guidelines.
  #
  # Many html elements have an implicitly [defined role](https://w3c.github.io/html-aam/#html-element-role-mappings) that is recognized by the role selector. You can find all the [supported roles here](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). ARIA guidelines **do not recommend** duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#682
  def get_by_role(role, checked: T.unsafe(nil), disabled: T.unsafe(nil), exact: T.unsafe(nil), expanded: T.unsafe(nil), includeHidden: T.unsafe(nil), level: T.unsafe(nil), name: T.unsafe(nil), pressed: T.unsafe(nil), selected: T.unsafe(nil)); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#716
  def get_by_test_id(testId); end

  # Locate element by the test id.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <button data-testid="directions">Itinéraire</button>
  # ```
  #
  # You can locate the element by it's test id:
  #
  # ```python sync
  # page.get_by_test_id("directions").click()
  # ```
  #
  # **Details**
  #
  # By default, the `data-testid` attribute is used as a test id. Use [`method: Selectors.setTestIdAttribute`] to configure a different test id attribute if necessary.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#716
  def get_by_testid(testId); end

  # Allows locating elements that contain given text.
  #
  # See also [`method: Locator.filter`] that allows to match by another criteria, like an accessible role, and then filter by the text content.
  #
  # **Usage**
  #
  # Consider the following DOM structure:
  #
  # ```html
  # <div>Hello <span>world</span></div>
  # <div>Hello</div>
  # ```
  #
  # You can locate by text substring, exact string, or a regular expression:
  #
  # ```python sync
  # # Matches <span>
  # page.get_by_text("world")
  #
  # # Matches first <div>
  # page.get_by_text("Hello world")
  #
  # # Matches second <div>
  # page.get_by_text("Hello", exact=True)
  #
  # # Matches both <div>s
  # page.get_by_text(re.compile("Hello"))
  #
  # # Matches second <div>
  # page.get_by_text(re.compile("^hello$", re.IGNORECASE))
  # ```
  #
  # **Details**
  #
  # Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into one, turns line breaks into spaces and ignores leading and trailing whitespace.
  #
  # Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For example, locating by text `"Log in"` matches `<input type=button value="Log in">`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#759
  def get_by_text(text, exact: T.unsafe(nil)); end

  # Allows locating elements by their title attribute.
  #
  # **Usage**
  #
  # Consider the following DOM structure.
  #
  # ```html
  # <span title='Issues count'>25 issues</span>
  # ```
  #
  # You can check the issues count after locating it by the title text:
  #
  # ```python sync
  # expect(page.get_by_title("Issues count")).to_have_text("25 issues")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#779
  def get_by_title(text, exact: T.unsafe(nil)); end

  # Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
  # last redirect. If cannot go back, returns `null`.
  #
  # Navigate to the previous page in history.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#788
  def go_back(timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
  # last redirect. If cannot go forward, returns `null`.
  #
  # Navigate to the next page in history.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#797
  def go_forward(timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # Returns the main resource response. In case of multiple redirects, the navigation will resolve with the first
  # non-redirect response.
  #
  # The method will throw an error if:
  # - there's an SSL error (e.g. in case of self-signed certificates).
  # - target URL is invalid.
  # - the `timeout` is exceeded during navigation.
  # - the remote server does not respond or is unreachable.
  # - the main resource failed to load.
  #
  # The method will not throw an error when any valid HTTP status code is returned by the remote server, including 404 "Not
  # Found" and 500 "Internal Server Error".  The status code for such responses can be retrieved by calling
  # [`method: Response.status`].
  #
  # **NOTE**: The method either throws an error or returns a main resource response. The only exceptions are navigation to
  # `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
  #
  # **NOTE**: Headless mode doesn't support navigation to a PDF document. See the
  # [upstream issue](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#838
  def goto(url, referer: T.unsafe(nil), timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1797
  def guid; end

  # Returns whether the element is hidden, the opposite of [visible](../actionability.md#visible).  `selector` that does not match any elements is considered hidden.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#915
  def hidden?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method hovers over an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to hover over the center of the element, or the specified `position`.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#851
  def hover(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns `element.innerHTML`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#865
  def inner_html(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns `element.innerText`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#871
  def inner_text(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns `input.value` for the selected `<input>` or `<textarea>` or `<select>` element.
  #
  # Throws for non-input elements. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), returns the value of the control.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#879
  def input_value(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # property
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#56
  def keyboard; end

  # The method returns an element locator that can be used to perform actions on this page / frame.
  # Locator is resolved to the element immediately before performing an action, so a series of actions on the same locator can in fact be performed on different DOM elements. That would happen if the DOM structure between those actions has changed.
  #
  # [Learn more about locators](../locators.md).
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#930
  def locator(selector, has: T.unsafe(nil), hasNot: T.unsafe(nil), hasNotText: T.unsafe(nil), hasText: T.unsafe(nil)); end

  # The page's main frame. Page is guaranteed to have a main frame which persists during navigations.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#941
  def main_frame; end

  # property
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#60
  def mouse; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1845
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1839
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1833
  def once(event, callback); end

  # Returns the opener for popup pages and `null` for others. If the opener has been closed already the returns `null`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#947
  def opener; end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1827
  def owned_context=(req); end

  # Pauses script execution. Playwright will stop executing the script and wait for the user to either press 'Resume'
  # button in the page overlay or to call `playwright.resume()` in the DevTools console.
  #
  # User can inspect selectors or perform manual steps while paused. Resume will continue running the original script from
  # the place it was paused.
  #
  # **NOTE**: This method requires Playwright to be started in a headed mode, with a falsy `headless` option.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#959
  def pause; end

  # Returns the PDF buffer.
  #
  # `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call
  # [`method: Page.emulateMedia`] before calling `page.pdf()`:
  #
  # **NOTE**: By default, `page.pdf()` generates a pdf with modified colors for printing. Use the
  # [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust) property to
  # force rendering of exact colors.
  #
  # **Usage**
  #
  # ```python sync
  # # generates a pdf with "screen" media type.
  # page.emulate_media(media="screen")
  # page.pdf(path="page.pdf")
  # ```
  #
  # The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled
  # values are treated as pixels.
  #
  # A few examples:
  # - `page.pdf({width: 100})` - prints with width set to 100 pixels
  # - `page.pdf({width: '100px'})` - prints with width set to 100 pixels
  # - `page.pdf({width: '10cm'})` - prints with width set to 10 centimeters.
  #
  # All possible units are:
  # - `px` - pixel
  # - `in` - inch
  # - `cm` - centimeter
  # - `mm` - millimeter
  #
  # The `format` options are:
  # - `Letter`: 8.5in x 11in
  # - `Legal`: 8.5in x 14in
  # - `Tabloid`: 11in x 17in
  # - `Ledger`: 17in x 11in
  # - `A0`: 33.1in x 46.8in
  # - `A1`: 23.4in x 33.1in
  # - `A2`: 16.54in x 23.4in
  # - `A3`: 11.7in x 16.54in
  # - `A4`: 8.27in x 11.7in
  # - `A5`: 5.83in x 8.27in
  # - `A6`: 4.13in x 5.83in
  #
  # **NOTE**: `headerTemplate` and `footerTemplate` markup have the following limitations: > 1. Script tags inside
  # templates are not evaluated. > 2. Page styles are not visible inside templates.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1010
  def pdf(displayHeaderFooter: T.unsafe(nil), footerTemplate: T.unsafe(nil), format: T.unsafe(nil), headerTemplate: T.unsafe(nil), height: T.unsafe(nil), landscape: T.unsafe(nil), margin: T.unsafe(nil), outline: T.unsafe(nil), pageRanges: T.unsafe(nil), path: T.unsafe(nil), preferCSSPageSize: T.unsafe(nil), printBackground: T.unsafe(nil), scale: T.unsafe(nil), tagged: T.unsafe(nil), width: T.unsafe(nil)); end

  # Focuses the element, and then uses [`method: Keyboard.down`] and [`method: Keyboard.up`].
  #
  # `key` can specify the intended
  # [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) value or a single character to
  # generate the text for. A superset of the `key` values can be found
  # [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:
  #
  # `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
  # `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
  #
  # Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.
  # `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.
  #
  # Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
  #
  # If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different
  # respective texts.
  #
  # Shortcuts such as `key: "Control+o"`, `key: "Control++` or `key: "Control+Shift+T"` are supported as well. When specified with the
  # modifier, modifier is pressed and being held while the subsequent key is being pressed.
  #
  # **Usage**
  #
  # ```python sync
  # page = browser.new_page()
  # page.goto("https://keycode.info")
  # page.press("body", "A")
  # page.screenshot(path="a.png")
  # page.press("body", "ArrowLeft")
  # page.screenshot(path="arrow_left.png")
  # page.press("body", "Shift+O")
  # page.screenshot(path="o.png")
  # browser.close()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1064
  def press(selector, key, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # The method finds an element matching the specified selector within the page. If no elements match the selector, the
  # return value resolves to `null`. To wait for an element on the page, use [`method: Locator.waitFor`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1077
  def query_selector(selector, strict: T.unsafe(nil)); end

  # The method finds all elements matching the specified selector within the page. If no elements match the selector, the
  # return value resolves to `[]`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1084
  def query_selector_all(selector); end

  # This method reloads the current page, in the same way as if the user had triggered a browser refresh.
  # Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
  # last redirect.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1168
  def reload(timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # Removes all locator handlers added by [`method: Page.addLocatorHandler`] for a specific locator.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1160
  def remove_locator_handler(locator); end

  # API testing helper associated with this page. This method returns the same instance as
  # [`property: BrowserContext.request`] on the page's context. See [`property: BrowserContext.request`] for more details.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#67
  def request; end

  # Request the page to perform garbage collection. Note that there is no guarantee that all unreachable objects will be collected.
  #
  # This is useful to help detect memory leaks. For example, if your page has a large object `'suspect'` that might be leaked, you can check that it does not leak by using a [`WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef).
  #
  # ```python sync
  # # 1. In your page, save a WeakRef for the "suspect".
  # page.evaluate("globalThis.suspectWeakRef = new WeakRef(suspect)")
  # # 2. Request garbage collection.
  # page.request_gc()
  # # 3. Check that weak ref does not deref to the original object.
  # assert page.evaluate("!globalThis.suspectWeakRef.deref()")
  # ```
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#814
  def request_gc; end

  # Routing provides the capability to modify network requests that are made by a page.
  #
  # Once routing is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.
  #
  # **NOTE**: The handler will only be called for the first url if the response is a redirect.
  #
  # **NOTE**: [`method: Page.route`] will not intercept requests intercepted by Service Worker. See [this](https://github.com/microsoft/playwright/issues/1090) issue. We recommend disabling Service Workers when using request interception by setting `serviceWorkers` to `'block'`.
  #
  # **NOTE**: [`method: Page.route`] will not intercept the first request of a popup page. Use [`method: BrowserContext.route`] instead.
  #
  # **Usage**
  #
  # An example of a naive handler that aborts all image requests:
  #
  # ```python sync
  # page = browser.new_page()
  # page.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
  # page.goto("https://example.com")
  # browser.close()
  # ```
  #
  # or the same snippet using a regex pattern instead:
  #
  # ```python sync
  # page = browser.new_page()
  # page.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
  # page.goto("https://example.com")
  # browser.close()
  # ```
  #
  # It is possible to examine the request to decide the route action. For example, mocking all requests that contain some post data, and leaving all other requests as is:
  #
  # ```python sync
  # def handle_route(route: Route):
  #   if ("my-string" in route.request.post_data):
  #     route.fulfill(body="mocked-data")
  #   else:
  #     route.continue_()
  # page.route("/api/**", handle_route)
  # ```
  #
  # Page routes take precedence over browser context routes (set up with [`method: BrowserContext.route`]) when request
  # matches both handlers.
  #
  # To remove a route with its handler you can use [`method: Page.unroute`].
  #
  # **NOTE**: Enabling routing disables http cache.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1220
  def route(url, handler, times: T.unsafe(nil)); end

  # If specified the network requests that are made in the page will be served from the HAR file. Read more about [Replaying from HAR](../mock.md#replaying-from-har).
  #
  # Playwright will not serve requests intercepted by Service Worker from the HAR file. See [this](https://github.com/microsoft/playwright/issues/1090) issue. We recommend disabling Service Workers when using request interception by setting `serviceWorkers` to `'block'`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1228
  def route_from_har(har, notFound: T.unsafe(nil), update: T.unsafe(nil), updateContent: T.unsafe(nil), updateMode: T.unsafe(nil), url: T.unsafe(nil)); end

  # This method allows to modify websocket connections that are made by the page.
  #
  # Note that only `WebSocket`s created after this method was called will be routed. It is recommended to call this method before navigating the page.
  #
  # **Usage**
  #
  # Below is an example of a simple mock that responds to a single message. See `WebSocketRoute` for more details and examples.
  #
  # ```python sync
  # def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  #   if message == "request":
  #     ws.send("response")
  #
  # def handler(ws: WebSocketRoute):
  #   ws.on_message(lambda message: message_handler(ws, message))
  #
  # page.route_web_socket("/ws", handler)
  # ```
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1257
  def route_web_socket(url, handler); end

  # Returns the buffer with the captured screenshot.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1263
  def screenshot(animations: T.unsafe(nil), caret: T.unsafe(nil), clip: T.unsafe(nil), fullPage: T.unsafe(nil), mask: T.unsafe(nil), maskColor: T.unsafe(nil), omitBackground: T.unsafe(nil), path: T.unsafe(nil), quality: T.unsafe(nil), scale: T.unsafe(nil), style: T.unsafe(nil), timeout: T.unsafe(nil), type: T.unsafe(nil)); end

  # This method waits for an element matching `selector`, waits for [actionability](../actionability.md) checks, waits until all specified options are present in the `<select>` element and selects these options.
  #
  # If the target element is not a `<select>` element, this method throws an error. However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), the control will be used instead.
  #
  # Returns the array of option values that have been successfully selected.
  #
  # Triggers a `change` and `input` event once all the provided options have been selected.
  #
  # **Usage**
  #
  # ```python sync
  # # Single selection matching the value or label
  # page.select_option("select#colors", "blue")
  # # single selection matching both the label
  # page.select_option("select#colors", label="blue")
  # # multiple selection
  # page.select_option("select#colors", value=["red", "green", "blue"])
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1299
  def select_option(selector, element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil), force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method checks or unchecks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws.
  # 1. If the element already has the right checked state, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now checked or unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1324
  def set_checked(selector, checked, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # This method internally calls [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), inheriting all its specific characteristics and behaviors.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1338
  def set_content(html, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # This setting will change the default maximum navigation time for the following methods and related shortcuts:
  # - [`method: Page.goBack`]
  # - [`method: Page.goForward`]
  # - [`method: Page.goto`]
  # - [`method: Page.reload`]
  # - [`method: Page.setContent`]
  # - [`method: Page.waitForNavigation`]
  # - [`method: Page.waitForURL`]
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`] takes priority over [`method: Page.setDefaultTimeout`],
  # [`method: BrowserContext.setDefaultTimeout`] and [`method: BrowserContext.setDefaultNavigationTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1355
  def set_default_navigation_timeout(timeout); end

  # This setting will change the default maximum time for all the methods accepting `timeout` option.
  #
  # **NOTE**: [`method: Page.setDefaultNavigationTimeout`] takes priority over [`method: Page.setDefaultTimeout`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1364
  def set_default_timeout(timeout); end

  # The extra HTTP headers will be sent with every request the page initiates.
  #
  # **NOTE**: [`method: Page.setExtraHTTPHeaders`] does not guarantee the order of headers in the outgoing requests.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1373
  def set_extra_http_headers(headers); end

  # Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
  # are resolved relative to the current working directory. For empty array, clears the selected files.
  # For inputs with a `[webkitdirectory]` attribute, only a single directory path is supported.
  #
  # This method expects `selector` to point to an
  # [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). However, if the element is inside the `<label>` element that has an associated [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), targets the control instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1385
  def set_input_files(selector, files, noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # In the case of multiple pages in a single browser, each page can have its own viewport size. However,
  # [`method: Browser.newContext`] allows to set viewport size (and more) for all pages in the context at once.
  #
  # [`method: Page.setViewportSize`] will resize the page. A lot of websites don't expect phones to change size, so you should set the
  # viewport size before navigating to the page. [`method: Page.setViewportSize`] will also reset `screen` size, use [`method: Browser.newContext`] with `screen` and `viewport` parameters if you need better control of these properties.
  #
  # **Usage**
  #
  # ```python sync
  # page = browser.new_page()
  # page.set_viewport_size({"width": 640, "height": 480})
  # page.goto("https://example.com")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1408
  def set_viewport_size(viewportSize); end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1802
  def snapshot_for_ai; end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1817
  def start_css_coverage(resetOnNavigation: T.unsafe(nil), reportAnonymousScripts: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1807
  def start_js_coverage(resetOnNavigation: T.unsafe(nil), reportAnonymousScripts: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1822
  def stop_css_coverage; end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1812
  def stop_js_coverage; end

  # This method taps an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.touchscreen`] to tap the center of the element, or the specified `position`.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # **NOTE**: [`method: Page.tap`] the method will throw if `hasTouch` option of the browser context is false.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1424
  def tap_point(selector, force: T.unsafe(nil), modifiers: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Returns `element.textContent`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1438
  def text_content(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns the page's title.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1444
  def title; end

  # property
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#71
  def touchscreen; end

  # Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send
  # fine-grained keyboard events. To fill values in form fields, use [`method: Page.fill`].
  #
  # To press a special key, like `Control` or `ArrowDown`, use [`method: Keyboard.press`].
  #
  # **Usage**
  #
  # @deprecated In most cases, you should use [`method: Locator.fill`] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [`method: Locator.pressSequentially`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1457
  def type(selector, text, delay: T.unsafe(nil), noWaitAfter: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # This method unchecks an element matching `selector` by performing the following steps:
  # 1. Find an element matching `selector`. If there is none, wait until a matching element is attached to the DOM.
  # 1. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is already unchecked, this method returns immediately.
  # 1. Wait for [actionability](../actionability.md) checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
  # 1. Scroll the element into view if needed.
  # 1. Use [`property: Page.mouse`] to click in the center of the element.
  # 1. Ensure that the element is now unchecked. If not, this method throws.
  #
  # When all steps combined have not finished during the specified `timeout`, this method throws a
  # `TimeoutError`. Passing zero timeout disables this.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1478
  def uncheck(selector, force: T.unsafe(nil), noWaitAfter: T.unsafe(nil), position: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil), trial: T.unsafe(nil)); end

  # Removes a route created with [`method: Page.route`]. When `handler` is not specified, removes all routes for
  # the `url`.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1498
  def unroute(url, handler: T.unsafe(nil)); end

  # Removes all routes created with [`method: Page.route`] and [`method: Page.routeFromHAR`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1491
  def unroute_all(behavior: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1502
  def url; end

  # Video object associated with this page.
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1508
  def video; end

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1512
  def viewport_size; end

  # In the case of multiple pages in a single browser, each page can have its own viewport size. However,
  # [`method: Browser.newContext`] allows to set viewport size (and more) for all pages in the context at once.
  #
  # [`method: Page.setViewportSize`] will resize the page. A lot of websites don't expect phones to change size, so you should set the
  # viewport size before navigating to the page. [`method: Page.setViewportSize`] will also reset `screen` size, use [`method: Browser.newContext`] with `screen` and `viewport` parameters if you need better control of these properties.
  #
  # **Usage**
  #
  # ```python sync
  # page = browser.new_page()
  # page.set_viewport_size({"width": 640, "height": 480})
  # page.goto("https://example.com")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1408
  def viewport_size=(viewportSize); end

  # Returns whether the element is [visible](../actionability.md#visible). `selector` that does not match any elements is considered not visible.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#921
  def visible?(selector, strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # **NOTE**: In most cases, you should use [`method: Page.waitForEvent`].
  #
  # Waits for given `event` to fire. If predicate is provided, it passes
  # event's value into the `predicate` function and waits for `predicate(event)` to return a truthy value.
  # Will throw an error if the page is closed before the `event` is fired.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1792
  def wait_for_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns when the `expression` returns a truthy value. It resolves to a JSHandle of the truthy value.
  #
  # **Usage**
  #
  # The [`method: Page.waitForFunction`] can be used to observe viewport size change:
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     webkit = playwright.webkit
  #     browser = webkit.launch()
  #     page = browser.new_page()
  #     page.evaluate("window.x = 0; setTimeout(() => { window.x = 100 }, 1000);")
  #     page.wait_for_function("() => window.x > 0")
  #     browser.close()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # To pass an argument to the predicate of [`method: Page.waitForFunction`] function:
  #
  # ```python sync
  # selector = ".foo"
  # page.wait_for_function("selector => !!document.querySelector(selector)", selector)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1583
  def wait_for_function(expression, arg: T.unsafe(nil), polling: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns when the required load state has been reached.
  #
  # This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed
  # when this method is called. If current document has already reached the required state, resolves immediately.
  #
  # **NOTE**: Most of the time, this method is not needed because Playwright [auto-waits before every action](../actionability.md).
  #
  # **Usage**
  #
  # ```python sync
  # page.get_by_role("button").click() # click triggers navigation.
  # page.wait_for_load_state() # the promise resolves after "load" event.
  # ```
  #
  # ```python sync
  # with page.expect_popup() as page_info:
  #     page.get_by_role("button").click() # click triggers a popup.
  # popup = page_info.value
  # # Wait for the "DOMContentLoaded" event.
  # popup.wait_for_load_state("domcontentloaded")
  # print(popup.title()) # popup is ready to use.
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1610
  def wait_for_load_state(state: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Returns when element specified by selector satisfies `state` option. Returns `null` if waiting for `hidden` or
  # `detached`.
  #
  # **NOTE**: Playwright automatically waits for element to be ready before performing an action. Using
  # `Locator` objects and web-first assertions makes the code wait-for-selector-free.
  #
  # Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become
  # visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method
  # will return immediately. If the selector doesn't satisfy the condition for the `timeout` milliseconds, the
  # function will throw.
  #
  # **Usage**
  #
  # This method works across navigations:
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     chromium = playwright.chromium
  #     browser = chromium.launch()
  #     page = browser.new_page()
  #     for current_url in ["https://google.com", "https://bbc.com"]:
  #         page.goto(current_url, wait_until="domcontentloaded")
  #         element = page.wait_for_selector("img")
  #         print("Loaded image: " + str(element.get_attribute("src")))
  #     browser.close()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1728
  def wait_for_selector(selector, state: T.unsafe(nil), strict: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Waits for the given `timeout` in milliseconds.
  #
  # Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be
  # flaky. Use signals such as network events, selectors becoming visible and others instead.
  #
  # **Usage**
  #
  # ```python sync
  # # wait for 1 second
  # page.wait_for_timeout(1000)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1744
  def wait_for_timeout(timeout); end

  # Waits for the main frame to navigate to the given URL.
  #
  # **Usage**
  #
  # ```python sync
  # page.click("a.delayed-navigation") # clicking the link will indirectly cause a navigation
  # page.wait_for_url("**/target.html")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1757
  def wait_for_url(url, timeout: T.unsafe(nil), waitUntil: T.unsafe(nil)); end

  # This method returns all of the dedicated [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
  # associated with the page.
  #
  # **NOTE**: This does not contain ServiceWorkers
  #
  # source://playwright-ruby-client//lib/playwright_api/page.rb#1782
  def workers; end

  private

  # source://playwright-ruby-client//lib/playwright_api/page.rb#1849
  def event_emitter_proxy; end
end

# The `PageAssertions` class provides assertion methods that can be used to make assertions about the `Page` state in the tests.
#
# ```python sync
# import re
# from playwright.sync_api import Page, expect
#
# def test_navigates_to_login_page(page: Page) -> None:
#     # ..
#     page.get_by_text("Sign in").click()
#     expect(page).to_have_url(re.compile(r".*/login"))
# ```
#
# source://playwright-ruby-client//lib/playwright_api/page_assertions.rb#14
class Playwright::PageAssertions < ::Playwright::PlaywrightApi
  # The opposite of [`method: PageAssertions.toHaveTitle`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page_assertions.rb#18
  def not_to_have_title(titleOrRegExp, timeout: T.unsafe(nil)); end

  # The opposite of [`method: PageAssertions.toHaveURL`].
  #
  # source://playwright-ruby-client//lib/playwright_api/page_assertions.rb#24
  def not_to_have_url(urlOrRegExp, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Ensures the page has the given title.
  #
  # **Usage**
  #
  # ```python sync
  # import re
  # from playwright.sync_api import expect
  #
  # # ...
  # expect(page).to_have_title(re.compile(r".*checkout"))
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page_assertions.rb#40
  def to_have_title(titleOrRegExp, timeout: T.unsafe(nil)); end

  # Ensures the page is navigated to the given URL.
  #
  # **Usage**
  #
  # ```python sync
  # import re
  # from playwright.sync_api import expect
  #
  # # ...
  # expect(page).to_have_url(re.compile(".*checkout"))
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/page_assertions.rb#56
  def to_have_url(urlOrRegExp, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end
end

# source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#0
class Playwright::PageAssertionsImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#14
  def initialize(page, default_expect_timeout, is_not, message); end

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#5
  def not_to_have_title(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#5
  def not_to_have_url(*args, **kwargs); end

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#107
  def to_have_title(title_or_regex, timeout: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#126
  def to_have_url(url_or_regex, ignoreCase: T.unsafe(nil), timeout: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#60
  def _not; end

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#22
  def expect_impl(expression, expect_options, expected, message, title); end

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#69
  def expected_regex(pattern, match_substring, normalize_white_space, ignore_case); end

  # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#83
  def to_expected_text_values(items, match_substring: T.unsafe(nil), normalize_white_space: T.unsafe(nil), ignore_case: T.unsafe(nil)); end

  class << self
    # source://playwright-ruby-client//lib/playwright/page_assertions_impl.rb#4
    def _define_negation(method_name); end
  end
end

# Playwright module provides a method to launch a browser instance. The following is a typical example of using Playwright
# to drive automation:
#
# ```python sync
# from playwright.sync_api import sync_playwright, Playwright
#
# def run(playwright: Playwright):
#     chromium = playwright.chromium # or "firefox" or "webkit".
#     browser = chromium.launch()
#     page = browser.new_page()
#     page.goto("http://example.com")
#     # other actions...
#     browser.close()
#
# with sync_playwright() as playwright:
#     run(playwright)
# ```
#
# source://playwright-ruby-client//lib/playwright_api/playwright.rb#20
class Playwright::Playwright < ::Playwright::PlaywrightApi
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#102
  def android; end

  # This object can be used to launch or connect to Chromium, returning instances of `Browser`.
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#24
  def chromium; end

  # Returns a dictionary of devices to be used with [`method: Browser.newContext`] or [`method: Browser.newPage`].
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     webkit = playwright.webkit
  #     iphone = playwright.devices["iPhone 6"]
  #     browser = webkit.launch()
  #     context = browser.new_context(**iphone)
  #     page = context.new_page()
  #     page.goto("http://example.com")
  #     # other actions...
  #     browser.close()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#47
  def devices; end

  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#97
  def electron; end

  # This object can be used to launch or connect to Firefox, returning instances of `Browser`.
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#53
  def firefox; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#120
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#114
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#108
  def once(event, callback); end

  # Exposes API that can be used for the Web API testing.
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#59
  def request; end

  # Selectors can be used to install custom selector engines. See
  # [extensibility](../extensibility.md) for more information.
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#66
  def selectors; end

  # Terminates this instance of Playwright in case it was created bypassing the Python context manager. This is useful in REPL applications.
  #
  # ```py
  # from playwright.sync_api import sync_playwright
  #
  # playwright = sync_playwright().start()
  #
  # browser = playwright.chromium.launch()
  # page = browser.new_page()
  # page.goto("https://playwright.dev/")
  # page.screenshot(path="example.png")
  # browser.close()
  #
  # playwright.stop()
  # ```
  #
  # @raise [NotImplementedError]
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#92
  def stop; end

  # This object can be used to launch or connect to WebKit, returning instances of `Browser`.
  #
  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#72
  def webkit; end

  private

  # source://playwright-ruby-client//lib/playwright_api/playwright.rb#124
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/playwright_api.rb#2
class Playwright::PlaywrightApi
  # @param impl [Playwright::ChannelOwner|Playwright::ApiImplementation]
  # @return [PlaywrightApi] a new instance of PlaywrightApi
  #
  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#111
  def initialize(impl); end

  private

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#145
  def unwrap_impl(object, visited: T.unsafe(nil)); end

  # @param block [Proc]
  #
  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#116
  def wrap_block_call(block); end

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#125
  def wrap_impl(object, visited: T.unsafe(nil)); end

  class << self
    # Unwrap ChannelOwner / ApiImplementation.
    #
    # @note Intended for internal use only.
    #
    # source://playwright-ruby-client//lib/playwright/playwright_api.rb#23
    def unwrap(api); end

    # Wrap ChannelOwner / ApiImplementation.
    # Playwright::ChannelOwners::XXXXX will be wrapped as Playwright::XXXXX
    # Playwright::YYYYImpl will be wrapped as Playwright::YYYY
    # Playwright::XXXXX is automatically generated by development/generate_api
    #
    # @note Intended for internal use only.
    # @param channel_owner [ChannelOwner|ApiImplementation]
    #
    # source://playwright-ruby-client//lib/playwright/playwright_api.rb#10
    def wrap(channel_owner_or_api_implementation); end
  end
end

# source://playwright-ruby-client//lib/playwright/playwright_api.rb#73
class Playwright::PlaywrightApi::ApiImplementationWrapper
  # @return [ApiImplementationWrapper] a new instance of ApiImplementationWrapper
  #
  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#74
  def initialize(impl); end

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#83
  def wrap; end

  private

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#100
  def detect_class_for(klass); end

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#94
  def expected_class_name_for(klass); end
end

# source://playwright-ruby-client//lib/playwright/playwright_api.rb#32
class Playwright::PlaywrightApi::ChannelOwnerWrapper
  # @return [ChannelOwnerWrapper] a new instance of ChannelOwnerWrapper
  #
  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#33
  def initialize(impl); end

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#42
  def wrap; end

  private

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#61
  def detect_class_for(klass); end

  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#53
  def expected_class_name_for(klass); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/playwright_api.rb#57
  def superclass_exist?(klass); end
end

# source://playwright-ruby-client//lib/playwright/raw_headers.rb#2
class Playwright::RawHeaders
  # @return [RawHeaders] a new instance of RawHeaders
  #
  # source://playwright-ruby-client//lib/playwright/raw_headers.rb#3
  def initialize(headers_array); end

  # @return [String|nil]
  #
  # source://playwright-ruby-client//lib/playwright/raw_headers.rb#21
  def get(name); end

  # @return [Array<String>]
  #
  # source://playwright-ruby-client//lib/playwright/raw_headers.rb#32
  def get_all(name); end

  # source://playwright-ruby-client//lib/playwright/raw_headers.rb#41
  def headers; end

  # source://playwright-ruby-client//lib/playwright/raw_headers.rb#47
  def headers_array; end

  private

  # source://playwright-ruby-client//lib/playwright/raw_headers.rb#53
  def join(key, values); end
end

# Whenever the page sends a request for a network resource the following sequence of events are emitted by `Page`:
# - [`event: Page.request`] emitted when the request is issued by the page.
# - [`event: Page.response`] emitted when/if the response status and headers are received for the request.
# - [`event: Page.requestFinished`] emitted when the response body is downloaded and the request is complete.
#
# If request fails at some point, then instead of `'requestfinished'` event (and possibly instead of 'response' event),
# the  [`event: Page.requestFailed`] event is emitted.
#
# **NOTE**: HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request will complete
# with `'requestfinished'` event.
#
# If request gets a 'redirect' response, the request is successfully finished with the `requestfinished` event, and a new
# request is  issued to a redirected url.
#
# source://playwright-ruby-client//lib/playwright_api/request.rb#16
class Playwright::Request < ::Playwright::PlaywrightApi
  # An object with all the request HTTP headers associated with this request. The header names are lower-cased.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#20
  def all_headers; end

  # source://playwright-ruby-client//lib/playwright_api/request.rb#199
  def apply_fallback_overrides(overrides); end

  # The method returns `null` unless this request has failed, as reported by `requestfailed` event.
  #
  # **Usage**
  #
  # Example of logging of all the failed requests:
  #
  # ```py
  # page.on("requestfailed", lambda request: print(request.url + " " + request.failure))
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#34
  def failure; end

  # Returns the `Frame` that initiated this request.
  #
  # **Usage**
  #
  # ```py
  # frame_url = request.frame.url
  # ```
  #
  # **Details**
  #
  # Note that in some cases the frame is not available, and this method will throw.
  # - When request originates in the Service Worker. You can use `request.serviceWorker()` to check that.
  # - When navigation request is issued before the corresponding frame is created. You can use [`method: Request.isNavigationRequest`] to check that.
  #
  # Here is an example that handles all the cases:
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#54
  def frame; end

  # Returns the value of the header matching the name. The name is case-insensitive.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#75
  def header_value(name); end

  # source://playwright-ruby-client//lib/playwright_api/request.rb#204
  def header_values(name); end

  # An object with the request HTTP headers. The header names are lower-cased.
  # Note that this method does not return security-related headers, including cookie-related ones.
  # You can use [`method: Request.allHeaders`] for complete list of headers that include `cookie` information.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#62
  def headers; end

  # An array with all the request HTTP headers associated with this request. Unlike [`method: Request.allHeaders`], header names are NOT lower-cased.
  # Headers with multiple entries, such as `Set-Cookie`, appear in the array multiple times.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#69
  def headers_array; end

  # Request's method (GET, POST, etc.)
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#90
  def method; end

  # Whether this request is driving frame's navigation.
  #
  # Some navigation requests are issued before the corresponding frame is created, and therefore
  # do not have [`method: Request.frame`] available.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#84
  def navigation_request?; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#222
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#216
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#210
  def once(event, callback); end

  # Request's post body, if any.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#96
  def post_data; end

  # Request's post body in a binary form, if any.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#102
  def post_data_buffer; end

  # Returns parsed request's body for `form-urlencoded` and JSON as a fallback if any.
  #
  # When the response is `application/x-www-form-urlencoded` then a key/value object of the values will be returned.
  # Otherwise it will be parsed as JSON.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#111
  def post_data_json; end

  # Request that was redirected by the server to this one, if any.
  #
  # When the server responds with a redirect, Playwright creates a new `Request` object. The two requests are connected by
  # `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to
  # construct the whole redirect chain by repeatedly calling `redirectedFrom()`.
  #
  # **Usage**
  #
  # For example, if the website `http://example.com` redirects to `https://example.com`:
  #
  # ```python sync
  # response = page.goto("http://example.com")
  # print(response.request.redirected_from.url) # "http://example.com"
  # ```
  #
  # If the website `https://google.com` has no redirects:
  #
  # ```python sync
  # response = page.goto("https://google.com")
  # print(response.request.redirected_from) # None
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#137
  def redirected_from; end

  # New request issued by the browser if the server responded with redirect.
  #
  # **Usage**
  #
  # This method is the opposite of [`method: Request.redirectedFrom`]:
  #
  # ```py
  # assert request.redirected_from.redirected_to == request
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#151
  def redirected_to; end

  # Contains the request's resource type as it was perceived by the rendering engine. ResourceType will be one of the
  # following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`,
  # `websocket`, `manifest`, `other`.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#159
  def resource_type; end

  # Returns the matching `Response` object, or `null` if the response was not received due to error.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#165
  def response; end

  # Returns resource size information for given request.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#171
  def sizes; end

  # Returns resource timing information for given request. Most of the timing values become available upon the response,
  # `responseEnd` becomes available when request finishes. Find more information at
  # [Resource Timing API](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming).
  #
  # **Usage**
  #
  # ```python sync
  # with page.expect_event("requestfinished") as request_info:
  #     page.goto("http://example.com")
  # request = request_info.value
  # print(request.timing)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#188
  def timing; end

  # URL of the request.
  #
  # source://playwright-ruby-client//lib/playwright_api/request.rb#194
  def url; end

  private

  # source://playwright-ruby-client//lib/playwright_api/request.rb#226
  def event_emitter_proxy; end
end

# `Response` class represents responses which are received by page.
#
# source://playwright-ruby-client//lib/playwright_api/response.rb#4
class Playwright::Response < ::Playwright::PlaywrightApi
  # An object with all the response HTTP headers associated with this response.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#8
  def all_headers; end

  # Returns the buffer with response body.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#14
  def body; end

  # Waits for this response to finish, returns always `null`.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#20
  def finished; end

  # Returns the `Frame` that initiated this response.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#26
  def frame; end

  # Indicates whether this Response was fulfilled by a Service Worker's Fetch Handler (i.e. via [FetchEvent.respondWith](https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith)).
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#32
  def from_service_worker; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#121
  def from_service_worker?; end

  # Returns the value of the header matching the name. The name is case-insensitive. If multiple headers have
  # the same name (except `set-cookie`), they are returned as a list separated by `, `. For `set-cookie`, the `\n` separator is used. If no headers are found, `null` is returned.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#54
  def header_value(name); end

  # Returns all values of the headers matching the name, for example `set-cookie`. The name is case-insensitive.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#60
  def header_values(name); end

  # An object with the response HTTP headers. The header names are lower-cased.
  # Note that this method does not return security-related headers, including cookie-related ones.
  # You can use [`method: Response.allHeaders`] for complete list of headers that include `cookie` information.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#40
  def headers; end

  # An array with all the request HTTP headers associated with this response. Unlike [`method: Response.allHeaders`], header names are NOT lower-cased.
  # Headers with multiple entries, such as `Set-Cookie`, appear in the array multiple times.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#47
  def headers_array; end

  # Returns the JSON representation of response body.
  #
  # This method will throw if the response body is not parsable via `JSON.parse`.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#68
  def json; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#144
  def off(event, callback); end

  # Contains a boolean stating whether the response was successful (status in the range 200-299) or not.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#74
  def ok; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#126
  def ok?; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#138
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#132
  def once(event, callback); end

  # Returns the matching `Request` object.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#80
  def request; end

  # Returns SSL and other security information.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#86
  def security_details; end

  # Returns the IP address and port of the server.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#92
  def server_addr; end

  # Contains the status code of the response (e.g., 200 for a success).
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#98
  def status; end

  # Contains the status text of the response (e.g. usually an "OK" for a success).
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#104
  def status_text; end

  # Returns the text representation of response body.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#110
  def text; end

  # Contains the URL of the response.
  #
  # source://playwright-ruby-client//lib/playwright_api/response.rb#116
  def url; end

  private

  # source://playwright-ruby-client//lib/playwright_api/response.rb#148
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/channel_owner.rb#139
class Playwright::RootChannelOwner < ::Playwright::ChannelOwner
  # @param connection [Playwright::Connection]
  # @return [RootChannelOwner] a new instance of RootChannelOwner
  #
  # source://playwright-ruby-client//lib/playwright/channel_owner.rb#141
  def initialize(connection); end
end

# Whenever a network route is set up with [`method: Page.route`] or [`method: BrowserContext.route`], the `Route` object
# allows to handle the route.
#
# Learn more about [networking](../network.md).
#
# source://playwright-ruby-client//lib/playwright_api/route.rb#7
class Playwright::Route < ::Playwright::PlaywrightApi
  # Aborts the route's request.
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#11
  def abort(errorCode: T.unsafe(nil)); end

  # Sends route's request to the network with optional overrides.
  #
  # **Usage**
  #
  # ```python sync
  # def handle(route, request):
  #     # override headers
  #     headers = {
  #         **request.headers,
  #         "foo": "foo-value", # set "foo" header
  #         "bar": None # remove "bar" header
  #     }
  #     route.continue_(headers=headers)
  #
  # page.route("**/*", handle)
  # ```
  #
  # **Details**
  #
  # The `headers` option applies to both the routed request and any redirects it initiates. However, `url`, `method`, and `postData` only apply to the original request and are not carried over to redirected requests.
  #
  # [`method: Route.continue`] will immediately send the request to the network, other matching handlers won't be invoked. Use [`method: Route.fallback`] If you want next matching handler in the chain to be invoked.
  #
  # **NOTE**: The `Cookie` header cannot be overridden using this method. If a value is provided, it will be ignored, and the cookie will be loaded from the browser's cookie store. To set custom cookies, use [`method: BrowserContext.addCookies`].
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#40
  def continue(headers: T.unsafe(nil), method: T.unsafe(nil), postData: T.unsafe(nil), url: T.unsafe(nil)); end

  # Continues route's request with optional overrides. The method is similar to [`method: Route.continue`] with the difference that other matching handlers will be invoked before sending the request.
  #
  # **Usage**
  #
  # When several routes match the given pattern, they run in the order opposite to their registration.
  # That way the last registered route can always override all the previous ones. In the example below,
  # request will be handled by the bottom-most handler first, then it'll fall back to the previous one and
  # in the end will be aborted by the first registered route.
  #
  # ```python sync
  # page.route("**/*", lambda route: route.abort())  # Runs last.
  # page.route("**/*", lambda route: route.fallback())  # Runs second.
  # page.route("**/*", lambda route: route.fallback())  # Runs first.
  # ```
  #
  # Registering multiple routes is useful when you want separate handlers to
  # handle different kinds of requests, for example API calls vs page resources or
  # GET requests vs POST requests as in the example below.
  #
  # ```python sync
  # # Handle GET requests.
  # def handle_get(route):
  #     if route.request.method != "GET":
  #         route.fallback()
  #         return
  #   # Handling GET only.
  #   # ...
  #
  # # Handle POST requests.
  # def handle_post(route):
  #     if route.request.method != "POST":
  #         route.fallback()
  #         return
  #   # Handling POST only.
  #   # ...
  #
  # page.route("**/*", handle_get)
  # page.route("**/*", handle_post)
  # ```
  #
  # One can also modify request while falling back to the subsequent handler, that way intermediate
  # route handler can modify url, method, headers and postData of the request.
  #
  # ```python sync
  # def handle(route, request):
  #     # override headers
  #     headers = {
  #         **request.headers,
  #         "foo": "foo-value", # set "foo" header
  #         "bar": None # remove "bar" header
  #     }
  #     route.fallback(headers=headers)
  #
  # page.route("**/*", handle)
  # ```
  #
  # Use [`method: Route.continue`] to immediately send the request to the network, other matching handlers won't be invoked in that case.
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#102
  def fallback(headers: T.unsafe(nil), method: T.unsafe(nil), postData: T.unsafe(nil), url: T.unsafe(nil)); end

  # Performs the request and fetches result without fulfilling it, so that the response
  # could be modified and then fulfilled.
  #
  # **Usage**
  #
  # ```python sync
  # def handle(route):
  #     response = route.fetch()
  #     json = response.json()
  #     json["message"]["big_red_dog"] = []
  #     route.fulfill(response=response, json=json)
  #
  # page.route("https://dog.ceo/api/breeds/list/all", handle)
  # ```
  #
  # **Details**
  #
  # Note that `headers` option will apply to the fetched request as well as any redirects initiated by it. If you want to only apply `headers` to the original request, but not to redirects, look into [`method: Route.continue`] instead.
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#125
  def fetch(headers: T.unsafe(nil), maxRedirects: T.unsafe(nil), maxRetries: T.unsafe(nil), method: T.unsafe(nil), postData: T.unsafe(nil), timeout: T.unsafe(nil), url: T.unsafe(nil)); end

  # Fulfills route's request with given response.
  #
  # **Usage**
  #
  # An example of fulfilling all requests with 404 responses:
  #
  # ```python sync
  # page.route("**/*", lambda route: route.fulfill(
  #     status=404,
  #     content_type="text/plain",
  #     body="not found!"))
  # ```
  #
  # An example of serving static file:
  #
  # ```python sync
  # page.route("**/xhr_endpoint", lambda route: route.fulfill(path="mock_data.json"))
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#155
  def fulfill(body: T.unsafe(nil), contentType: T.unsafe(nil), headers: T.unsafe(nil), json: T.unsafe(nil), path: T.unsafe(nil), response: T.unsafe(nil), status: T.unsafe(nil)); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#191
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#185
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#179
  def once(event, callback); end

  # source://playwright-ruby-client//lib/playwright_api/route.rb#173
  def redirect_navigation_request(url); end

  # A request to be routed.
  #
  # source://playwright-ruby-client//lib/playwright_api/route.rb#168
  def request; end

  private

  # source://playwright-ruby-client//lib/playwright_api/route.rb#195
  def event_emitter_proxy; end
end

# source://playwright-ruby-client//lib/playwright/route_handler.rb#2
class Playwright::RouteHandler
  # @param url [String]
  # @param base_url [String|nil]
  # @param handler [Proc]
  # @param times [Integer|nil]
  # @return [RouteHandler] a new instance of RouteHandler
  #
  # source://playwright-ruby-client//lib/playwright/route_handler.rb#34
  def initialize(url, base_url, handler, times); end

  # source://playwright-ruby-client//lib/playwright/route_handler.rb#46
  def as_pattern; end

  # source://playwright-ruby-client//lib/playwright/route_handler.rb#54
  def async_handle(route); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/route_handler.rb#62
  def expired?; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/route_handler.rb#50
  def match?(url); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/route_handler.rb#66
  def same_value?(url:, handler: T.unsafe(nil)); end

  class << self
    # source://playwright-ruby-client//lib/playwright/route_handler.rb#74
    def prepare_interception_patterns(handlers); end
  end
end

# source://playwright-ruby-client//lib/playwright/route_handler.rb#3
class Playwright::RouteHandler::CountDown
  # @return [CountDown] a new instance of CountDown
  #
  # source://playwright-ruby-client//lib/playwright/route_handler.rb#4
  def initialize(count); end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/route_handler.rb#15
  def expired?; end

  # source://playwright-ruby-client//lib/playwright/route_handler.rb#8
  def increment; end
end

# source://playwright-ruby-client//lib/playwright/route_handler.rb#20
class Playwright::RouteHandler::StubCounter
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/route_handler.rb#25
  def expired?; end

  # source://playwright-ruby-client//lib/playwright/route_handler.rb#21
  def increment; end
end

# source://playwright-ruby-client//lib/playwright/select_option_values.rb#2
class Playwright::SelectOptionValues
  # @return [SelectOptionValues] a new instance of SelectOptionValues
  #
  # source://playwright-ruby-client//lib/playwright/select_option_values.rb#3
  def initialize(element: T.unsafe(nil), index: T.unsafe(nil), value: T.unsafe(nil), label: T.unsafe(nil)); end

  # @return [Hash]
  #
  # source://playwright-ruby-client//lib/playwright/select_option_values.rb#31
  def as_params; end

  private

  # source://playwright-ruby-client//lib/playwright/select_option_values.rb#35
  def convert(key, values); end
end

# Selectors can be used to install custom selector engines. See [extensibility](../extensibility.md) for more
# information.
#
# source://playwright-ruby-client//lib/playwright_api/selectors.rb#5
class Playwright::Selectors < ::Playwright::PlaywrightApi
  # Selectors must be registered before creating the page.
  #
  # **Usage**
  #
  # An example of registering selector engine that queries elements based on a tag name:
  #
  # ```python sync
  # from playwright.sync_api import sync_playwright, Playwright
  #
  # def run(playwright: Playwright):
  #     tag_selector = """
  #       {
  #           // Returns the first element matching given selector in the root's subtree.
  #           query(root, selector) {
  #               return root.querySelector(selector);
  #           },
  #           // Returns all elements matching given selector in the root's subtree.
  #           queryAll(root, selector) {
  #               return Array.from(root.querySelectorAll(selector));
  #           }
  #       }"""
  #
  #     # Register the engine. Selectors will be prefixed with "tag=".
  #     playwright.selectors.register("tag", tag_selector)
  #     browser = playwright.chromium.launch()
  #     page = browser.new_page()
  #     page.set_content('<div><button>Click me</button></div>')
  #
  #     # Use the selector prefixed with its name.
  #     button = page.locator('tag=button')
  #     # Combine it with built-in locators.
  #     page.locator('tag=div').get_by_text('Click me').click()
  #     # Can use it in any methods supporting selectors.
  #     button_count = page.locator('tag=button').count()
  #     print(button_count)
  #     browser.close()
  #
  # with sync_playwright() as playwright:
  #     run(playwright)
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/selectors.rb#48
  def register(name, script: T.unsafe(nil), contentScript: T.unsafe(nil), path: T.unsafe(nil)); end

  # Defines custom attribute name to be used in [`method: Page.getByTestId`]. `data-testid` is used by default.
  #
  # source://playwright-ruby-client//lib/playwright_api/selectors.rb#54
  def set_test_id_attribute(attributeName); end

  # Defines custom attribute name to be used in [`method: Page.getByTestId`]. `data-testid` is used by default.
  #
  # source://playwright-ruby-client//lib/playwright_api/selectors.rb#54
  def test_id_attribute=(attributeName); end
end

# source://playwright-ruby-client//lib/playwright/selectors_impl.rb#0
class Playwright::SelectorsImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/selectors_impl.rb#4
  def initialize; end

  # source://playwright-ruby-client//lib/playwright/selectors_impl.rb#9
  def register(name, contentScript: T.unsafe(nil), path: T.unsafe(nil), script: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/selectors_impl.rb#30
  def set_test_id_attribute(attribute_name); end

  private

  # source://playwright-ruby-client//lib/playwright/selectors_impl.rb#41
  def contexts_for_selectors; end

  # source://playwright-ruby-client//lib/playwright/selectors_impl.rb#35
  def update_with_selector_options(options); end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#24
class Playwright::SocketClosedError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#25
  def initialize; end
end

# source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#30
class Playwright::SocketError < ::StandardError
  # source://playwright-ruby-client//lib/playwright/channel_owners/web_socket.rb#31
  def initialize; end
end

# source://playwright-ruby-client//lib/playwright/errors.rb#55
class Playwright::TargetClosedError < ::Playwright::Error
  # @return [TargetClosedError] a new instance of TargetClosedError
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#56
  def initialize(message: T.unsafe(nil), stack: T.unsafe(nil)); end
end

# source://playwright-ruby-client//lib/playwright/errors.rb#49
class Playwright::TimeoutError < ::Playwright::Error
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#50
  def initialize(message:, stack: T.unsafe(nil)); end
end

# source://playwright-ruby-client//lib/playwright/timeout_settings.rb#2
class Playwright::TimeoutSettings
  # @return [TimeoutSettings] a new instance of TimeoutSettings
  #
  # source://playwright-ruby-client//lib/playwright/timeout_settings.rb#6
  def initialize(parent = T.unsafe(nil)); end

  # Sets the attribute default_navigation_timeout
  #
  # @param value the value to set the attribute default_navigation_timeout to.
  #
  # source://playwright-ruby-client//lib/playwright/timeout_settings.rb#10
  def default_navigation_timeout=(_arg0); end

  # Sets the attribute default_timeout
  #
  # @param value the value to set the attribute default_timeout to.
  #
  # source://playwright-ruby-client//lib/playwright/timeout_settings.rb#10
  def default_timeout=(_arg0); end

  # source://playwright-ruby-client//lib/playwright/timeout_settings.rb#20
  def launch_timeout(timeout_override = T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/timeout_settings.rb#12
  def navigation_timeout(timeout_override = T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/timeout_settings.rb#16
  def timeout(timeout_override = T.unsafe(nil)); end
end

# 3 minutes
#
# source://playwright-ruby-client//lib/playwright/timeout_settings.rb#4
Playwright::TimeoutSettings::DEFAULT_LAUNCH_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://playwright-ruby-client//lib/playwright/timeout_settings.rb#3
Playwright::TimeoutSettings::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The Touchscreen class operates in main-frame CSS pixels relative to the top-left corner of the viewport. Methods on the
# touchscreen can only be used in browser contexts that have been initialized with `hasTouch` set to true.
#
# This class is limited to emulating tap gestures. For examples of other gestures simulated by manually dispatching touch events, see the [emulating legacy touch events](../touch-events.md) page.
#
# source://playwright-ruby-client//lib/playwright_api/touchscreen.rb#7
class Playwright::Touchscreen < ::Playwright::PlaywrightApi
  # Dispatches a `touchstart` and `touchend` event with a single touch at the position (`x`,`y`).
  #
  # **NOTE**: [`method: Page.tap`] the method will throw if `hasTouch` option of the browser context is false.
  #
  # source://playwright-ruby-client//lib/playwright_api/touchscreen.rb#13
  def tap_point(x, y); end
end

# source://playwright-ruby-client//lib/playwright/touchscreen_impl.rb#0
class Playwright::TouchscreenImpl
  include ::Playwright::ApiImplementation

  # source://playwright-ruby-client//lib/playwright/touchscreen_impl.rb#3
  def initialize(channel); end

  # source://playwright-ruby-client//lib/playwright/touchscreen_impl.rb#7
  def tap_point(x, y); end
end

# API for collecting and saving Playwright traces. Playwright traces can be opened in [Trace Viewer](../trace-viewer.md) after Playwright script runs.
#
# **NOTE**: You probably want to [enable tracing in your config file](https://playwright.dev/docs/api/class-testoptions#test-options-trace) instead of using `context.tracing`.
#
# The `context.tracing` API captures browser operations and network activity, but it doesn't record test assertions (like `expect` calls). We recommend [enabling tracing through Playwright Test configuration](https://playwright.dev/docs/api/class-testoptions#test-options-trace), which includes those assertions and provides a more complete trace for debugging test failures.
#
# Start recording a trace before performing actions. At the end, stop tracing and save it to a file.
#
# ```python sync
# browser = chromium.launch()
# context = browser.new_context()
# context.tracing.start(screenshots=True, snapshots=True)
# page = context.new_page()
# page.goto("https://playwright.dev")
# context.tracing.stop(path = "trace.zip")
# ```
#
# source://playwright-ruby-client//lib/playwright_api/tracing.rb#19
class Playwright::Tracing < ::Playwright::PlaywrightApi
  # **NOTE**: Use `test.step` instead when available.
  #
  # Creates a new group within the trace, assigning any subsequent API calls to this group, until [`method: Tracing.groupEnd`] is called. Groups can be nested and will be visible in the trace viewer.
  #
  # **Usage**
  #
  # ```python sync
  # # All actions between group and group_end
  # # will be shown in the trace viewer as a group.
  # page.context.tracing.group("Open Playwright.dev > API")
  # page.goto("https://playwright.dev/")
  # page.get_by_role("link", name="API").click()
  # page.context.tracing.group_end()
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#84
  def group(name, location: T.unsafe(nil)); end

  # Closes the last group created by [`method: Tracing.group`].
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#90
  def group_end; end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#120
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#114
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#108
  def once(event, callback); end

  # Start tracing.
  #
  # **NOTE**: You probably want to [enable tracing in your config file](https://playwright.dev/docs/api/class-testoptions#test-options-trace) instead of using `Tracing.start`.
  #
  # The `context.tracing` API captures browser operations and network activity, but it doesn't record test assertions (like `expect` calls). We recommend [enabling tracing through Playwright Test configuration](https://playwright.dev/docs/api/class-testoptions#test-options-trace), which includes those assertions and provides a more complete trace for debugging test failures.
  #
  # **Usage**
  #
  # ```python sync
  # context.tracing.start(screenshots=True, snapshots=True)
  # page = context.new_page()
  # page.goto("https://playwright.dev")
  # context.tracing.stop(path = "trace.zip")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#36
  def start(name: T.unsafe(nil), screenshots: T.unsafe(nil), snapshots: T.unsafe(nil), sources: T.unsafe(nil), title: T.unsafe(nil)); end

  # Start a new trace chunk. If you'd like to record multiple traces on the same `BrowserContext`, use [`method: Tracing.start`] once, and then create multiple trace chunks with [`method: Tracing.startChunk`] and [`method: Tracing.stopChunk`].
  #
  # **Usage**
  #
  # ```python sync
  # context.tracing.start(screenshots=True, snapshots=True)
  # page = context.new_page()
  # page.goto("https://playwright.dev")
  #
  # context.tracing.start_chunk()
  # page.get_by_text("Get Started").click()
  # # Everything between start_chunk and stop_chunk will be recorded in the trace.
  # context.tracing.stop_chunk(path = "trace1.zip")
  #
  # context.tracing.start_chunk()
  # page.goto("http://example.com")
  # # Save a second trace file with different actions.
  # context.tracing.stop_chunk(path = "trace2.zip")
  # ```
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#65
  def start_chunk(name: T.unsafe(nil), title: T.unsafe(nil)); end

  # Stop tracing.
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#96
  def stop(path: T.unsafe(nil)); end

  # Stop the trace chunk. See [`method: Tracing.startChunk`] for more details about multiple trace chunks.
  #
  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#102
  def stop_chunk(path: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright_api/tracing.rb#124
  def event_emitter_proxy; end
end

# ref: https://github.com/microsoft/playwright-python/blob/master/playwright/_impl/_transport.py
#
# source://playwright-ruby-client//lib/playwright/transport.rb#9
class Playwright::Transport
  # @param playwright_cli_executable_path [String] path to playwright-cli.
  # @return [Transport] a new instance of Transport
  #
  # source://playwright-ruby-client//lib/playwright/transport.rb#11
  def initialize(playwright_cli_executable_path:); end

  # Start `playwright-cli run-driver`
  #
  # @note This method blocks until playwright-cli exited. Consider using Thread or Future.
  #
  # source://playwright-ruby-client//lib/playwright/transport.rb#52
  def async_run; end

  # source://playwright-ruby-client//lib/playwright/transport.rb#21
  def on_driver_closed(&block); end

  # source://playwright-ruby-client//lib/playwright/transport.rb#25
  def on_driver_crashed(&block); end

  # source://playwright-ruby-client//lib/playwright/transport.rb#17
  def on_message_received(&block); end

  # @param message [Hash]
  #
  # source://playwright-ruby-client//lib/playwright/transport.rb#32
  def send_message(message); end

  # Terminate playwright-cli driver.
  #
  # source://playwright-ruby-client//lib/playwright/transport.rb#44
  def stop; end

  private

  # source://playwright-ruby-client//lib/playwright/transport.rb#123
  def debug_recv_message(message); end

  # source://playwright-ruby-client//lib/playwright/transport.rb#117
  def debug_send_message(message); end

  # source://playwright-ruby-client//lib/playwright/transport.rb#93
  def handle_stderr; end

  # source://playwright-ruby-client//lib/playwright/transport.rb#74
  def handle_stdout(packet_size: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/transport.rb#62
  def run_driver_with_open3; end

  # source://playwright-ruby-client//lib/playwright/transport.rb#127
  def shorten_double_quoted_string(message, maxlen: T.unsafe(nil)); end
end

# source://playwright-ruby-client//lib/playwright/transport.rb#29
class Playwright::Transport::AlreadyDisconnectedError < ::StandardError; end

# source://playwright-ruby-client//lib/playwright/url_matcher.rb#2
class Playwright::UrlMatcher
  # @param url [String|Regexp]
  # @param base_url [String|nil]
  # @return [UrlMatcher] a new instance of UrlMatcher
  #
  # source://playwright-ruby-client//lib/playwright/url_matcher.rb#5
  def initialize(url, base_url:); end

  # source://playwright-ruby-client//lib/playwright/url_matcher.rb#10
  def as_pattern; end

  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/url_matcher.rb#22
  def match?(target_url); end

  private

  # source://playwright-ruby-client//lib/playwright/url_matcher.rb#33
  def joined_url; end
end

# source://playwright-ruby-client//lib/playwright/utils.rb#4
module Playwright::Utils; end

# source://playwright-ruby-client//lib/playwright/utils.rb#63
module Playwright::Utils::Errors; end

# source://playwright-ruby-client//lib/playwright/utils.rb#64
module Playwright::Utils::Errors::TargetClosedErrorMethods
  private

  # @param err [Exception]
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright/utils.rb#66
  def target_closed_error?(err); end
end

# source://playwright-ruby-client//lib/playwright/utils.rb#5
module Playwright::Utils::PrepareBrowserContextOptions
  private

  # @see https://github.com/microsoft/playwright/blob/5a2cfdbd47ed3c3deff77bb73e5fac34241f649d/src/client/browserContext.ts#L265
  #
  # source://playwright-ruby-client//lib/playwright/utils.rb#7
  def prepare_browser_context_options(params); end
end

# source://playwright-ruby-client//lib/playwright/version.rb#4
Playwright::VERSION = T.let(T.unsafe(nil), String)

# source://playwright-ruby-client//lib/playwright/video.rb#2
class Playwright::Video
  # @return [Video] a new instance of Video
  #
  # source://playwright-ruby-client//lib/playwright/video.rb#3
  def initialize(page); end

  # source://playwright-ruby-client//lib/playwright/video.rb#39
  def delete; end

  # source://playwright-ruby-client//lib/playwright/video.rb#24
  def path; end

  # source://playwright-ruby-client//lib/playwright/video.rb#33
  def save_as(path); end

  private

  # source://playwright-ruby-client//lib/playwright/video.rb#13
  def on_page_closed; end

  # called only from Page#on_video via send(:set_artifact, artifact)
  #
  # source://playwright-ruby-client//lib/playwright/video.rb#20
  def set_artifact(artifact); end

  # source://playwright-ruby-client//lib/playwright/video.rb#45
  def wait_for_artifact_and(&block); end
end

# ref: https://github.com/microsoft/playwright-python/blob/v1.40.0/playwright/_impl/_waiter.py
# ref: https://github.com/microsoft/playwright/blob/v1.40.0/packages/playwright-core/src/client/waiter.ts
#
# source://playwright-ruby-client//lib/playwright/waiter.rb#6
class Playwright::Waiter
  # @return [Waiter] a new instance of Waiter
  #
  # source://playwright-ruby-client//lib/playwright/waiter.rb#7
  def initialize(channel_owner, wait_name:); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#78
  def force_fulfill(result); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#118
  def log(message); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#43
  def reject_on_event(emitter, event, error_or_proc, predicate: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#59
  def reject_on_timeout(timeout_ms, message); end

  # Returns the value of attribute result.
  #
  # source://playwright-ruby-client//lib/playwright/waiter.rb#116
  def result; end

  # @param [Playwright::EventEmitter]
  # @param
  #
  # source://playwright-ruby-client//lib/playwright/waiter.rb#100
  def wait_for_event(emitter, event, predicate: T.unsafe(nil)); end

  private

  # source://playwright-ruby-client//lib/playwright/waiter.rb#71
  def cleanup; end

  # @param logs [Array<String>]
  #
  # source://playwright-ruby-client//lib/playwright/waiter.rb#137
  def format_log_recording(logs); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#82
  def fulfill(result); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#89
  def reject(error); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#30
  def wait_for_event_info_after(error: T.unsafe(nil)); end

  # source://playwright-ruby-client//lib/playwright/waiter.rb#17
  def wait_for_event_info_before; end
end

# source://playwright-ruby-client//lib/playwright/errors.rb#62
class Playwright::WebError
  # @return [WebError] a new instance of WebError
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#63
  def initialize(error, page); end

  # Returns the value of attribute error.
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#68
  def error; end

  # Returns the value of attribute page.
  #
  # source://playwright-ruby-client//lib/playwright/errors.rb#68
  def page; end
end

# The `WebSocket` class represents WebSocket connections within a page. It provides the ability to inspect and manipulate the data being transmitted and received.
#
# If you want to intercept or modify WebSocket frames, consider using `WebSocketRoute`.
#
# source://playwright-ruby-client//lib/playwright_api/web_socket.rb#6
class Playwright::WebSocket < ::Playwright::PlaywrightApi
  # Indicates that the web socket has been closed.
  #
  # @return [Boolean]
  #
  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#10
  def closed?; end

  # Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
  # value. Will throw an error if the webSocket is closed before the event is fired. Returns the event data value.
  #
  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#23
  def expect_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#51
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#45
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#39
  def once(event, callback); end

  # Contains the URL of the WebSocket.
  #
  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#16
  def url; end

  # **NOTE**: In most cases, you should use [`method: WebSocket.waitForEvent`].
  #
  # Waits for given `event` to fire. If predicate is provided, it passes
  # event's value into the `predicate` function and waits for `predicate(event)` to return a truthy value.
  # Will throw an error if the socket is closed before the `event` is fired.
  #
  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#33
  def wait_for_event(event, predicate: T.unsafe(nil), timeout: T.unsafe(nil), &block); end

  private

  # source://playwright-ruby-client//lib/playwright_api/web_socket.rb#55
  def event_emitter_proxy; end
end

# The Worker class represents a [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API). `worker`
# event is emitted on the page object to signal a worker creation. `close` event is emitted on the worker object when the
# worker is gone.
#
# ```py
# def handle_worker(worker):
#     print("worker created: " + worker.url)
#     worker.on("close", lambda: print("worker destroyed: " + worker.url))
#
# page.on('worker', handle_worker)
#
# print("current workers:")
# for worker in page.workers:
#     print("    " + worker.url)
# ```
#
# source://playwright-ruby-client//lib/playwright_api/worker.rb#18
class Playwright::Worker < ::Playwright::PlaywrightApi
  # source://playwright-ruby-client//lib/playwright_api/worker.rb#55
  def context=(req); end

  # Returns the return value of `expression`.
  #
  # If the function passed to the [`method: Worker.evaluate`] returns a [Promise], then [`method: Worker.evaluate`] would wait for the promise
  # to resolve and return its value.
  #
  # If the function passed to the [`method: Worker.evaluate`] returns a non-[Serializable] value, then [`method: Worker.evaluate`] returns `undefined`. Playwright also supports transferring some
  # additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.
  #
  # source://playwright-ruby-client//lib/playwright_api/worker.rb#28
  def evaluate(expression, arg: T.unsafe(nil)); end

  # Returns the return value of `expression` as a `JSHandle`.
  #
  # The only difference between [`method: Worker.evaluate`] and
  # [`method: Worker.evaluateHandle`] is that [`method: Worker.evaluateHandle`]
  # returns `JSHandle`.
  #
  # If the function passed to the [`method: Worker.evaluateHandle`] returns a [Promise], then [`method: Worker.evaluateHandle`] would wait for
  # the promise to resolve and return its value.
  #
  # source://playwright-ruby-client//lib/playwright_api/worker.rb#41
  def evaluate_handle(expression, arg: T.unsafe(nil)); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/worker.rb#73
  def off(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/worker.rb#67
  def on(event, callback); end

  # -- inherited from EventEmitter --
  #
  # source://playwright-ruby-client//lib/playwright_api/worker.rb#61
  def once(event, callback); end

  # source://playwright-ruby-client//lib/playwright_api/worker.rb#50
  def page=(req); end

  # source://playwright-ruby-client//lib/playwright_api/worker.rb#45
  def url; end

  private

  # source://playwright-ruby-client//lib/playwright_api/worker.rb#77
  def event_emitter_proxy; end
end
