# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-core` gem.
# Please instead update this file by running `bin/tapioca gem dry-core`.


# source://dry-core//lib/dry/core/constants.rb#5
module Dry
  class << self
    # Build an equalizer module for the inclusion in other class
    #
    # ## Credits
    #
    # Equalizer has been originally imported from the equalizer gem created by Dan Kubb
    #
    # @api public
    #
    # source://dry-core//lib/dry/core/equalizer.rb#11
    def Equalizer(*keys, **options); end

    # source://dry-struct/1.4.0/lib/dry/struct.rb#33
    def Struct(attributes = T.unsafe(nil), &block); end

    # source://dry-types/1.5.1/lib/dry/types.rb#226
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# source://dry-core//lib/dry/core/constants.rb#6
module Dry::Core; end

# Internal support module for class-level settings
#
# @api public
#
# source://dry-core//lib/dry/core/class_attributes.rb#11
module Dry::Core::ClassAttributes
  include ::Dry::Core::Constants

  # Specify what attributes a class will use
  #
  # @api public
  # @example
  #   class ExtraClass
  #   extend Dry::Core::ClassAttributes
  #
  #   defines :hello
  #
  #   hello 'world'
  #   end
  # @example with inheritance and type checking
  #
  #   class MyClass
  #   extend Dry::Core::ClassAttributes
  #
  #   defines :one, :two, type: Integer
  #
  #   one 1
  #   two 2
  #   end
  #
  #   class OtherClass < MyClass
  #   two 3
  #   end
  #
  #   MyClass.one # => 1
  #   MyClass.two # => 2
  #
  #   OtherClass.one # => 1
  #   OtherClass.two # => 3
  # @example with dry-types
  #
  #   class Foo
  #   extend Dry::Core::ClassAttributes
  #
  #   defines :one, :two, type: Dry::Types['strict.int']
  #   end
  # @example with coercion using Proc
  #
  #   class Bar
  #   extend Dry::Core::ClassAttributes
  #
  #   defines :one, coerce: proc { |value| value.to_s }
  #   end
  # @example with coercion using dry-types
  #
  #   class Bar
  #   extend Dry::Core::ClassAttributes
  #
  #   defines :one, coerce: Dry::Types['coercible.string']
  #   end
  #
  # source://dry-core//lib/dry/core/class_attributes.rb#70
  def defines(*args, type: T.unsafe(nil), coerce: T.unsafe(nil)); end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::Undefined = T.let(T.unsafe(nil), Object)

# A list of constants you can use to avoid memory allocations or identity checks.
#
# @api public
# @example Just include this module to your class or module
#   class Foo
#   include Dry::Core::Constants
#   def call(value = EMPTY_ARRAY)
#   value.map(&:to_s)
#   end
#   end
#
# source://dry-core//lib/dry/core/constants.rb#18
module Dry::Core::Constants
  class << self
    # @api public
    # @private
    #
    # source://dry-core//lib/dry/core/constants.rb#108
    def included(base); end
  end
end

# An empty array
#
# @api public
#
# source://dry-core//lib/dry/core/constants.rb#20
Dry::Core::Constants::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# An empty hash
#
# @api public
#
# source://dry-core//lib/dry/core/constants.rb#22
Dry::Core::Constants::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# An empty list of options
#
# @api public
#
# source://dry-core//lib/dry/core/constants.rb#24
Dry::Core::Constants::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# An empty set
#
# @api public
#
# source://dry-core//lib/dry/core/constants.rb#26
Dry::Core::Constants::EMPTY_SET = T.let(T.unsafe(nil), Set)

# An empty string
#
# @api public
#
# source://dry-core//lib/dry/core/constants.rb#28
Dry::Core::Constants::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Identity function
#
# @api public
#
# source://dry-core//lib/dry/core/constants.rb#30
Dry::Core::Constants::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#45
Dry::Core::Constants::Self = T.let(T.unsafe(nil), Proc)

# A special value you can use as a default to know if no arguments
# were passed to the method
#
# @api public
# @example
#   def method(value = Undefined)
#   if Undefined.equal?(value)
#   puts 'no args'
#   else
#   puts value
#   end
#   end
#
# source://dry-core//lib/dry/core/constants.rb#43
Dry::Core::Constants::Undefined = T.let(T.unsafe(nil), Object)

# An extension for issueing warnings on using deprecated methods.
#
# @api public
# @example
#
#   class Foo
#   def self.old_class_api; end
#   def self.new_class_api; end
#
#   deprecate_class_method :old_class_api, :new_class_api
#
#   def old_api; end
#   def new_api; end
#
#   deprecate :old_api, :new_api, message: "old_api is no-no"
#   end
# @example You also can use this module for your custom messages
#
#   Dry::Core::Deprecations.announce("Foo", "use bar instead")
#   Dry::Core::Deprecations.warn("Baz is going to be removed soon")
#
# source://dry-core//lib/dry/core/deprecations.rb#29
module Dry::Core::Deprecations
  class << self
    # @api public
    #
    # source://dry-core//lib/dry/core/deprecations.rb#105
    def [](tag); end

    # Wraps arguments with a standard message format and prints a warning
    #
    # @api public
    # @param name [Object] what is deprecated
    # @param msg [String] additional message usually containing upgrade instructions
    #
    # source://dry-core//lib/dry/core/deprecations.rb#45
    def announce(name, msg, tag: T.unsafe(nil)); end

    # @api private
    #
    # source://dry-core//lib/dry/core/deprecations.rb#58
    def deprecated_name_message(old, new = T.unsafe(nil), msg = T.unsafe(nil)); end

    # @api private
    #
    # source://dry-core//lib/dry/core/deprecations.rb#50
    def deprecation_message(name, msg); end

    # Returns the logger used for printing warnings.
    # You can provide your own with .set_logger!
    #
    # @api public
    # @param output [IO] output stream
    # @return [Logger]
    #
    # source://dry-core//lib/dry/core/deprecations.rb#75
    def logger(output = T.unsafe(nil)); end

    # Sets a custom logger. This is a global setting.
    #
    # @api public
    # @overload set_logger!
    # @overload set_logger!
    # @overload set_logger!
    #
    # source://dry-core//lib/dry/core/deprecations.rb#95
    def set_logger!(output = T.unsafe(nil)); end

    # Prints a warning
    #
    # @api public
    # @param msg [String] Warning string
    #
    # source://dry-core//lib/dry/core/deprecations.rb#36
    def warn(msg, tag: T.unsafe(nil)); end
  end
end

# @api public
#
# source://dry-core//lib/dry/core/deprecations.rb#122
module Dry::Core::Deprecations::Interface
  # Mark instance method as deprecated
  #
  # @api public
  # @option [String]
  # @param old_name [Symbol] deprecated method
  # @param new_name [Symbol] replacement (not required)
  # @param [String] [Hash] a customizable set of options
  #
  # source://dry-core//lib/dry/core/deprecations.rb#146
  def deprecate(old_name, new_name = T.unsafe(nil), message: T.unsafe(nil)); end

  # Mark class-level method as deprecated
  #
  # @api public
  # @option [String]
  # @param old_name [Symbol] deprecated method
  # @param new_name [Symbol] replacement (not required)
  # @param [String] [Hash] a customizable set of options
  #
  # source://dry-core//lib/dry/core/deprecations.rb#179
  def deprecate_class_method(old_name, new_name = T.unsafe(nil), message: T.unsafe(nil)); end

  # Mark a constant as deprecated
  #
  # @api public
  # @option [String]
  # @param constant_name [Symbol] constant name to be deprecated
  # @param [String] [Hash] a customizable set of options
  #
  # source://dry-core//lib/dry/core/deprecations.rb#201
  def deprecate_constant(constant_name, message: T.unsafe(nil)); end

  # Sets/gets deprecation tag
  #
  # @api public
  # @option [String,Symbol]
  # @param [String,Symbol] [Hash] a customizable set of options
  #
  # source://dry-core//lib/dry/core/deprecations.rb#126
  def deprecation_tag(tag = T.unsafe(nil)); end

  # Issue a tagged warning message
  #
  # @api public
  # @param msg [String] warning message
  #
  # source://dry-core//lib/dry/core/deprecations.rb#137
  def warn(msg); end
end

# @api public
#
# source://dry-core//lib/dry/core/deprecations.rb#30
Dry::Core::Deprecations::STACK = T.let(T.unsafe(nil), Proc)

# @api private
#
# source://dry-core//lib/dry/core/deprecations.rb#111
class Dry::Core::Deprecations::Tagged < ::Module
  # @api private
  # @return [Tagged] a new instance of Tagged
  #
  # source://dry-core//lib/dry/core/deprecations.rb#112
  def initialize(tag); end

  # @api private
  #
  # source://dry-core//lib/dry/core/deprecations.rb#116
  def extended(base); end
end

# An implementation of descendants tracker, heavily inspired
# by the descendants_tracker gem.
#
# @example
#
#   class Base
#   extend Dry::Core::DescendantsTracker
#   end
#
#   class A < Base
#   end
#
#   class B < Base
#   end
#
#   class C < A
#   end
#
#   Base.descendants # => [C, B, A]
#   A.descendants # => [C]
#   B.descendants # => []
#
# source://dry-core//lib/dry/core/descendants_tracker.rb#29
module Dry::Core::DescendantsTracker
  # Return the descendants of this class
  #
  # @api public
  # @example
  #   descendants = Parent.descendants
  # @return [Array<Class>]
  #
  # source://dry-core//lib/dry/core/descendants_tracker.rb#54
  def descendants; end

  protected

  # @api private
  #
  # source://dry-core//lib/dry/core/descendants_tracker.rb#59
  def add_descendant(descendant); end

  private

  # @api private
  #
  # source://dry-core//lib/dry/core/descendants_tracker.rb#70
  def inherited(descendant); end

  class << self
    # @api private
    #
    # source://dry-core//lib/dry/core/descendants_tracker.rb#32
    def setup(target); end

    private

    # @api private
    # @private
    #
    # source://dry-core//lib/dry/core/descendants_tracker.rb#39
    def extended(base); end
  end
end

# Define equality, equivalence and inspection methods
#
# source://dry-core//lib/dry/core/equalizer.rb#30
class Dry::Core::Equalizer < ::Module
  # Initialize an Equalizer with the given keys
  #
  # Will use the keys with which it is initialized to define #cmp?,
  # #hash, and #inspect
  #
  # @api private
  # @option options
  # @option options
  # @param keys [Array<Symbol>]
  # @param options [Hash]
  # @return [undefined]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#31
  def initialize(*keys, **options); end

  private

  # Define an #cmp? method based on the instance's values identified by #keys
  #
  # @api private
  # @return [undefined]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#71
  def define_cmp_method; end

  # Define a #hash method based on the instance's values identified by #keys
  #
  # @api private
  # @return [undefined]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#86
  def define_hash_method(immutable:); end

  # Define an inspect method that reports the values of the instance's keys
  #
  # @api private
  # @return [undefined]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#108
  def define_inspect_method; end

  # Define the equalizer methods based on #keys
  #
  # @api private
  # @param inspect [Boolean] whether to define #inspect method
  # @param immutable [Boolean] whether to memoize #hash method
  # @return [undefined]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#60
  def define_methods(inspect: T.unsafe(nil), immutable: T.unsafe(nil)); end

  # Hook called when module is included
  #
  # @api private
  # @param descendant [Module] the module or class including Equalizer
  # @return [self]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#47
  def included(descendant); end
end

# The comparison methods
#
# source://dry-core//lib/dry/core/equalizer.rb#118
module Dry::Core::Equalizer::Methods
  # Compare the object with other object for equivalency
  #
  # @api public
  # @example
  #   object == other  # => true or false
  # @param other [Object] the other object to compare with
  # @return [Boolean]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#145
  def ==(other); end

  # Compare the object with other object for equality
  #
  # @api public
  # @example
  #   object.eql?(other)  # => true or false
  # @param other [Object] the other object to compare with
  # @return [Boolean]
  #
  # source://dry-core//lib/dry/core/equalizer.rb#130
  def eql?(other); end
end

# Define extensions that can be later enabled by the user.
#
# @example
#
#   class Foo
#   extend Dry::Core::Extensions
#
#   register_extension(:bar) do
#   def bar; :bar end
#   end
#   end
#
#   Foo.new.bar # => NoMethodError
#   Foo.load_extensions(:bar)
#   Foo.new.bar # => :bar
#
# source://dry-core//lib/dry/core/extensions.rb#23
module Dry::Core::Extensions
  # Whether an extension is available
  #
  # @param name [Symbol] extension name
  # @return [Boolean] Extension availability
  #
  # source://dry-core//lib/dry/core/extensions.rb#43
  def available_extension?(name); end

  # Enables specified extensions. Already enabled extensions remain untouched
  #
  # @param extensions [Array<Symbol>] list of extension names
  #
  # source://dry-core//lib/dry/core/extensions.rb#50
  def load_extensions(*extensions); end

  # Register an extension
  #
  # @param name [Symbol] extension name
  # @yield extension block. This block guaranteed not to be called more than once
  #
  # source://dry-core//lib/dry/core/extensions.rb#35
  def register_extension(name, &block); end

  class << self
    # @api private
    # @private
    #
    # source://dry-core//lib/dry/core/extensions.rb#25
    def extended(obj); end
  end
end

# Helper module providing thin interface around an inflection backend.
#
# source://dry-core//lib/dry/core/inflector.rb#6
module Dry::Core::Inflector
  class << self
    # Transform string to camel case
    #
    # @example
    #   Dry::Core::Inflector.camelize('foo_bar') # => 'FooBar'
    # @param input [String] input string
    # @return Transformed string
    #
    # source://dry-core//lib/dry/core/inflector.rb#70
    def camelize(input); end

    # Transform a file path to a constant name
    #
    # @example
    #   Dry::Core::Inflector.classify('foo/bar') # => 'Foo::Bar'
    # @param input [String] input string
    # @return Constant name
    #
    # source://dry-core//lib/dry/core/inflector.rb#136
    def classify(input); end

    # Get a constant value by its name
    #
    # @example
    #   Dry::Core::Inflector.constantize('Foo::Bar') # => Foo::Bar
    # @param input [String] input constant name
    # @return Constant value
    #
    # source://dry-core//lib/dry/core/inflector.rb#125
    def constantize(input); end

    # Remove namespaces from a constant name
    #
    # @example
    #   Dry::Core::Inflector.demodulize('Deeply::Nested::Name') # => 'Name'
    # @param input [String] input string
    # @return Unnested constant name
    #
    # source://dry-core//lib/dry/core/inflector.rb#114
    def demodulize(input); end

    # Set up first available backend
    #
    # @api private
    #
    # source://dry-core//lib/dry/core/inflector.rb#37
    def detect_backend; end

    # Inflector accessor. Lazily initializes a backend
    #
    # @api private
    #
    # source://dry-core//lib/dry/core/inflector.rb#59
    def inflector; end

    # Get a plural form of a word
    #
    # @example
    #   Dry::Core::Inflector.pluralize('string') # => 'strings'
    # @param input [String] input string
    # @return Transformed string
    #
    # source://dry-core//lib/dry/core/inflector.rb#103
    def pluralize(input); end

    # Try to activate a backend
    #
    # @api private
    #
    # source://dry-core//lib/dry/core/inflector.rb#26
    def realize_backend(path, backend_factory); end

    # Set preferred backend
    #
    # @param name [Symbol] backend name (:activesupport or :inflecto)
    #
    # source://dry-core//lib/dry/core/inflector.rb#48
    def select_backend(name = T.unsafe(nil)); end

    # Get a singlular form of a word
    #
    # @example
    #   Dry::Core::Inflector.singularize('chars') # => 'char'
    # @param input [String] input string
    # @return Transformed string
    #
    # source://dry-core//lib/dry/core/inflector.rb#92
    def singularize(input); end

    # Transform string to snake case
    #
    # @example
    #   Dry::Core::Inflector.underscore('FooBar') # => 'foo_bar'
    # @param input [String] input string
    # @return Transformed string
    #
    # source://dry-core//lib/dry/core/inflector.rb#81
    def underscore(input); end
  end
end

# List of supported backends
#
# source://dry-core//lib/dry/core/inflector.rb#8
Dry::Core::Inflector::BACKENDS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/errors.rb#5
class Dry::Core::InvalidClassAttributeValue < ::StandardError
  # @return [InvalidClassAttributeValue] a new instance of InvalidClassAttributeValue
  #
  # source://dry-core//lib/dry/core/errors.rb#6
  def initialize(name, value); end
end

module Dry::Types
  extend ::Dry::Core::Constants

  class << self
    # source://dry-types/1.5.1/lib/dry/types/constraints.rb#17
    def Rule(options); end

    # source://dry-types/1.5.1/lib/dry/types.rb#88
    def [](name); end

    # source://dry-types/1.5.1/lib/dry/types.rb#136
    def const_missing(const); end

    # source://dry-types/1.5.1/lib/dry/types.rb#55
    def container; end

    # source://dry-types/1.5.1/lib/dry/types.rb#170
    def define_builder(method, &block); end

    # source://dry-types/1.5.1/lib/dry/types.rb#122
    def identifier(klass); end

    # source://dry-types/1.5.1/lib/dry/types.rb#46
    def included(*_arg0); end

    # source://dry-core//lib/dry/core/deprecations.rb#191
    def module(*args, &block); end

    # source://dry-types/1.5.1/lib/dry/types.rb#77
    def register(name, type = T.unsafe(nil), &block); end

    # source://dry-types/1.5.1/lib/dry/types.rb#64
    def registered?(class_or_identifier); end

    # source://dry-types/1.5.1/lib/dry/types/constraints.rb#30
    def rule_compiler; end

    # source://dry-types/1.5.1/lib/dry/types.rb#131
    def type_map; end
  end
end

class Dry::Types::Compiler
  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#13
  def initialize(registry); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#17
  def call(ast); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#118
  def compile_fn(fn); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#11
  def registry; end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#21
  def visit(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#114
  def visit_any(meta); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#63
  def visit_array(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#26
  def visit_constrained(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#32
  def visit_constructor(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#104
  def visit_enum(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#69
  def visit_hash(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#84
  def visit_json_array(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#79
  def visit_json_hash(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#99
  def visit_key(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#38
  def visit_lax(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#109
  def visit_map(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#43
  def visit_nominal(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#94
  def visit_params_array(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#89
  def visit_params_hash(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#54
  def visit_rule(node); end

  # source://dry-core//lib/dry/core/deprecations.rb#157
  def visit_safe(*args, &block); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#74
  def visit_schema(node); end

  # source://dry-types/1.5.1/lib/dry/types/compiler.rb#58
  def visit_sum(node); end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::Self = T.let(T.unsafe(nil), Proc)

module Dry::Types::Type
  # source://dry-types/1.5.1/lib/dry/types/type.rb#20
  def ===(input = T.unsafe(nil)); end

  # source://dry-types/1.5.1/lib/dry/types/type.rb#45
  def [](input = T.unsafe(nil), &block); end

  # source://dry-types/1.5.1/lib/dry/types/type.rb#45
  def call(input = T.unsafe(nil), &block); end

  # source://dry-core//lib/dry/core/deprecations.rb#157
  def safe(*args, &block); end

  # source://dry-types/1.5.1/lib/dry/types/type.rb#20
  def valid?(input = T.unsafe(nil)); end
end

# source://dry-core//lib/dry/core/constants.rb#112
Dry::Types::Undefined = T.let(T.unsafe(nil), Object)
