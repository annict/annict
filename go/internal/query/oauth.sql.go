// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: oauth.sql

package query

import (
	"context"
	"database/sql"
	"time"
)

const createOAuthAccessToken = `-- name: CreateOAuthAccessToken :one
INSERT INTO oauth_access_tokens (
	resource_owner_id, application_id, token,
	refresh_token, expires_in, revoked_at,
	created_at, scopes, previous_refresh_token,
	description
) VALUES (
	$1, $2, $3,
	$4, $5, $6,
	$7, $8, $9,
	$10
) RETURNING id
`

type CreateOAuthAccessTokenParams struct {
	ResourceOwnerID      int64          `db:"resource_owner_id"`
	ApplicationID        sql.NullInt64  `db:"application_id"`
	Token                string         `db:"token"`
	RefreshToken         sql.NullString `db:"refresh_token"`
	ExpiresIn            sql.NullInt32  `db:"expires_in"`
	RevokedAt            sql.NullTime   `db:"revoked_at"`
	CreatedAt            time.Time      `db:"created_at"`
	Scopes               sql.NullString `db:"scopes"`
	PreviousRefreshToken string         `db:"previous_refresh_token"`
	Description          string         `db:"description"`
}

func (q *Queries) CreateOAuthAccessToken(ctx context.Context, arg CreateOAuthAccessTokenParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createOAuthAccessToken,
		arg.ResourceOwnerID,
		arg.ApplicationID,
		arg.Token,
		arg.RefreshToken,
		arg.ExpiresIn,
		arg.RevokedAt,
		arg.CreatedAt,
		arg.Scopes,
		arg.PreviousRefreshToken,
		arg.Description,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createOAuthApplication = `-- name: CreateOAuthApplication :one
INSERT INTO oauth_applications (
	name, uid, secret, redirect_uri, scopes,
	aasm_state, created_at, updated_at,
	owner_id, owner_type, confidential,
	hide_social_login
) VALUES (
	$1, $2, $3, $4, $5,
	$6, $7, $8,
	$9, $10, $11,
	$12
) RETURNING id
`

type CreateOAuthApplicationParams struct {
	Name            string         `db:"name"`
	Uid             string         `db:"uid"`
	Secret          string         `db:"secret"`
	RedirectUri     string         `db:"redirect_uri"`
	Scopes          string         `db:"scopes"`
	AasmState       string         `db:"aasm_state"`
	CreatedAt       sql.NullTime   `db:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at"`
	OwnerID         sql.NullInt64  `db:"owner_id"`
	OwnerType       sql.NullString `db:"owner_type"`
	Confidential    bool           `db:"confidential"`
	HideSocialLogin bool           `db:"hide_social_login"`
}

func (q *Queries) CreateOAuthApplication(ctx context.Context, arg CreateOAuthApplicationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createOAuthApplication,
		arg.Name,
		arg.Uid,
		arg.Secret,
		arg.RedirectUri,
		arg.Scopes,
		arg.AasmState,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.OwnerID,
		arg.OwnerType,
		arg.Confidential,
		arg.HideSocialLogin,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOAuthApplicationByUID = `-- name: GetOAuthApplicationByUID :one
SELECT id, name, uid, secret, redirect_uri, scopes,
	aasm_state, created_at, updated_at,
	owner_id, owner_type, confidential,
	hide_social_login, deleted_at
FROM oauth_applications
WHERE uid = $1
LIMIT 1
`

type GetOAuthApplicationByUIDRow struct {
	ID              int64          `db:"id"`
	Name            string         `db:"name"`
	Uid             string         `db:"uid"`
	Secret          string         `db:"secret"`
	RedirectUri     string         `db:"redirect_uri"`
	Scopes          string         `db:"scopes"`
	AasmState       string         `db:"aasm_state"`
	CreatedAt       sql.NullTime   `db:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at"`
	OwnerID         sql.NullInt64  `db:"owner_id"`
	OwnerType       sql.NullString `db:"owner_type"`
	Confidential    bool           `db:"confidential"`
	HideSocialLogin bool           `db:"hide_social_login"`
	DeletedAt       sql.NullTime   `db:"deleted_at"`
}

func (q *Queries) GetOAuthApplicationByUID(ctx context.Context, uid string) (GetOAuthApplicationByUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOAuthApplicationByUID, uid)
	var i GetOAuthApplicationByUIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Uid,
		&i.Secret,
		&i.RedirectUri,
		&i.Scopes,
		&i.AasmState,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.OwnerType,
		&i.Confidential,
		&i.HideSocialLogin,
		&i.DeletedAt,
	)
	return i, err
}
