// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: works.sql

package query

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getCastsByWorkIDs = `-- name: GetCastsByWorkIDs :many
SELECT
    c.id,
    c.work_id,
    c.name,
    c.name_en,
    c.sort_number,
    ch.name as character_name,
    ch.name_en as character_name_en,
    p.name as person_name,
    p.name_en as person_name_en
FROM casts c
LEFT JOIN characters ch ON c.character_id = ch.id
LEFT JOIN people p ON c.person_id = p.id
WHERE c.work_id = ANY($1::bigint[])
ORDER BY c.work_id, c.sort_number
`

type GetCastsByWorkIDsRow struct {
	ID              int64          `db:"id"`
	WorkID          int64          `db:"work_id"`
	Name            string         `db:"name"`
	NameEn          string         `db:"name_en"`
	SortNumber      int32          `db:"sort_number"`
	CharacterName   sql.NullString `db:"character_name"`
	CharacterNameEn sql.NullString `db:"character_name_en"`
	PersonName      sql.NullString `db:"person_name"`
	PersonNameEn    sql.NullString `db:"person_name_en"`
}

func (q *Queries) GetCastsByWorkIDs(ctx context.Context, dollar_1 []int64) ([]GetCastsByWorkIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCastsByWorkIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCastsByWorkIDsRow{}
	for rows.Next() {
		var i GetCastsByWorkIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.Name,
			&i.NameEn,
			&i.SortNumber,
			&i.CharacterName,
			&i.CharacterNameEn,
			&i.PersonName,
			&i.PersonNameEn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularWorks = `-- name: GetPopularWorks :many
SELECT
    w.id,
    w.title,
    w.title_en,
    w.recommended_image_url,
    wi.image_data,
    w.watchers_count,
    w.season_year,
    w.season_name,
    w.created_at
FROM works w
LEFT JOIN work_images wi ON w.id = wi.work_id
WHERE w.watchers_count > 0
ORDER BY w.watchers_count DESC, w.id DESC
LIMIT 30
`

type GetPopularWorksRow struct {
	ID                  int64          `db:"id"`
	Title               string         `db:"title"`
	TitleEn             string         `db:"title_en"`
	RecommendedImageUrl string         `db:"recommended_image_url"`
	ImageData           sql.NullString `db:"image_data"`
	WatchersCount       int32          `db:"watchers_count"`
	SeasonYear          sql.NullInt32  `db:"season_year"`
	SeasonName          sql.NullInt32  `db:"season_name"`
	CreatedAt           sql.NullTime   `db:"created_at"`
}

func (q *Queries) GetPopularWorks(ctx context.Context) ([]GetPopularWorksRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularWorks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularWorksRow{}
	for rows.Next() {
		var i GetPopularWorksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TitleEn,
			&i.RecommendedImageUrl,
			&i.ImageData,
			&i.WatchersCount,
			&i.SeasonYear,
			&i.SeasonName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaffsByWorkIDs = `-- name: GetStaffsByWorkIDs :many
SELECT
    s.id,
    s.work_id,
    s.name,
    s.name_en,
    s.role,
    s.role_other,
    s.role_other_en,
    s.sort_number
FROM staffs s
WHERE s.work_id = ANY($1::bigint[])
  AND s.role != 'other'
ORDER BY s.work_id, s.sort_number
`

type GetStaffsByWorkIDsRow struct {
	ID          int64          `db:"id"`
	WorkID      int64          `db:"work_id"`
	Name        string         `db:"name"`
	NameEn      string         `db:"name_en"`
	Role        string         `db:"role"`
	RoleOther   sql.NullString `db:"role_other"`
	RoleOtherEn string         `db:"role_other_en"`
	SortNumber  int32          `db:"sort_number"`
}

func (q *Queries) GetStaffsByWorkIDs(ctx context.Context, dollar_1 []int64) ([]GetStaffsByWorkIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStaffsByWorkIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStaffsByWorkIDsRow{}
	for rows.Next() {
		var i GetStaffsByWorkIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.Name,
			&i.NameEn,
			&i.Role,
			&i.RoleOther,
			&i.RoleOtherEn,
			&i.SortNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkByID = `-- name: GetWorkByID :one
SELECT
    id,
    title,
    title_en,
    title_kana,
    media,
    official_site_url,
    wikipedia_url,
    recommended_image_url,
    watchers_count,
    episodes_count,
    season_year,
    season_name,
    synopsis,
    created_at,
    updated_at
FROM works
WHERE id = $1
`

type GetWorkByIDRow struct {
	ID                  int64         `db:"id"`
	Title               string        `db:"title"`
	TitleEn             string        `db:"title_en"`
	TitleKana           string        `db:"title_kana"`
	Media               int32         `db:"media"`
	OfficialSiteUrl     string        `db:"official_site_url"`
	WikipediaUrl        string        `db:"wikipedia_url"`
	RecommendedImageUrl string        `db:"recommended_image_url"`
	WatchersCount       int32         `db:"watchers_count"`
	EpisodesCount       int32         `db:"episodes_count"`
	SeasonYear          sql.NullInt32 `db:"season_year"`
	SeasonName          sql.NullInt32 `db:"season_name"`
	Synopsis            string        `db:"synopsis"`
	CreatedAt           sql.NullTime  `db:"created_at"`
	UpdatedAt           sql.NullTime  `db:"updated_at"`
}

func (q *Queries) GetWorkByID(ctx context.Context, id int64) (GetWorkByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getWorkByID, id)
	var i GetWorkByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TitleEn,
		&i.TitleKana,
		&i.Media,
		&i.OfficialSiteUrl,
		&i.WikipediaUrl,
		&i.RecommendedImageUrl,
		&i.WatchersCount,
		&i.EpisodesCount,
		&i.SeasonYear,
		&i.SeasonName,
		&i.Synopsis,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
